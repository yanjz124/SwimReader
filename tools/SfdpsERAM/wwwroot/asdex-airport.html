<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ASDE-X</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
@font-face { font-family: 'ERAM'; src: url('ERAMv110.ttf') format('truetype'); }
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #393939; overflow: hidden; height: 100vh; }
#map { width: 100%; height: 100vh; background: #393939; transform-origin: center center; }

/* ── Status bar ── */
#statusbar {
    position: fixed; bottom: 0; left: 0; right: 0; z-index: 600;
    background: #111; border-top: 1px solid #333;
    display: flex; align-items: center; gap: 16px; padding: 4px 12px;
    font-family: 'ERAM', 'Consolas', monospace; font-size: 10px; color: #888;
}
#statusbar a { color: #444; text-decoration: none; }
#statusbar a:hover { color: #888; }
#statusbar .airport-id { color: #cccc44; font-size: 13px; letter-spacing: 2px; }
#conn { color: #ff4444; }
#conn.ok { color: #44aa44; }
#conn.waiting { color: #aaaa44; }
#statusbar label { color: #666; margin-right: -10px; }
#statusbar input[type=number] {
    width: 40px; background: #222; border: 1px solid #444; color: #ccc;
    font-family: inherit; font-size: 10px; text-align: center; padding: 1px 2px;
}
#statusbar button {
    background: #222; border: 1px solid #444; color: #ccc;
    font-family: inherit; font-size: 10px; padding: 1px 6px; cursor: pointer;
}
#statusbar button:hover { border-color: #888; }

/* ── Target icons — rendered as Leaflet divIcons ── */
.ac-icon {
    position: relative;
    overflow: visible;
    pointer-events: none;
}
.ac-icon svg.sym {
    display: block;
    overflow: visible;
    pointer-events: auto;
    cursor: none;
}
.ac-icon svg.sym:hover {
    filter: drop-shadow(0 0 4px rgba(255,255,255,0.8)) drop-shadow(0 0 8px rgba(255,255,255,0.4));
}
.ac-icon .ldr {
    position: absolute; left: 0; top: 0;
    overflow: visible; pointer-events: none;
}
.ac-icon .db-wrap {
    position: absolute;
    pointer-events: none;
}
.db {
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 13px; line-height: 16px;
    color: #00cc00;
    white-space: nowrap;
    padding: 0 2px;
    pointer-events: auto;
    cursor: none;
}
.db-line2 { color: #00cc00; }

/* hide Leaflet attribution noise */
.leaflet-control-attribution { display: none; }

/* ── Crosshair cursor ── */
#map { cursor: none !important; }
.leaflet-container { cursor: none !important; }
.leaflet-grab, .leaflet-dragging { cursor: none !important; }
.leaflet-marker-icon { cursor: none !important; }
#crosshair {
    position: fixed; pointer-events: none; z-index: 9999; display: none;
}
#crosshair .ch { position: absolute; background: #fff; }
#crosshair .h { width: 21px; height: 2px; left: -10px; top: -1px; }
#crosshair .v { width: 2px; height: 21px; left: -1px; top: -10px; }
</style>
</head>
<body>
<div id="map"></div>
<div id="crosshair"><div class="ch h"></div><div class="ch v"></div></div>
<div id="statusbar">
    <span class="airport-id" id="airport-id">—</span>
    <span id="track-count">0 tracks</span>
    <span id="conn">CONNECTING</span>
    <span style="flex:1"></span>
    <label>ROT</label>
    <input type="number" id="rot" min="0" max="360" value="360" step="1">
    <button id="dn-toggle">NIGHT</button>
    <a href="/asdex">◂ DIRECTORY</a>
</div>

<script>
// ── Crosshair cursor ────────────────────────────────────────────────────────
const ch = document.getElementById('crosshair');
document.addEventListener('mousemove', e => {
    ch.style.left = e.clientX + 'px';
    ch.style.top  = e.clientY + 'px';
    ch.style.display = 'block';
});
document.addEventListener('mouseleave', () => { ch.style.display = 'none'; });

// ── Map rotation ────────────────────────────────────────────────────────────
let mapRotation = 0; // degrees, 360=north-up
const rotInput = document.getElementById('rot');
function applyRotation(deg) {
    mapRotation = ((deg % 360) + 360) % 360;
    // 360 = north-up (no rotation). Rotation = -(360 - value) = value - 360
    const cssAngle = mapRotation === 360 ? 0 : -mapRotation;
    document.getElementById('map').style.transform = `rotate(${cssAngle}deg)`;
    // Counter-rotate data blocks so text stays upright
    document.querySelectorAll('.db').forEach(el => {
        el.style.transform = `rotate(${-cssAngle}deg)`;
    });
}
rotInput.addEventListener('input', () => applyRotation(parseInt(rotInput.value) || 360));

// ── Day/Night toggle ────────────────────────────────────────────────────────
const dnBtn = document.getElementById('dn-toggle');
dnBtn.addEventListener('click', () => {
    isNightMode = !isNightMode;
    asdexColors = isNightMode ? ASDEX_NIGHT : ASDEX_DAY;
    dnBtn.textContent = isNightMode ? 'NIGHT' : 'DAY';
    // Restyle surface polygons
    const bg = asdexColors.bg;
    document.getElementById('map').style.background = bg;
    document.body.style.background = bg;
    if (surfaceLayer) {
        surfaceLayer.setStyle(feature => {
            const sfc = (feature.properties && feature.properties.asdex) || 'structure';
            return {
                fillColor: asdexColors[sfc] || asdexColors.structure,
                fillOpacity: 1,
                color: asdexColors[sfc] || asdexColors.structure,
                weight: 0.5, opacity: 1
            };
        });
    }
});

// ── Airport from URL ─────────────────────────────────────────────────────────
const pathParts = window.location.pathname.split('/').filter(Boolean);
const AIRPORT = (pathParts[pathParts.length - 1] || 'UNKN').toUpperCase();
document.getElementById('airport-id').textContent = AIRPORT;
document.title = 'ASDE-X ' + AIRPORT;

// ── Leaflet map (right-click drag to pan) ───────────────────────────────────
const map = L.map('map', {
    center: [38.85, -77.04],
    zoom: 14,
    zoomControl: true,
    zoomSnap: 0.25,
    zoomDelta: 0.25,
    attributionControl: false,
    dragging: false
});

// Right-click drag panning
(function() {
    let panning = false, startX, startY;
    const el = map.getContainer();
    el.addEventListener('contextmenu', e => e.preventDefault());
    el.addEventListener('mousedown', e => {
        if (e.button !== 2) return;
        panning = true;
        startX = e.clientX;
        startY = e.clientY;
        e.preventDefault();
    });
    document.addEventListener('mousemove', e => {
        if (!panning) return;
        const dx = e.clientX - startX, dy = e.clientY - startY;
        startX = e.clientX; startY = e.clientY;
        map.panBy([-dx, -dy], { animate: false });
    });
    document.addEventListener('mouseup', e => {
        if (e.button === 2) panning = false;
    });
})();

// ── ASDEX surface colors (vNAS spec) ────────────────────────────────────────
const ASDEX_NIGHT = {
    bg:        '#393939',
    runway:    'rgb(0,0,0)',
    taxiway:   'rgb(17,39,80)',
    apron:     'rgb(18,55,97)',
    structure: 'rgb(34,63,103)'
};
const ASDEX_DAY = {
    bg:        '#005C73',
    runway:    'rgb(0,0,0)',
    taxiway:   'rgb(47,47,47)',
    apron:     'rgb(73,73,73)',
    structure: 'rgb(100,100,100)'
};
let asdexColors = ASDEX_NIGHT;
let isNightMode = true;
let surfaceLayer = null;

// ── Load airport surface GeoJSON ────────────────────────────────────────────
let surfaceLoaded = false;
fetch(`/asdex/maps/${AIRPORT}.geojson`)
    .then(r => { if (!r.ok) throw new Error(r.status); return r.json(); })
    .then(geojson => {
        surfaceLayer = L.geoJSON(geojson, {
            style: feature => {
                const sfc = (feature.properties && feature.properties.asdex) || 'structure';
                return {
                    fillColor: asdexColors[sfc] || asdexColors.structure,
                    fillOpacity: 1,
                    color: asdexColors[sfc] || asdexColors.structure,
                    weight: 0.5,
                    opacity: 1
                };
            },
            interactive: false
        }).addTo(map);
        map.fitBounds(surfaceLayer.getBounds(), { padding: [20, 20] });
        surfaceLoaded = true;
        centeredOnce = true;
    })
    .catch(() => {
        // No surface map — fall back to CartoDB dark tiles
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            subdomains: 'abcd', maxZoom: 20
        }).addTo(map);
    });

// ── State ────────────────────────────────────────────────────────────────────
const markers  = {};   // trackId → L.marker
const hashes   = {};   // trackId → hash string for change detection
let   trackCount = 0;
let   centeredOnce = false;

// ── Data block positions (8 compass points) ─────────────────────────────────
const DB_ORDERS = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];
const DB_POS = {
    N:  { wl: -5,  wt: -38, lx: 5,  ly: -12 },
    NE: { wl: 23,  wt: -15, lx: 23, ly: -5 },
    E:  { wl: 23,  wt: 1,   lx: 23, ly: 9 },
    SE: { wl: 23,  wt: 20,  lx: 23, ly: 23 },
    S:  { wl: -5,  wt: 28,  lx: 5,  ly: 26 },
    SW: { wl: -80, wt: 20,  lx: -5, ly: 23 },
    W:  { wl: -80, wt: 1,   lx: -5, ly: 9 },
    NW: { wl: -80, wt: -15, lx: -5, ly: -5 },
};
const dbPositions = {};  // trackId → 'N'|'NE'|..., default NE
const hiddenDbs = new Set();  // trackIds with hidden data blocks

// ── Data block drag (snap to 8 compass positions) ──────────────────────────
let dragTid = null, dragOrigin = null;

document.addEventListener('mousedown', e => {
    if (e.button !== 0) return;
    const db = e.target.closest('.db');
    if (!db) return;
    const icon = e.target.closest('.ac-icon[data-tid]');
    if (!icon) return;
    dragTid = icon.dataset.tid;
    const m = markers[dragTid];
    if (!m) { dragTid = null; return; }
    const el = m.getElement();
    if (!el) { dragTid = null; return; }
    const rect = el.getBoundingClientRect();
    dragOrigin = { x: rect.left + 9, y: rect.top + 9 };
    e.preventDefault();
    e.stopPropagation();
});

document.addEventListener('mousemove', e => {
    if (!dragTid) return;
    const sdx = e.clientX - dragOrigin.x;
    const sdy = e.clientY - dragOrigin.y;
    // Convert screen delta to icon-local (undo CSS rotation)
    const rad = mapRotation * Math.PI / 180;
    const ldx = sdx * Math.cos(rad) + sdy * Math.sin(rad);
    const ldy = -sdx * Math.sin(rad) + sdy * Math.cos(rad);
    // Snap to nearest octant
    let angle = Math.atan2(ldx, -ldy) * 180 / Math.PI;
    if (angle < 0) angle += 360;
    const idx = Math.round(angle / 45) % 8;
    const dir = DB_ORDERS[idx];
    if (dbPositions[dragTid] === dir) return;
    dbPositions[dragTid] = dir;
    // Update DOM live
    const iconEl = document.querySelector(`.ac-icon[data-tid="${dragTid}"]`);
    if (!iconEl) return;
    const pos = DB_POS[dir];
    const wrap = iconEl.querySelector('.db-wrap');
    if (wrap) { wrap.style.left = pos.wl + 'px'; wrap.style.top = pos.wt + 'px'; }
    const line = iconEl.querySelector('.ldr line');
    if (line) { line.setAttribute('x2', pos.lx); line.setAttribute('y2', pos.ly); }
});

document.addEventListener('mouseup', () => { dragTid = null; dragOrigin = null; });

// ── Left-click target to toggle data block ──────────────────────────────────
document.addEventListener('click', e => {
    const sym = e.target.closest('svg.sym');
    if (!sym) return;
    const icon = sym.closest('.ac-icon[data-tid]');
    if (!icon) return;
    const tid = icon.dataset.tid;
    if (hiddenDbs.has(tid)) hiddenDbs.delete(tid);
    else hiddenDbs.add(tid);
    const hidden = hiddenDbs.has(tid);
    const wrap = icon.querySelector('.db-wrap');
    const ldr = icon.querySelector('.ldr');
    if (wrap) wrap.style.display = hidden ? 'none' : '';
    if (ldr) ldr.style.display = hidden ? 'none' : '';
});

const connEl  = document.getElementById('conn');
const cntEl   = document.getElementById('track-count');

// ── Heavy-type detection (client-side from ICAO type code) ───────────────────
const HEAVY_PREFIXES = ['B74','B77','B78','A33','A34','A35','A38','A30',
                        'A22','C17','C5M','IL7','AN1','DC8','L101'];
const B757_CODES     = ['B752','B753','B757'];

function targetCategory(t) {
    // unknown = no callsign/squawk, OR tgtType explicitly unknown
    if (t.tgtType === 'unknown') return 'unknown';
    if (t.tgtType === 'vehicle') return 'vehicle';
    if (!t.callsign && !t.squawk) return 'unknown';
    if (t.acType) {
        const ac = t.acType.toUpperCase();
        if (B757_CODES.includes(ac)) return 'heavy';
        for (const pfx of HEAVY_PREFIXES) if (ac.startsWith(pfx)) return 'heavy';
    }
    return 'aircraft';
}

// ── SVG path for airplane (pointing up = heading 0°) ─────────────────────────
// Fuselage + swept wings + V-tail. ViewBox centered on 0,0, nose at top.
const PLANE_PATH = 'M 0 -8 L 1.5 -3 L 7.5 1.5 L 2 2.5 L 2 5.5 L 3.5 7 L 0 6.5 L -3.5 7 L -2 5.5 L -2 2.5 L -7.5 1.5 L -1.5 -3 Z';
// Kite diamond (unknown): tall narrow, taller than wide
const DIAMOND_PATH = 'M 0 -9 L 4.5 0 L 0 9 L -4.5 0 Z';
// Vehicle: small square
const VEHICLE_PATH = 'M -4 -4 L 4 -4 L 4 4 L -4 4 Z';

function makeIcon(t) {
    const cat = targetCategory(t);
    const hdg = t.hdg ?? 0;

    let fill, symHtml;
    if (cat === 'unknown') {
        fill = '#00ffff';
        symHtml = `<path d="${DIAMOND_PATH}" fill="${fill}" fill-opacity="0.9"/>`;
    } else if (cat === 'vehicle') {
        fill = '#00cccc';
        symHtml = `<path d="${VEHICLE_PATH}" fill="${fill}" fill-opacity="0.75"/>`;
    } else {
        fill = cat === 'heavy' ? '#ff8c00' : '#ffffff';
        // rotate inline via SVG transform (faster than CSS for many markers)
        symHtml = `<g transform="rotate(${hdg})">${'<path d="' + PLANE_PATH + '" fill="' + fill + '" fill-opacity="0.95"/>'}</g>`;
    }

    // Data block — skip for targets with no callsign and no squawk
    const cs  = t.callsign || t.squawk || '';
    const alt = t.altFt != null ? Math.round(t.altFt / 100).toString().padStart(3, '0') : '';
    const spd = t.spdKts != null ? Math.round(t.spdKts / 10).toString().padStart(2, '0') : '';
    const typ = t.acType || '';

    let dbHtml = '';
    if (cs) {
        if (cat !== 'unknown' && cat !== 'vehicle') {
            dbHtml = `<div class="db">
                <div class="db-line1">${cs}${alt ? ' ' + alt : ''}</div>
                <div class="db-line2">${typ}${typ && spd ? ' ' : ''}${spd}</div>
            </div>`;
        } else {
            dbHtml = `<div class="db"><div class="db-line1">${cs}</div></div>`;
        }
    }

    const posKey = dbPositions[t.trackId] || 'NE';
    const pos = DB_POS[posKey];
    const hideStyle = hiddenDbs.has(t.trackId) ? ';display:none' : '';
    const ldrHtml = cs ? `<svg class="ldr" width="18" height="18" viewBox="0 0 18 18" style="position:absolute;left:0;top:0;overflow:visible${hideStyle}">
            <line x1="9" y1="9" x2="${pos.lx}" y2="${pos.ly}" stroke="#00cc00" stroke-width="0.5" opacity="0.6"/>
        </svg>` : '';

    const html = `<div class="ac-icon" data-tid="${t.trackId}">
        <svg class="sym" width="18" height="18" viewBox="-9 -9 18 18" style="display:block">${symHtml}</svg>
        ${ldrHtml}
        <div class="db-wrap" style="left:${pos.wl}px;top:${pos.wt}px${hideStyle}">${dbHtml}</div>
    </div>`;

    return L.divIcon({ className: '', html, iconSize: [200, 18], iconAnchor: [9, 9] });
}

function trackHash(t) {
    return `${t.lat?.toFixed(5)},${t.lon?.toFixed(5)},${t.callsign||''},${t.altFt||0},${t.spdKts||0},${t.hdg?.toFixed(0)||0},${t.tgtType||''},${t.acType||''}`;
}

// ── Apply one track update ───────────────────────────────────────────────────
function applyTrack(t) {
    if (t.lat == null || t.lon == null) return;
    const ll  = [t.lat, t.lon];
    const h   = trackHash(t);
    const tid = t.trackId;

    if (!markers[tid]) {
        markers[tid] = L.marker(ll, { icon: makeIcon(t), zIndexOffset: 0 }).addTo(map);
    } else {
        markers[tid].setLatLng(ll);
        if (hashes[tid] !== h) {
            markers[tid].setIcon(makeIcon(t));
        }
    }
    hashes[tid] = h;
}

function removeTrack(trackId) {
    if (markers[trackId]) { map.removeLayer(markers[trackId]); delete markers[trackId]; }
    delete hashes[trackId];
}

function updateCount() {
    trackCount = Object.keys(markers).length;
    cntEl.textContent = trackCount + ' track' + (trackCount !== 1 ? 's' : '');
}

// ── Center map on track centroid ─────────────────────────────────────────────
function centerOnTracks(tracks) {
    if (!tracks.length || centeredOnce) return;
    const lat = tracks.reduce((s, t) => s + t.lat, 0) / tracks.length;
    const lon = tracks.reduce((s, t) => s + t.lon, 0) / tracks.length;
    map.setView([lat, lon], 14);
    centeredOnce = true;
}

// ── WebSocket ────────────────────────────────────────────────────────────────
let ws = null;
let wsRetryTimer = null;

function connect() {
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const url   = `${proto}//${location.host}/asdex/ws/${AIRPORT}`;
    ws = new WebSocket(url);
    connEl.textContent = 'CONNECTING';
    connEl.className   = 'waiting';

    ws.onopen = () => {
        connEl.textContent = 'LIVE';
        connEl.className   = 'ok';
        if (wsRetryTimer) { clearTimeout(wsRetryTimer); wsRetryTimer = null; }
    };

    ws.onmessage = ev => {
        let msg;
        try { msg = JSON.parse(ev.data); } catch { return; }

        if (msg.type === 'snapshot') {
            // Remove stale markers not in snapshot
            const incoming = new Set((msg.data.tracks || []).map(t => t.trackId));
            for (const tid of Object.keys(markers)) {
                if (!incoming.has(tid)) removeTrack(tid);
            }
            for (const t of (msg.data.tracks || [])) applyTrack(t);
            centerOnTracks(msg.data.tracks || []);
            updateCount();

        } else if (msg.type === 'batch') {
            for (const t of (msg.data || [])) applyTrack(t);
            updateCount();

        } else if (msg.type === 'remove') {
            removeTrack(msg.data.trackId);
            updateCount();
        }
    };

    ws.onclose = () => {
        connEl.textContent = 'DISCONNECTED';
        connEl.className   = '';
        wsRetryTimer = setTimeout(connect, 5000);
    };

    ws.onerror = () => { ws.close(); };
}

connect();
</script>
</body>
</html>
