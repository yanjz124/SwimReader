<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SFDPS ERAM</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
@font-face { font-family: 'ERAM'; src: url('ERAMv110.ttf') format('truetype'); }
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000000; color: #cccc44; font-family: 'ERAM', 'Consolas', 'Courier New', monospace; overflow: hidden; height: 100vh; }

/* ── Layout ── */
#app { position: relative; height: 100vh; }
#sidebar-wrapper { display: flex; position: absolute; top: 0; left: 0; bottom: 0; z-index: 500; }
#sidebar { width: 260px; min-width: 260px; background: #111; border-right: 1px solid #333; display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; transition: margin-left 0.2s ease; }
#sidebar.collapsed { margin-left: -260px; }
#sidebar-toggle {
    width: 20px; background: #1a1a1a; border: none; border-right: 1px solid #333;
    color: #666; cursor: pointer; display: flex; align-items: center; justify-content: center;
    font-size: 14px; padding: 0; flex-shrink: 0; z-index: 10;
    transition: color 0.15s, height 0.2s, border-radius 0.2s, margin-top 0.2s;
}
#sidebar-toggle:hover { color: #cccc44; background: #222; }
#sidebar.collapsed ~ #sidebar-toggle {
    height: 36px; align-self: flex-start; margin-top: 8px;
    border-radius: 0 4px 4px 0; border: 1px solid #333; border-left: none;
    opacity: 0.5;
}
#sidebar.collapsed ~ #sidebar-toggle:hover { opacity: 1; }
#map-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; }
#map { width: 100%; height: 100%; }

/* ── Sidebar ── */
#sidebar-header { padding: 10px 12px; border-bottom: 1px solid #333; }
#sidebar-header h2 { font-size: 13px; color: #aaa; font-weight: normal; letter-spacing: 1px; }
#connection-status { font-size: 11px; margin-top: 4px; }

.panel-section { padding: 10px 12px; border-bottom: 1px solid #222; }
.panel-label { font-size: 10px; color: #666; letter-spacing: 1.5px; margin-bottom: 8px; font-weight: bold; }

.ctrl-row { display: flex; align-items: center; margin-bottom: 6px; font-size: 11px; }
.ctrl-row label { color: #aaa; min-width: 60px; cursor: pointer; display: flex; align-items: center; gap: 6px; }
.ctrl-row select {
    flex: 1; background: #1a1a1a; color: #cccc44; border: 1px solid #333;
    padding: 3px 6px; font-family: inherit; font-size: 11px; outline: none;
}
.ctrl-row select:focus { border-color: #cccc44; }
.ctrl-row input[type="checkbox"] { accent-color: #cccc44; }

#sector-checkboxes {
    max-height: 200px; overflow-y: auto; font-size: 11px; color: #aaa;
    scrollbar-width: thin; scrollbar-color: #444 #1a1a1a;
}
#sector-checkboxes::-webkit-scrollbar { width: 6px; }
#sector-checkboxes::-webkit-scrollbar-track { background: #1a1a1a; }
#sector-checkboxes::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
#sector-checkboxes::-webkit-scrollbar-thumb:hover { background: #666; }

.traffic-row { font-size: 12px; padding: 2px 0; display: flex; justify-content: space-between; }
.traffic-row.own { color: #cccc44; }
.traffic-row.ho { color: #cccc44; }
.traffic-row.other { color: #cccc44; }
.traffic-row.total { color: #aaa; border-top: 1px solid #333; margin-top: 4px; padding-top: 6px; }

#sidebar-footer {
    margin-top: auto; padding: 8px 12px; border-top: 1px solid #333;
    font-size: 11px; color: #666;
}

/* ── Map overrides ── */
.leaflet-container {
    background: #000000 !important;
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cline x1='16' y1='9' x2='16' y2='12' stroke='white' stroke-width='4.5'/%3E%3Cline x1='16' y1='20' x2='16' y2='23' stroke='white' stroke-width='4.5'/%3E%3Cline x1='9' y1='16' x2='12' y2='16' stroke='white' stroke-width='4.5'/%3E%3Cline x1='20' y1='16' x2='23' y2='16' stroke='white' stroke-width='4.5'/%3E%3Crect x='12' y='12' width='8' height='8' fill='none' stroke='white' stroke-width='1.3'/%3E%3C/svg%3E") 16 16, crosshair !important;
}
.leaflet-control-zoom a { background: #222 !important; color: #cccc44 !important; border-color: #444 !important; }
.leaflet-control-attribution { display: none !important; }
/* Boundary/overlay lines: lighten blend so brighter line always shows through overlaps */
.bnd-path { mix-blend-mode: lighten; }

/* ── Aircraft target group ── */
.ac-group { position: absolute; pointer-events: none; }

/* ── Target symbols (Table 1 — radar return present) ── */
/* Correlated Beacon: \ backslash — transponder on, correlated to flight plan */
.ac-sym-corr-bcn {
    position: absolute; width: 2px; height: 12px;
    background: #cccc44;
    transform: translate(-1px, -6px) rotate(-45deg);
    pointer-events: auto; cursor: inherit;
}
.ac-sym-corr-bcn.emrg { background: #ff4444; }

/* Reduced Separation: • dot — correlated beacon in reduced separation area (at/below FL230) */
.ac-sym-reduced-sep {
    position: absolute;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 16px; font-weight: bold; line-height: 1;
    color: #cccc44;
    transform: translate(-50%, -50%);
    pointer-events: auto; cursor: inherit;
}
.ac-sym-reduced-sep.emrg { color: #ff4444; }

/* Uncorrelated Beacon: / forward slash — transponder on, no flight plan */
.ac-sym-uncorr-bcn {
    position: absolute; width: 2px; height: 12px;
    background: #cccc44;
    transform: translate(-1px, -6px) rotate(45deg);
    pointer-events: auto; cursor: inherit;
}

/* Uncorrelated Primary: + plus — transponder off/standby */
.ac-sym-uncorr-pri {
    position: absolute; width: 12px; height: 12px;
    transform: translate(-6px, -6px);
    pointer-events: auto; cursor: inherit;
}
.ac-sym-uncorr-pri::before, .ac-sym-uncorr-pri::after {
    content: ''; position: absolute; background: #cccc44;
}
.ac-sym-uncorr-pri::before { width: 12px; height: 2px; top: 5px; left: 0; }
.ac-sym-uncorr-pri::after { width: 2px; height: 12px; top: 0; left: 5px; }

/* ── Track position symbols (Table 2 — coasting/no target) ── */
/* Flight Plan Aided (Flat) Track: hollow diamond — centered at (0,0) target position */
.ac-sym-flat-track {
    position: absolute;
    box-sizing: border-box;
    width: 8px; height: 8px;
    left: -4px; top: -4px;
    border: 1.5px solid #cccc44; background: transparent;
    transform: rotate(45deg);
    transform-origin: center;
    pointer-events: auto; cursor: inherit;
    z-index: 1;
}
.ac-sym-flat-track.emrg { border-color: #ff4444; }

/* Coast Track: # hash */
.ac-sym-coast {
    position: absolute;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 14px; font-weight: bold;
    color: #cccc44;
    transform: translate(-5px, -7px);
    pointer-events: auto; cursor: inherit;
}

/* Handoff flash — handled by JS content changes in formatLine3() */

/* ── Leader line ── */
.ac-leader { position: absolute; top: 0; left: 0; pointer-events: none; }

/* ── Data block ── */
.ac-db {
    position: absolute; white-space: pre; pointer-events: auto; cursor: inherit;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 10px; line-height: 12.5px; letter-spacing: 0.5px;
    padding: 1px 2px; color: #cccc44;
    text-shadow: 0 0 3px rgba(0,0,0,0.9), 1px 1px 2px rgba(0,0,0,0.8);
}
.ac-db.emrg { color: #ff4444; }
.dwell-border { position: absolute; pointer-events: none; border: 1px solid #cccc44; }
.emrg .dwell-border { border-color: #ff4444; }
.ac-db.ldb.dwell { outline: 1px solid #cccc44; outline-offset: 1px; }
.ac-db.ldb.dwell.emrg { outline-color: #ff4444; }
/* .ac-db.ho — handoff flash now driven by JS */

/* ── Column 0 (R / VCI) — inline prefix on each data block line ── */
.ac-col0 { color: #cccc44; }
.ac-vci { color: #44cc44; }
/* ── Point-out P/A indicator (line 0) ── */
.ac-po-pending { color: #cccc44; }
.ac-po-accepted { color: #ffffff; }
/* ── Point-out pop-up menu ── */
#po-menu {
    position: absolute; z-index: 1100;
    font-family: 'ERAM', 'Consolas', 'Courier New', monospace;
    font-size: 12px; line-height: 16px; letter-spacing: 0.5px;
    user-select: none; background: #000; border: 1px solid #888;
}
#po-menu.box-dragging { outline: 2px solid #fff; cursor: move; }
#po-menu-title {
    display: flex; justify-content: space-between; align-items: center;
    padding: 2px 6px; border-bottom: 1px solid #555; background: #222; cursor: move;
}
#po-menu-callsign { color: #fff; }
.po-menu-divider { width: 1px; align-self: stretch; background: #555; margin: 0 4px; }
#po-menu-close { color: #fff; cursor: pointer; padding: 0 4px; }
#po-menu-close:hover { color: #ff4444; }
#po-menu-body { padding: 3px 6px; }
.po-sector-row { padding: 2px 0; cursor: pointer; white-space: pre; }
.po-sector-box { display: inline-block; padding: 0 3px; border: 1px solid; }
.po-orig-pending { color: #cccc44; border-color: #cccc44; }
.po-recv-pending { color: #00cccc; border-color: #00cccc; }
.po-acked { color: #fff; border-color: transparent; }

/* ── Flight detail (sidebar panel) ── */
#flight-detail-section { display: none; }
#flight-detail-section .fd-title { color: #cccc44; font-size: 12px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; }
#flight-detail-section .fd-row { display: flex; gap: 8px; margin-bottom: 2px; font-size: 11px; }
#flight-detail-section .fd-label { color: #666; min-width: 60px; flex-shrink: 0; }
#flight-detail-section .fd-val { color: #cccc44; word-break: break-all; }
#flight-detail-section .fd-close { cursor: pointer; color: #666; font-size: 14px; }
#flight-detail-section .fd-close:hover { color: #ff4444; }

/* ── Target symbols are drawn as inline geometric divs (no font metrics dependency) ── */

/* ── MCA (Message Composition Area) ── */
#mca {
    position: absolute; z-index: 1000;
    bottom: 170px; right: 30px;
    font-family: 'ERAM', 'Consolas', 'Courier New', monospace;
    user-select: none;
}
#mca.box-dragging { outline: 2px solid #fff; cursor: move; }
#mca-preview {
    background: #000000; border: 1px solid #888; color: #ffffff;
    padding: 3px 6px; min-width: 400px;
    font-size: 14px; font-weight: normal; line-height: 18px; white-space: pre; min-height: 28px;
    display: flex; align-items: center;
}
#mca-feedback {
    background: #000000; border: 1px solid #888; border-top: none; color: #ffffff;
    padding: 3px 6px; min-width: 400px;
    font-size: 14px; font-weight: normal; line-height: 18px; white-space: pre; min-height: 68px;
}
#mca-kb-btn {
    position: absolute; top: 0; right: -28px;
    width: 24px; height: 24px; padding: 0;
    background: rgba(50,50,50,0.6); border: 1px solid #555; border-radius: 3px;
    color: #888; font-size: 16px; line-height: 22px; text-align: center;
    cursor: pointer; opacity: 0.5; transition: opacity 0.2s;
    display: none;
}
#mca-kb-btn:hover, #mca-kb-btn:active { opacity: 1; color: #ccc; }
@media (pointer: coarse) { #mca-kb-btn { display: block; } }
#mca.show-kb #mca-kb-btn { display: block; }
#mca-mobile-input {
    position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0;
}
.transp-mca #mca-preview,
.transp-mca #mca-feedback { background: transparent; }
.transp-mca #ra-content { background: transparent; }

/* ── RA (Response Area) ── */
#ra {
    position: absolute; z-index: 1000;
    bottom: 30px; right: 30px;
    max-width: calc(100vw - 60px);
    font-family: 'ERAM', 'Consolas', 'Courier New', monospace;
    user-select: none;
}
#ra.box-dragging { outline: 2px solid #fff; cursor: move; }
#ra-content {
    background: #000000; border: 1px solid #888; color: #ffffff;
    padding: 3px 6px; width: 500px; min-height: 100px;
    max-height: 60vh; overflow-y: auto;
    font-size: 14px; line-height: 18px; white-space: pre-wrap; word-break: break-all;
    font-weight: normal;
}
</style>
</head>
<body>
<div id="app">
    <div id="sidebar-wrapper">
    <div id="sidebar">
        <div id="sidebar-header">
            <h2>SFDPS RADAR</h2>
            <div id="connection-status">Connecting...</div>
        </div>

        <div class="panel-section">
            <div class="panel-label">YOUR POSITION</div>
            <div class="ctrl-row">
                <label>Facility</label>
                <select id="sel-facility">
                    <option value="">All</option>
                </select>
            </div>
            <div style="margin-top:4px;">
                <div class="panel-label" style="margin-bottom:4px;">SECTORS</div>
                <div id="sector-checkboxes">
                    <span style="color:#666; font-size:10px;">Select facility first</span>
                </div>
            </div>
            <div class="ctrl-row" style="margin-top:4px;">
                <label><input type="checkbox" id="chk-facility-only"> Facility only</label>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">DISPLAY</div>
            <div class="ctrl-row">
                <label>Vector</label>
                <select id="sel-vector">
                    <option value="0" selected>Off</option>
                    <option value="1">1 min</option>
                    <option value="2">2 min</option>
                    <option value="4">4 min</option>
                    <option value="8">8 min</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>Line 4</label>
                <select id="sel-line4">
                    <option value="DEST" selected>DEST</option>
                    <option value="TYPE">TYPE</option>
                    <option value="OFF">OFF</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>LDB %</label>
                <input type="range" id="rng-ldb-brightness" min="0" max="100" value="30"
                    style="flex:1; accent-color:#cccc44;">
                <span id="lbl-ldb-brightness" style="min-width:28px; text-align:right; font-size:11px;">30</span>
            </div>
            <div class="ctrl-row">
                <label>Hist #</label>
                <select id="sel-histcount">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5" selected>5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>UHI %</label>
                <input type="range" id="rng-bnd-uhi" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-uhi" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>HI %</label>
                <input type="range" id="rng-bnd-hi" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-hi" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>LO %</label>
                <input type="range" id="rng-bnd-lo" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-lo" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>APP %</label>
                <input type="range" id="rng-bnd-app" min="0" max="100" value="30" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-app" style="min-width:28px; text-align:right; font-size:11px;">30</span>
            </div>
            <div class="ctrl-row">
                <label>HI Awy</label>
                <input type="range" id="rng-jroutes" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-jroutes" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label>LO Awy</label>
                <input type="range" id="rng-vroutes" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-vroutes" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label>VORs</label>
                <input type="range" id="rng-vors" min="0" max="100" value="15" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-vors" style="min-width:28px; text-align:right; font-size:11px;">15</span>
            </div>
            <div class="ctrl-row">
                <label>APTs</label>
                <input type="range" id="rng-airports" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-airports" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label>CL</label>
                <input type="range" id="rng-centerlines" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-centerlines" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label>PROC</label>
                <input type="range" id="rng-proc" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-proc" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label><input type="checkbox" id="chk-mapbg"> Map Bg</label>
                <label style="margin-left:12px;"><input type="checkbox" id="chk-mca-kb"> KB</label>
            </div>
            <!-- Transp MCA: reserved for future use
            <div class="ctrl-row">
                <label><input type="checkbox" id="chk-transp-mca"> Transp MCA</label>
            </div> -->
            <div class="ctrl-row">
                <button id="btn-fullscreen" style="flex:1; background:#222; color:#cccc44; border:1px solid #444; padding:3px 8px; font-family:inherit; font-size:11px; cursor:pointer;">Fullscreen</button>
            </div>
            <div class="ctrl-row">
                <label>NX LVL</label>
                <select id="sel-nxlvl">
                    <option value="0">OFF</option>
                    <option value="3">3</option>
                    <option value="23">23</option>
                    <option value="123" selected>123</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>NX %</label>
                <input type="range" id="rng-nx" min="0" max="100" value="30" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-nx" style="min-width:28px; text-align:right; font-size:11px;">30</span>
            </div>
            <div class="ctrl-row">
                <label>Font</label>
                <select id="sel-fontsize">
                    <option value="8">8 px</option>
                    <option value="9">9 px</option>
                    <option value="10" selected>10 px</option>
                    <option value="11">11 px</option>
                    <option value="12">12 px</option>
                    <option value="14">14 px</option>
                </select>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">ALTITUDE FILTER</div>
            <div class="ctrl-row">
                <label>Low FL</label>
                <input type="number" id="inp-alt-low" value="0" min="0" max="999" step="10"
                    style="flex:1; background:#1a1a1a; color:#cccc44; border:1px solid #333; padding:3px 6px; font-family:inherit; font-size:11px; outline:none; width:60px;">
            </div>
            <div class="ctrl-row">
                <label>High FL</label>
                <input type="number" id="inp-alt-high" value="999" min="0" max="999" step="10"
                    style="flex:1; background:#1a1a1a; color:#cccc44; border:1px solid #333; padding:3px 6px; font-family:inherit; font-size:11px; outline:none; width:60px;">
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">TRAFFIC</div>
            <div id="traffic-counts">
                <div class="traffic-row own">Own <span id="cnt-own">0</span></div>
                <div class="traffic-row ho">Handoff <span id="cnt-ho">0</span></div>
                <div class="traffic-row other">Other <span id="cnt-other">0</span></div>
                <div class="traffic-row total">Total <span id="cnt-total">0</span></div>
            </div>
        </div>

        <div class="panel-section" id="flight-detail-section">
            <div class="fd-title">
                <span id="fd-title"></span>
                <span class="fd-close" onclick="closeFd()">&times;</span>
            </div>
            <div id="fd-body"></div>
        </div>

        <div id="sidebar-footer">
            <span id="stat-rate">0</span> msg/s &middot;
            <span id="stat-flights">0</span> flights &middot;
            <span id="stat-uptime">00:00:00</span>
            <br><span id="stat-fp" style="color:#888;font-size:0.85em;"></span>
        </div>
    </div>
    <button id="sidebar-toggle" title="Toggle sidebar">&#9664;</button>
    </div>

    <div id="map-container">
        <div id="map"></div>
        <div id="mca">
            <div id="mca-preview"><span class="mca-cursor">_</span></div>
            <div id="mca-feedback"></div>
            <button id="mca-kb-btn" title="Open keyboard" aria-label="Open keyboard">&#9000;&#xFE0E;</button>
            <input id="mca-mobile-input" autocapitalize="characters" autocomplete="off" autocorrect="off" spellcheck="false">
        </div>
        <div id="ra">
            <div id="ra-content"></div>
        </div>
        <div id="po-menu" style="display:none;">
            <div id="po-menu-title">
                <span id="po-menu-callsign"></span>
                <span class="po-menu-divider"></span>
                <span id="po-menu-close">X</span>
            </div>
            <div id="po-menu-body"></div>
        </div>
    </div>
</div>

<script>
// ════════════════════════════════════════════════════════════════════════════
// State
// ════════════════════════════════════════════════════════════════════════════
const flights = new Map();          // current displayed state — datablock fields updated instantly
// Position updates applied immediately — history dots use time-based decay for scan simulation
const flightHistory = new Map();
let MAX_HISTORY = 5;
const TRACK_COLOR = '#cccc44';
const EMRG_COLOR = '#ff4444';
const MAP_COLOR = '#555555';
const RENDER_INTERVAL = 2000;  // render repaint interval (ms)
const SCAN_INTERVAL = 12000;   // SFDPS update cadence (used for history decay cutoff)

let myFacility = '';
let mySectors = new Set();
let facilityOnly = false;   // when true + facility selected, hide all non-facility aircraft
let showFdb = true;
let showHistory = true;
let vectorMinutes = 0;
// showBoundaries removed — boundaries always on, controlled by brightness sliders
let selectedGufi = null;
let wsConnected = false;
let msgRate = 0;
let altFilterLow = 0;      // FL (hundreds of feet), 0 = no filter
let altFilterHigh = 999;    // FL (hundreds of feet), 999 = no filter
let fontSize = 10;          // data block font size in px
let ldbBrightness = 30;     // 0-100, opacity for LDB data blocks (0=hidden, 100=same as FDB)
let showMapBg = false;      // tile layer hidden by default
let line4Mode = 'DEST';     // 'DEST' | 'TYPE' | 'OFF' — what FDB line 4 shows
const quickLookSectors = new Set(); // QL sectors — force FDB on tracks in these sectors without claiming ownership
const quickLookDests = new Set();   // QL destinations — force FDB on flights to these airports (e.g. KCLT, KGSO)
const fdbOverrides = new Map(); // gufi → true/false — user toggle for FDB/LDB per track
const wasOwnOrHo = new Set();  // tracks that were own/ho — keeps FDB sticky when they become other
const manuallyHidden = new Set(); // GUFIs user explicitly hid via middle-click cycle or QX command
const lastVisibleAt = new Map(); // gufi → performance.now() — grace period prevents flicker on facility field changes

const knownFacilities = new Map();
const hoCompletedInfo = new Map(); // gufi → { time, receiving, transferring } — track completed handoffs for 60s O display
const dbPositions = new Map(); // gufi → position number 1-9 (data block placement)
const ldrLenOverrides = new Map(); // gufi → leader length level (0-3), default 1
const driActive = new Map();       // gufi → 'J' (standard 5nm) or 'T' (reduced 3nm)
const dwellLocked = new Set();     // GUFIs with persistent dwell emphasis (toggled via Field A click)
const vciActive = new Set();       // GUFIs with VCI (Visual Communications Indicator) toggled on

// Controller-entered altitude overrides (QZ/QQ/QR commands)
// Local wins when present; SWIM clears local override only when it sends a genuinely NEW different value
const localAssignedAlt = new Map();  // gufi → { feet, rules, block, serverVal } — QZ assigned altitude
const localInterimAlt = new Map();   // gufi → { feet, type, serverVal } — QQ interim (type: 'I'|'P'|'L')
const localReportedAlt = new Map();  // gufi → { feet, serverVal } — QR controller-entered reported altitude

// HSF (Heading/Speed/Free text) data — QS command (local overrides)
const hsfData = new Map();     // gufi → { heading, speed, freeText } — local QS overrides
const hsfShowMap = new Set();  // GUFIs currently displaying HSF on line 4 (toggled by ↴ click or QS <FLID>)
const hsfClrSuppressed = new Map();  // gufi → {h,s,t} — suppressed server clearance values (after QS * clear)

// Effective HSF: merges server clearance data with local QS overrides (local wins per-field)
// Server clearanceSpeed may be bare number — normalize: 2-digit → M prefix, 3-digit → S prefix
function normalizeSpeed(s) {
    if (!s) return s;
    if (/^\d{2}[+-]?$/.test(s)) return 'M' + s;  // e.g. 75 → M75, 78+ → M78+
    if (/^\d{3}$/.test(s)) return 'S' + s;        // e.g. 250 → S250
    return s;  // 280+, 250-, M79, S270 etc. pass through
}
function normalizeHeading(h) {
    if (!h) return h;
    if (/^\d{3}$/.test(h)) return 'H' + h;  // e.g. 255 → H255
    return h;  // 15R, PH, VK etc. pass through
}
function getEffectiveHsf(f) {
    const local = hsfData.get(f.gufi);
    const heading = normalizeHeading(local?.heading ?? f.clearanceHeading ?? null);
    const speed = local?.speed ?? normalizeSpeed(f.clearanceSpeed) ?? null;
    const freeText = local?.freeText ?? f.clearanceText ?? null;
    if (!heading && !speed && !freeText) return null;
    return { heading, speed, freeText };
}

// Point-out state
const pointoutAcked = new Set();  // GUFIs with acknowledged point-outs (P→A)
const pointoutFirstSeen = new Map();  // GUFI → timestamp (ms) when PO first appeared on client
const PO_CLIENT_TIMEOUT = 3 * 60 * 1000;  // 3 minutes
let pointoutMenuGufi = null;       // GUFI of flight whose point-out menu is open

function updatePointoutMenuBody(f, poInfo) {
    const body = document.getElementById('po-menu-body');
    const acked = pointoutAcked.has(f.gufi);
    // Determine which sector to show and its styling
    let sectorId, pColor, sectorCls;
    if (poInfo.role === 'originator') {
        // Originator sees receiving sector(s)
        sectorId = poInfo.recvSector || '??';
        if (acked) {
            // Remote acknowledged: white P, white unboxed sector
            pColor = '#fff';
            sectorCls = 'po-acked';
        } else {
            // Pending: yellow P, yellow boxed sector
            pColor = '#cccc44';
            sectorCls = 'po-orig-pending';
        }
    } else {
        // Receiver sees initiating sector(s)
        sectorId = poInfo.origSector || '??';
        if (acked) {
            // Already acknowledged: white P, white unboxed sector
            pColor = '#fff';
            sectorCls = 'po-acked';
        } else {
            // Pending: cyan P, cyan boxed sector
            pColor = '#00cccc';
            sectorCls = 'po-recv-pending';
        }
    }
    body.innerHTML = `<div class="po-sector-row" data-gufi="${f.gufi}" data-role="${poInfo.role}"><span style="color:${pColor}">P</span> <span class="po-sector-box ${sectorCls}">${sectorId}</span></div>`;
}

function openPointoutMenu(f, poInfo, clientX, clientY) {
    closePointoutMenu();
    pointoutMenuGufi = f.gufi;
    const menu = document.getElementById('po-menu');
    document.getElementById('po-menu-callsign').textContent = f.callsign || '???';

    updatePointoutMenuBody(f, poInfo);

    // Position to the right of the data block
    const container = document.getElementById('map-container');
    const cRect = container.getBoundingClientRect();
    const gufi = f.gufi;
    const marker = markers.get(gufi);
    let menuLeft = clientX - cRect.left + 10;
    let menuTop = clientY - cRect.top - 10;
    if (marker) {
        const mEl = marker.getElement();
        const dbEl = mEl?.querySelector('.ac-db');
        if (dbEl) {
            const dbRect = dbEl.getBoundingClientRect();
            menuLeft = dbRect.right - cRect.left + 6;
            menuTop = dbRect.top - cRect.top;
        }
    }
    menu.style.left = menuLeft + 'px';
    menu.style.top = menuTop + 'px';
    menu.style.bottom = 'auto';
    menu.style.right = 'auto';
    menu.style.display = 'block';
    requestAnimationFrame(() => clampBox(menu));
}

function closePointoutMenu() {
    pointoutMenuGufi = null;
    document.getElementById('po-menu').style.display = 'none';
}

// .FIND overlay state
let findMarker = null;   // { ident, lat, lon, time } — active find highlight
let findTimer = null;    // auto-clear timeout
let findBlinkRaf = null; // setTimeout ID for blink redraw

function setFindMarker(ident, lat, lon) {
    clearFindMarker();
    findMarker = { ident, lat, lon, time: performance.now() };
    // Auto-clear after 30 seconds
    findTimer = setTimeout(clearFindMarker, 30000);
    // Start blink redraw — every 500ms to match blink rate
    (function blinkLoop() {
        if (!findMarker) return;
        drawOverlay();
        findBlinkRaf = setTimeout(blinkLoop, 500);
    })();
}

function clearFindMarker() {
    findMarker = null;
    if (findTimer) { clearTimeout(findTimer); findTimer = null; }
    if (findBlinkRaf) { clearTimeout(findBlinkRaf); findBlinkRaf = null; }
    drawOverlay();
}

// Global flash reference — updated once per 500ms tick so ALL tracks see the same phase
let flashTime = performance.now();

// Dedup: when a facility is selected, only show one GUFI per callsign (prefer our facility)
const bestGufiByCallsign = new Map();  // callsign → gufi — rebuilt each render cycle
function isDedupHidden(gufi, f) {
    return myFacility && f.callsign && bestGufiByCallsign.get(f.callsign) !== gufi;
}

// Facility handoff codes — loaded from handoff-codes.json
// Structure: { default: { FAC: code }, ZDC: { PCT: code }, ... }
let handoffCodesConfig = { default: {} };

async function loadHandoffCodes() {
    try {
        const resp = await fetch('/handoff-codes.json');
        if (!resp.ok) return;
        handoffCodesConfig = await resp.json();
        console.log('[HO-Codes] Loaded', Object.keys(handoffCodesConfig.default).length, 'default codes');
    } catch (e) { console.warn('[HO-Codes]', e); }
}
loadHandoffCodes();

// Look up handoff code for a facility, respecting per-scope overrides
function getHandoffCode(facility) {
    // Per-scope override first (e.g. ZDC scope sees PCT as "E")
    if (myFacility && handoffCodesConfig[myFacility]) {
        const code = handoffCodesConfig[myFacility][facility];
        if (code) return code;
    }
    // Default codes
    const code = handoffCodesConfig.default?.[facility];
    if (code) return code;
    // Fallback: first character of facility ID
    return facility.charAt(0);
}

// Destination airport single-letter codes — loaded from destination-codes.json
// Structure: { ZDC: { A: ["ATL"], B: ["BWI"], ... }, ... }
// Reverse lookup: destCodeLookup[facility][airport] = letter
let destCodesConfig = {};
const destCodeLookup = {};  // facility → { airport → letter }

async function loadDestinationCodes() {
    try {
        const resp = await fetch('/destination-codes.json');
        if (!resp.ok) return;
        destCodesConfig = await resp.json();
        // Build reverse lookup: airport → letter for each facility
        for (const [fac, letters] of Object.entries(destCodesConfig)) {
            destCodeLookup[fac] = {};
            for (const [letter, airports] of Object.entries(letters)) {
                for (const apt of airports) {
                    destCodeLookup[fac][apt] = letter;
                }
            }
        }
        const facCount = Object.keys(destCodesConfig).length;
        console.log('[DestCodes] Loaded destination codes for', facCount, 'facilities');
    } catch (e) { console.warn('[DestCodes]', e); }
}
loadDestinationCodes();

// Look up single-letter destination code for an airport, using selected facility's config
function getDestinationLetter(dest) {
    if (!dest || !myFacility) return '';
    const lookup = destCodeLookup[myFacility];
    if (!lookup) return '';
    // Try as-is (FAA LID), then with K prefix stripped (ICAO→LID)
    return lookup[dest] || lookup[dest.replace(/^K/, '')] || '';
}

// ════════════════════════════════════════════════════════════════════════════
// Map setup
// ════════════════════════════════════════════════════════════════════════════
const map = L.map('map', {
    center: [39.0, -98.0],
    zoom: 6,
    dragging: false,       // disable left-click drag — we use right-click pan
    doubleClickZoom: false, // disable double-click zoom
    zoomControl: false,
    keyboard: false,       // disable numpad/+/- zoom — conflicts with MCA input
    attributionControl: false,
    zoomSnap: 0.1,        // granular zoom (0.1 steps)
    zoomDelta: 0.1,       // each scroll/click zooms by 0.1
    wheelPxPerZoomLevel: 200,  // smooth scroll zoom
});

const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
    subdomains: 'abcd', maxZoom: 19, opacity: 0.4
});

map.createPane('nexrad');
map.getPane('nexrad').style.zIndex = 250;
map.getPane('nexrad').style.pointerEvents = 'none';

map.createPane('routes');
map.getPane('routes').style.zIndex = 420;

map.createPane('targets');
map.getPane('targets').style.zIndex = 450;

const markers = new Map();

// QU route display: gufi → { polyline, destMarker, time, minutes }
// polyline = Leaflet L.polyline, destMarker = L.marker for destination X
// time = performance.now() when added (auto-remove after 30s for QU commands, null = persistent)
// minutes = display length in minutes (null = full route)
const activeRoutes = new Map();

// ════════════════════════════════════════════════════════════════════════════
// Canvas overlay for history dots + velocity vectors
// ════════════════════════════════════════════════════════════════════════════
const overlayCanvas = document.createElement('canvas');
overlayCanvas.style.position = 'absolute';
overlayCanvas.style.pointerEvents = 'none';
overlayCanvas.style.zIndex = '440';
map.getPane('overlayPane').appendChild(overlayCanvas);

// Draw a symbol as canvas geometry at (cx, cy) — same shapes as the HTML target symbols
const SYM_LINE_LEN = 14;   // length of \ and / lines (px)
const SYM_LINE_W = 2;      // stroke width
const SYM_DOT_R = 2.5;     // dot radius for • symbol
function drawSymbolGeometry(ctx, sym, cx, cy, color) {
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = SYM_LINE_W;
    const half = SYM_LINE_LEN / 2;
    if (sym === '\\') {
        // Backslash: top-left to bottom-right
        ctx.beginPath();
        ctx.moveTo(cx - half * 0.707, cy - half * 0.707);
        ctx.lineTo(cx + half * 0.707, cy + half * 0.707);
        ctx.stroke();
    } else if (sym === '/') {
        // Forward slash: bottom-left to top-right
        ctx.beginPath();
        ctx.moveTo(cx - half * 0.707, cy + half * 0.707);
        ctx.lineTo(cx + half * 0.707, cy - half * 0.707);
        ctx.stroke();
    } else if (sym === '\u2022') {
        // Dot: filled circle
        ctx.beginPath();
        ctx.arc(cx, cy, SYM_DOT_R, 0, 2 * Math.PI);
        ctx.fill();
    } else if (sym === '#') {
        // Coast track: # — 2 horizontal lines + 2 slanted vertical lines (like /)
        const sz = half * 0.85, g = sz * 0.4, slant = sz * 0.2;
        ctx.beginPath();
        ctx.moveTo(cx - sz, cy - g); ctx.lineTo(cx + sz, cy - g);
        ctx.moveTo(cx - sz, cy + g); ctx.lineTo(cx + sz, cy + g);
        ctx.moveTo(cx - g + slant, cy - sz); ctx.lineTo(cx - g - slant, cy + sz);
        ctx.moveTo(cx + g + slant, cy - sz); ctx.lineTo(cx + g - slant, cy + sz);
        ctx.stroke();
    }
    // ◇ (diamond): history doesn't draw diamond overlay, only the current position marker does
}

function drawOverlay() {
    const size = map.getSize();
    if (size.x === 0 || size.y === 0) return;
    const bounds = map.getBounds();
    const topLeft = map.containerPointToLayerPoint([0, 0]);
    overlayCanvas.width = size.x;
    overlayCanvas.height = size.y;
    L.DomUtil.setPosition(overlayCanvas, topLeft);

    const ctx = overlayCanvas.getContext('2d');

    // ── History symbols (dimmer target symbols — drawn as geometry, not font) ──
    if (showHistory) {
        const histNow = performance.now();
        const histCutoff = histNow - (MAX_HISTORY * SCAN_INTERVAL);
        for (const [gufi, hist] of flightHistory) {
            if (hist.length === 0) continue;
            const f = flights.get(gufi);
            if (!f || f.latitude == null) continue;
            if (!isVisible(f)) continue;
            if (isDedupHidden(gufi, f)) continue;
            if (manuallyHidden.has(gufi)) continue;

            const color = isEmergency(f) ? EMRG_COLOR : TRACK_COLOR;
            const isFdb = shouldShowFdb(gufi, classifyTrack(f));
            const histAlpha = isFdb ? 0.30 : (ldbBrightness / 100) * 0.30;
            if (histAlpha <= 0) continue;

            for (let i = 0; i < hist.length; i++) {
                if (hist[i].time && hist[i].time < histCutoff) continue;
                if (!bounds.contains([hist[i].lat, hist[i].lon])) continue;
                const pt = map.latLngToLayerPoint([hist[i].lat, hist[i].lon]);
                const x = pt.x - topLeft.x;
                const y = pt.y - topLeft.y;
                ctx.globalAlpha = histAlpha;
                drawSymbolGeometry(ctx, hist[i].sym || '\\', x, y, color);
            }
        }
    }

    // ── Velocity vectors ──
    if (vectorMinutes > 0) {
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 1.0;
        for (const [gufi, f] of flights) {
            if (f.latitude == null || f.longitude == null) continue;
            if (f.trackVelocityX == null || f.trackVelocityY == null) continue;
            if (!isVisible(f)) continue;
            if (isDedupHidden(gufi, f)) continue;
            if (manuallyHidden.has(gufi)) continue;
            if (isCoasting(f)) continue;  // no velocity vector for coast tracks
            if (!showFdb || !shouldShowFdb(gufi, classifyTrack(f))) continue;
            if (!bounds.contains([f.latitude, f.longitude])) continue;

            const color = isEmergency(f) ? EMRG_COLOR : TRACK_COLOR;

            const dLat = f.trackVelocityY * vectorMinutes / 3600;
            const dLon = f.trackVelocityX * vectorMinutes / (3600 * Math.cos(f.latitude * Math.PI / 180));

            const startPt = map.latLngToLayerPoint([f.latitude, f.longitude]);
            const endPt = map.latLngToLayerPoint([f.latitude + dLat, f.longitude + dLon]);

            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(startPt.x - topLeft.x, startPt.y - topLeft.y);
            ctx.lineTo(endPt.x - topLeft.x, endPt.y - topLeft.y);
            ctx.stroke();
        }
    }

    // ── DRI halos (QP command — 5nm standard or 3nm reduced) ──
    if (driActive.size > 0) {
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 1.0;
        for (const [gufi, driType] of driActive) {
            const f = flights.get(gufi);
            if (!f || f.latitude == null || f.longitude == null) continue;
            if (!isVisible(f)) continue;
            if (isDedupHidden(gufi, f)) continue;
            if (manuallyHidden.has(gufi)) continue;
            if (!bounds.contains([f.latitude, f.longitude])) continue;

            const radiusNm = driType === 'T' ? 3 : 5;
            const radiusDeg = radiusNm / 60; // 1 NM = 1/60 degree latitude
            const centerPt = map.latLngToLayerPoint([f.latitude, f.longitude]);
            const edgePt = map.latLngToLayerPoint([f.latitude + radiusDeg, f.longitude]);
            const radiusPx = Math.abs(centerPt.y - edgePt.y);
            const cx = centerPt.x - topLeft.x;
            const cy = centerPt.y - topLeft.y;
            const color = isEmergency(f) ? EMRG_COLOR : TRACK_COLOR;
            ctx.strokeStyle = color;

            if (driType === 'T') {
                // Reduced DRI: circle with 4 gaps (at N, E, S, W)
                const gapAngle = Math.PI / 12; // 15° gap at each cardinal
                for (let q = 0; q < 4; q++) {
                    const cardinal = -Math.PI / 2 + q * Math.PI / 2; // N, E, S, W
                    ctx.beginPath();
                    ctx.arc(cx, cy, radiusPx, cardinal + gapAngle, cardinal + Math.PI / 2 - gapAngle);
                    ctx.stroke();
                }
            } else {
                // Standard DRI: full circle
                ctx.beginPath();
                ctx.arc(cx, cy, radiusPx, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }
    }

    // ── Airport overlay (NASR) ──
    if (airportOverlayData && nasrBrightness.airports > 0) {
        const aptCol = nasrColor(nasrBrightness.airports);
        ctx.strokeStyle = aptCol;
        ctx.fillStyle = aptCol;
        ctx.lineWidth = 1;
        ctx.font = `${Math.round(fontSize * 0.75)}px 'ERAM', Consolas, monospace`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        ctx.globalAlpha = nasrBrightness.airports / 100;

        for (const apt of airportOverlayData) {
            if (!bounds.contains([apt.lat, apt.lon])) continue;
            const pt = map.latLngToLayerPoint([apt.lat, apt.lon]);
            const x = pt.x - topLeft.x;
            const y = pt.y - topLeft.y;

            if (apt.cls === 'B') {
                // Class B: hollow square 7×7
                ctx.strokeRect(x - 3.5, y - 3.5, 7, 7);
            } else if (apt.cls === 'C') {
                // Class C: smaller hollow square 5×5
                ctx.strokeRect(x - 2.5, y - 2.5, 5, 5);
            } else if (apt.cls === 'D') {
                // Class D: small hollow circle r=3
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.stroke();
            } else {
                // Class E/G: L-shape (top + left sides only)
                ctx.beginPath();
                ctx.moveTo(x - 2.5, y + 2.5);
                ctx.lineTo(x - 2.5, y - 2.5);
                ctx.lineTo(x + 2.5, y - 2.5);
                ctx.stroke();
            }

            // ICAO label: top-left of text at symbol center
            ctx.fillText(apt.icao || apt.lid, x, y);
        }
        ctx.globalAlpha = 1;
        ctx.textBaseline = 'alphabetic';
    }

    // ── ILS/LOC/LDA centerlines — dashed lines from threshold, 15 NM ──
    if (centerlineData && nasrBrightness.centerlines > 0) {
        const clCol = nasrColor(nasrBrightness.centerlines);
        ctx.strokeStyle = clCol;
        ctx.lineWidth = 1;
        ctx.globalAlpha = nasrBrightness.centerlines / 100;

        for (const cl of centerlineData) {
            // Quick bounds check: skip if both endpoints off-screen
            const clBounds = L.latLngBounds([cl.lat1, cl.lon1], [cl.lat2, cl.lon2]);
            if (!bounds.intersects(clBounds)) continue;

            const p1 = map.latLngToLayerPoint([cl.lat1, cl.lon1]);
            const p2 = map.latLngToLayerPoint([cl.lat2, cl.lon2]);
            const x1 = p1.x - topLeft.x, y1 = p1.y - topLeft.y;
            const x2 = p2.x - topLeft.x, y2 = p2.y - topLeft.y;

            // Compute 1 NM in pixels (total line = 15 NM)
            const dx = x2 - x1, dy = y2 - y1;
            const totalPx = Math.sqrt(dx * dx + dy * dy);
            const nmPx = totalPx / 15;

            ctx.setLineDash([nmPx, nmPx]);
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
    }

    // ── .FIND highlight — blinking yellow square (full ↔ half bright) ──
    if (findMarker && bounds.contains([findMarker.lat, findMarker.lon])) {
        const blinkPhase = Math.floor(performance.now() / 500) % 2 === 0;
        const pt = map.latLngToLayerPoint([findMarker.lat, findMarker.lon]);
        const x = pt.x - topLeft.x;
        const y = pt.y - topLeft.y;
        const sz = Math.round(fontSize * 0.8);
        ctx.globalAlpha = blinkPhase ? 1.0 : 0.4;
        ctx.strokeStyle = TRACK_COLOR;
        ctx.lineWidth = 1.5;
        ctx.strokeRect(x - sz / 2, y - sz - 2, sz, sz);
        // Label below — always full bright
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = TRACK_COLOR;
        ctx.fillText(findMarker.ident, x, y + LINE_H);
    }

    ctx.globalAlpha = 1;
}

// Clear canvas immediately on zoom start to prevent ghost shadows
map.on('zoomstart', () => {
    const ctx = overlayCanvas.getContext('2d');
    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
});

let _overlayRafPending = false;
map.on('move zoom viewreset resize', () => {
    closePointoutMenu();
    if (!_overlayRafPending) {
        _overlayRafPending = true;
        requestAnimationFrame(() => {
            _overlayRafPending = false;
            try { drawOverlay(); } catch(e) { console.error('[Overlay]', e); }
        });
    }
});

// ════════════════════════════════════════════════════════════════════════════
// KML sector boundaries (video maps — grey)
// ════════════════════════════════════════════════════════════════════════════
let kmlSectors = [];
const boundaryLayers = {};        // keyed by 'ARTCC:category'
let activeBoundaryArtcc = '';
const BOUNDARY_CATS = ['Ultra High', 'High Altitude', 'Low Altitude', 'Approach Control'];
const BOUNDARY_CAT_LABELS = { 'Ultra High': 'UHI', 'High Altitude': 'HI', 'Low Altitude': 'LO', 'Approach Control': 'APP' };
const BOUNDARY_CAT_SLIDER = { 'Ultra High': 'rng-bnd-uhi', 'High Altitude': 'rng-bnd-hi', 'Low Altitude': 'rng-bnd-lo', 'Approach Control': 'rng-bnd-app' };
const BOUNDARY_CAT_LABEL = { 'Ultra High': 'lbl-bnd-uhi', 'High Altitude': 'lbl-bnd-hi', 'Low Altitude': 'lbl-bnd-lo', 'Approach Control': 'lbl-bnd-app' };
let boundaryBrightness = { 'Ultra High': 60, 'High Altitude': 60, 'Low Altitude': 60, 'Approach Control': 30 };

function bndColor(brightness) {
    const v = Math.round(brightness * 2.55);
    return `rgb(${v},${v},${v})`;
}

async function loadKml() {
    try {
        const resp = await fetch('/api/kml/AllSectors.kml');
        if (!resp.ok) return;
        const text = await resp.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'text/xml');
        const placemarks = xml.querySelectorAll('Placemark');

        for (const pm of placemarks) {
            const name = pm.querySelector('name')?.textContent || '';
            const desc = pm.querySelector('description')?.textContent || '';
            const coordEl = pm.querySelector('coordinates');
            if (!coordEl) continue;

            const descDoc = new DOMParser().parseFromString(desc, 'text/html');
            const tds = descDoc.querySelectorAll('td');
            const data = {};
            for (let i = 0; i < tds.length - 1; i += 2) {
                data[tds[i].textContent.trim()] = tds[i + 1].textContent.trim();
            }

            const folderPath = data['FolderPath'] || '';
            const parts = folderPath.split('/');
            let artcc = parts.length >= 2 ? parts[1] : '';
            let category = '';
            let sectorId = name;

            if (artcc) {
                // Standard format: FolderPath = "xxx/ZDC/High Altitude (17)/sectorId"
                const catRaw = parts.length >= 3 ? parts[2] : '';
                category = catRaw.replace(/\s*\(\d+\)$/, '');
                sectorId = parts.length >= 4 ? parts[3] : name;
            } else {
                // Western ARTCCs: no FolderPath, derive from ancestor Folder names
                // e.g. Folder "ZLA_HIGH_NEW" → artcc=ZLA, category=High Altitude
                let el = pm.parentElement;
                while (el) {
                    const fn = el.tagName === 'Folder' ? (el.querySelector(':scope > name')?.textContent || '') : '';
                    const m = fn.match(/^(Z[A-Z]{2})[_ ]/);
                    if (m) {
                        artcc = m[1];
                        const upper = fn.toUpperCase();
                        if (upper.includes('ULTRA')) category = 'Ultra High';
                        else if (upper.includes('HIGH')) category = 'High Altitude';
                        else if (upper.includes('LOW')) category = 'Low Altitude';
                        else if (upper.includes('APPROACH')) category = 'Approach Control';
                        else category = 'High Altitude';
                        break;
                    }
                    el = el.parentElement;
                }
            }
            if (!artcc) continue;

            const coords = coordEl.textContent.trim().split(/\s+/).map(c => {
                const [lon, lat] = c.split(',');
                return [parseFloat(lat), parseFloat(lon)];
            }).filter(c => !isNaN(c[0]) && !isNaN(c[1]));

            if (coords.length < 2) continue;
            kmlSectors.push({ artcc, name, sectorId, alt: data['ALT'] || '', category, coords });
        }
        const catCounts = {};
        for (const s of kmlSectors) catCounts[s.category] = (catCounts[s.category] || 0) + 1;
        console.log(`[KML] Loaded ${kmlSectors.length} sectors`, catCounts);
        // Clear any boundary layers cached before KML finished (they'd be empty)
        for (const key in boundaryLayers) {
            if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
            delete boundaryLayers[key];
        }
        if (myFacility) showBoundariesForFacility(myFacility);
    } catch (e) { console.warn('[KML]', e); }
}

function showBoundariesForFacility(artcc) {
    // Remove all layers for the previous ARTCC
    if (activeBoundaryArtcc) {
        for (const cat of BOUNDARY_CATS) {
            const key = `${activeBoundaryArtcc}:${cat}`;
            if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
        }
    }
    activeBoundaryArtcc = artcc;
    if (!artcc) return;

    for (const cat of BOUNDARY_CATS) {
        const br = boundaryBrightness[cat];
        if (br <= 0) continue;
        const key = `${artcc}:${cat}`;
        if (!boundaryLayers[key]) {
            const group = L.layerGroup();
            const dash = cat === 'Approach Control' ? '8 4' : '16 8';
            for (const sec of kmlSectors.filter(s => s.artcc === artcc && s.category === cat)) {
                L.polyline(sec.coords, { color: bndColor(br), weight: 1, opacity: 1, dashArray: dash, interactive: false, className: 'bnd-path' }).addTo(group);
            }
            boundaryLayers[key] = group;
        }
        boundaryLayers[key].addTo(map);
    }
}

function setBoundaryBrightness(cat, brightness) {
    boundaryBrightness[cat] = brightness;
    if (!activeBoundaryArtcc) return;
    const key = `${activeBoundaryArtcc}:${cat}`;
    if (brightness <= 0) {
        if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
        return;
    }
    const col = bndColor(brightness);
    if (!boundaryLayers[key]) {
        const group = L.layerGroup();
        const dash = cat === 'Approach Control' ? '8 4' : '16 8';
        for (const sec of kmlSectors.filter(s => s.artcc === activeBoundaryArtcc && s.category === cat)) {
            L.polyline(sec.coords, { color: col, weight: 1, opacity: 1, dashArray: dash, interactive: false, className: 'bnd-path' }).addTo(group);
        }
        boundaryLayers[key] = group;
        boundaryLayers[key].addTo(map);
    } else {
        // Update color on existing polylines
        boundaryLayers[key].eachLayer(l => l.setStyle({ color: col }));
        if (!map.hasLayer(boundaryLayers[key])) boundaryLayers[key].addTo(map);
    }
}

function zoomToFacility(artcc) {
    if (!artcc || kmlSectors.length === 0) return;
    const sectors = kmlSectors.filter(s => s.artcc === artcc);
    if (sectors.length === 0) return;
    let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
    for (const sec of sectors) {
        for (const [lat, lon] of sec.coords) {
            if (lat < minLat) minLat = lat;
            if (lat > maxLat) maxLat = lat;
            if (lon < minLon) minLon = lon;
            if (lon > maxLon) maxLon = lon;
        }
    }
    map.fitBounds([[minLat, minLon], [maxLat, maxLon]], { padding: [20, 20] });
}

loadKml();

// ════════════════════════════════════════════════════════════════════════════
// NASR overlay layers (airways, VORs, SID/STARs)
// ════════════════════════════════════════════════════════════════════════════
const nasrLayers = {};    // 'jroutes'|'vroutes'|'vors'|'proc:DCA' → L.layerGroup
const nasrCache = {};     // same keys → raw API data (cache across toggles)
const nasrBrightness = { jroutes: 0, vroutes: 0, vors: 15, airports: 0, centerlines: 0, proc: 0 };
let airportOverlayData = null; // cached from /api/nasr/airports
let centerlineData = null;     // cached from /api/nasr/centerlines

const nasrLoading = {};   // guard against double-click during async fetch
function nasrColor(brightness) { return bndColor(brightness); }  // same grey ramp as boundaries

async function showNasrLayer(layerKey, url, renderer) {
    const br = nasrBrightness[layerKey];
    if (br <= 0) {
        if (nasrLayers[layerKey]) { map.removeLayer(nasrLayers[layerKey]); delete nasrLayers[layerKey]; }
        return;
    }
    // Already showing — just update color
    if (nasrLayers[layerKey]) {
        const col = nasrColor(br);
        nasrLayers[layerKey].eachLayer(l => l.setStyle({ color: col }));
        return;
    }
    if (nasrLoading[layerKey]) return;
    // Fetch data (cached)
    if (!nasrCache[layerKey]) {
        nasrLoading[layerKey] = true;
        try {
            const resp = await fetch(url);
            if (!resp.ok) { console.warn(`[NASR] ${layerKey}: ${resp.status}`); delete nasrLoading[layerKey]; return; }
            nasrCache[layerKey] = await resp.json();
        } catch (e) { console.warn(`[NASR] ${layerKey}:`, e); delete nasrLoading[layerKey]; return; }
        delete nasrLoading[layerKey];
    }
    // Re-check brightness after async fetch (slider may have changed to 0)
    const finalBr = nasrBrightness[layerKey];
    if (finalBr <= 0) return;
    const group = L.layerGroup();
    renderer(nasrCache[layerKey], group, finalBr);
    nasrLayers[layerKey] = group;
    group.addTo(map);
}

function renderAirways(data, group, br) {
    const col = nasrColor(br);
    for (const awy of data) {
        if (awy.points.length < 2) continue;
        L.polyline(awy.points, { color: col, weight: 1, opacity: 1, interactive: false, className: 'bnd-path' }).addTo(group);
    }
}

function renderVors(data, group, br) {
    const col = nasrColor(br);
    for (const vor of data) {
        L.circleMarker([vor.lat, vor.lon], {
            radius: 4, color: col, weight: 1, opacity: 1, fill: false, interactive: false, className: 'bnd-path'
        }).addTo(group);
    }
}

function setupNasrSlider(sliderId, labelId, layerKey, url, renderer) {
    document.getElementById(sliderId).addEventListener('input', function () {
        nasrBrightness[layerKey] = parseInt(this.value);
        document.getElementById(labelId).textContent = nasrBrightness[layerKey];
        showNasrLayer(layerKey, url, renderer);
        saveSettingsToUrl();
    });
}
setupNasrSlider('rng-jroutes', 'lbl-jroutes', 'jroutes', '/api/nasr/airways?type=hi', renderAirways);
setupNasrSlider('rng-vroutes', 'lbl-vroutes', 'vroutes', '/api/nasr/airways?type=lo', renderAirways);
setupNasrSlider('rng-vors', 'lbl-vors', 'vors', '/api/nasr/navaids', renderVors);

// Airport overlay — drawn on canvas in drawOverlay()
document.getElementById('rng-airports').addEventListener('input', async function () {
    nasrBrightness.airports = parseInt(this.value);
    document.getElementById('lbl-airports').textContent = nasrBrightness.airports;
    if (nasrBrightness.airports > 0 && !airportOverlayData) {
        try {
            const resp = await fetch('/api/nasr/airports');
            if (resp.ok) airportOverlayData = await resp.json();
        } catch (e) { console.warn('[NASR] airports:', e); }
    }
    drawOverlay();
    saveSettingsToUrl();
});

document.getElementById('rng-centerlines').addEventListener('input', async function () {
    nasrBrightness.centerlines = parseInt(this.value);
    document.getElementById('lbl-centerlines').textContent = nasrBrightness.centerlines;
    if (nasrBrightness.centerlines > 0 && !centerlineData) {
        try {
            const resp = await fetch('/api/nasr/centerlines');
            if (resp.ok) centerlineData = await resp.json();
        } catch (e) { console.warn('[NASR] centerlines:', e); }
    }
    drawOverlay();
    saveSettingsToUrl();
});

// Procedure overlay — managed via .SID/.STAR/.PROC MCA commands
// activeProcedures: Map<string, { layer: L.layerGroup, procs: Array, query: string }>
const activeProcedures = new Map();

function renderProcedureLegs(data, group, br) {
    const col = nasrColor(br);
    for (const proc of data) {
        for (const leg of proc.legs) {
            if (leg.length >= 2) {
                L.polyline(leg, { color: col, weight: 1, opacity: 1, dashArray: '6 4', interactive: false, className: 'bnd-path' }).addTo(group);
            }
        }
    }
}

document.getElementById('rng-proc').addEventListener('input', function () {
    nasrBrightness.proc = parseInt(this.value);
    document.getElementById('lbl-proc').textContent = nasrBrightness.proc;
    const col = nasrColor(nasrBrightness.proc);
    for (const [key, entry] of activeProcedures) {
        if (nasrBrightness.proc <= 0) {
            if (map.hasLayer(entry.layer)) map.removeLayer(entry.layer);
        } else {
            if (!map.hasLayer(entry.layer)) entry.layer.addTo(map);
            entry.layer.eachLayer(l => l.setStyle({ color: col }));
        }
    }
    saveSettingsToUrl();
});

function clearProcOverlay() {
    for (const [key, entry] of activeProcedures) {
        if (map.hasLayer(entry.layer)) map.removeLayer(entry.layer);
    }
    activeProcedures.clear();
}

// ════════════════════════════════════════════════════════════════════════════
// MRMS weather radar overlay — ERAM-style pixel rendering
// Source: NOAA nowCOAST WMS (MRMS base reflectivity composite)
// https://nowcoast.noaa.gov/geoserver/observations/weather_radar/ows
// Updates every ~4 minutes, CORS-enabled, transparent PNG tiles
// NWS standard radar colors → parsed on canvas → remapped to ERAM categories:
//   Moderate (20-40 dBZ, NWS greens/yellows) → solid blue #0044ff
//   Heavy (40-55 dBZ, NWS oranges/reds) → checkered cyan #00ccff / black
//   Extreme (55+ dBZ, NWS dark reds/magentas) → solid cyan #00ccff
// ════════════════════════════════════════════════════════════════════════════
let nexradLayer = null;
let nexradLevel = 3;           // 0=OFF, 1=extreme(3), 2=heavy+extreme(23), 3=all(123)
let nexradBrightness = 30;
const MRMS_WMS_URL = 'https://nowcoast.noaa.gov/geoserver/observations/weather_radar/ows';

// Classify NWS radar pixel to ERAM NEXRAD level (0=none, 1=moderate, 2=heavy, 3=extreme)
// NOAA MRMS palette: cyan/blue (5-15 dBZ) → green (20-30) → yellow/gold (35-40) → orange (45) → red (50+) → magenta (65+)
// Only cyan/blue = moderate; all greens and warmer = heavy; reds/magentas = extreme.
// Tuned to match CRC NEXRAD where heavy (checkered) covers most precipitation area.
function classifyNwsPixel(r, g, b, a) {
    if (a < 128) return 0;                              // filter anti-aliased edges
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    if (max < 30) return 0;
    const delta = max - min;
    if (delta < 15) return 0;                            // filter greys/unsaturated
    // Blue/cyan dominant or bright greens: moderate
    if ((b > r && b >= g) || (g > r * 3 && g >= b)) return 1;
    // Red strongly dominant over green: extreme — 50+ dBZ
    if (r > g * 2.5) return 3;
    // Everything else (yellows, oranges, orange-reds): heavy
    return 2;
}

const MrmsEramLayer = L.GridLayer.extend({
    createTile: function (coords, done) {
        const tile = document.createElement('canvas');
        tile.width = tile.height = 256;
        const ctx = tile.getContext('2d');
        const level = this.options.nxLevel || 3;
        // Build WMS GetMap URL
        const bounds = this._tileCoordsToBounds(coords);
        const sw = bounds.getSouthWest(), ne = bounds.getNorthEast();
        const bbox = `${sw.lng},${sw.lat},${ne.lng},${ne.lat}`;
        const url = `${MRMS_WMS_URL}?service=WMS&version=1.1.1&request=GetMap` +
            `&layers=conus_base_reflectivity_mosaic&srs=EPSG:4326` +
            `&bbox=${bbox}&width=256&height=256&format=image/png&transparent=true`;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            ctx.drawImage(img, 0, 0, 256, 256);
            // Remap NWS colors to ERAM categories
            const imageData = ctx.getImageData(0, 0, 256, 256);
            const d = imageData.data;
            for (let i = 0; i < d.length; i += 4) {
                const cat = classifyNwsPixel(d[i], d[i + 1], d[i + 2], d[i + 3]);
                if (cat === 0) { d[i + 3] = 0; continue; }
                // NX LVL filtering: 1=extreme only, 2=heavy+extreme, 3=all
                if (level === 1 && cat < 3) { d[i + 3] = 0; continue; }
                if (level === 2 && cat < 2) { d[i + 3] = 0; continue; }
                const px = i / 4;
                const tx = px % 256, ty = Math.floor(px / 256);
                if (cat === 1) {
                    // Moderate: solid blue (#0044ff)
                    d[i] = 0; d[i + 1] = 68; d[i + 2] = 255;
                } else if (cat === 2) {
                    // Heavy: checkered cyan (#00ccff) and black
                    if ((Math.floor(tx / 4) + Math.floor(ty / 4)) % 2 === 0) {
                        d[i] = 0; d[i + 1] = 204; d[i + 2] = 255;
                    } else {
                        d[i] = 0; d[i + 1] = 0; d[i + 2] = 0;
                    }
                } else {
                    // Extreme: solid cyan (#00ccff)
                    d[i] = 0; d[i + 1] = 204; d[i + 2] = 255;
                }
                d[i + 3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
            done(null, tile);
        };
        img.onerror = () => done(null, tile);  // blank tile on error
        img.src = url;
        return tile;
    }
});

function createNexradLayer() {
    return new MrmsEramLayer({
        pane: 'nexrad',
        opacity: nexradBrightness / 100,
        maxZoom: 16,
        tileSize: 256,
        nxLevel: nexradLevel,
    });
}

function updateNexrad() {
    if (nexradLayer) { map.removeLayer(nexradLayer); nexradLayer = null; }
    if (nexradLevel === 0) return;
    nexradLayer = createNexradLayer();
    nexradLayer.addTo(map);
}

// Auto-refresh every 5 minutes (nowCOAST updates every ~4 min)
if (nexradLevel > 0) updateNexrad();
setInterval(() => {
    if (nexradLayer) { map.removeLayer(nexradLayer); nexradLayer = createNexradLayer(); nexradLayer.addTo(map); }
}, 5 * 60 * 1000);

document.getElementById('sel-nxlvl').addEventListener('change', function () {
    const v = this.value;
    nexradLevel = v === '123' ? 3 : v === '23' ? 2 : v === '3' ? 1 : 0;
    updateNexrad();
    saveSettingsToUrl();
});

document.getElementById('rng-nx').addEventListener('input', function () {
    nexradBrightness = parseInt(this.value);
    document.getElementById('lbl-nx').textContent = nexradBrightness;
    if (nexradLayer) nexradLayer.setOpacity(nexradBrightness / 100);
    saveSettingsToUrl();
});

// ════════════════════════════════════════════════════════════════════════════
// Visibility & classification
// ════════════════════════════════════════════════════════════════════════════
function isEmergency(f) {
    return f.squawk === '7700' || f.squawk === '7600' || f.squawk === '7500';
}

function isVisible(f) {
    if (f.latitude == null || f.longitude == null) return false;
    // Allow DROPPED flights briefly — 1 minute grace for handoff transitions where
    // old center drops the track but new center hasn't sent position yet.
    // Uses server-side posAge (seconds since last position) — immune to snapshot resets.
    if (f.flightStatus === 'CANCELLED') return false;
    if (f.flightStatus === 'DROPPED' && (f.posAge == null || f.posAge > 60)) return false;
    if (f.flightStatus && f.flightStatus !== 'ACTIVE' && f.flightStatus !== 'DROPPED') return false;
    // Hide stale ACTIVE flights — no position update for >10 minutes means SFDPS lost the track
    if (f.flightStatus === 'ACTIVE' && f.posAge != null && f.posAge > 600) return false;

    // Altitude filter (reported altitude in feet → FL in hundreds)
    // Exempt: FDB tracks, and any track the user explicitly toggled (fdbOverrides entry)
    if (altFilterLow > 0 || altFilterHigh < 999) {
        const cls = classifyTrack(f);
        if (!shouldShowFdb(f.gufi, cls) && !fdbOverrides.has(f.gufi)) {
            const alt = f.reportedAltitude;
            if (alt != null) {
                const fl = Math.round(alt / 100);
                if (fl < altFilterLow || fl > altFilterHigh) return false;
            }
        }
    }

    // No facility selected → show all
    if (!myFacility) return true;
    // Show if controlling/reporting facility matches
    // In facilityOnly mode, only controllingFacility counts — reportingFacility alternates
    // between centers on each SFDPS update, causing flicker if used for strict filtering
    const fac = f.controllingFacility || '';
    const rptFac = f.reportingFacility || '';
    if (fac === myFacility || (!facilityOnly && rptFac === myFacility)) return true;
    // Show if handoff involves our facility
    if (f.handoffReceiving && extractFac(f.handoffReceiving) === myFacility) return true;
    if (f.handoffTransferring && extractFac(f.handoffTransferring) === myFacility) return true;
    // "Facility only" — strict mode: only show aircraft reported by our facility (above checks)
    if (facilityOnly) return false;
    // Keep flights visible that were previously own/ho (prevents disappearing during handoff transitions)
    if (wasOwnOrHo.has(f.gufi)) return true;
    // Keep flights visible that have a recent completed handoff involving us
    if (hoCompletedInfo.has(f.gufi)) return true;
    // Grace period: keep recently-visible flights for 120s to prevent flicker on facility field changes
    const lastVis = lastVisibleAt.get(f.gufi);
    if (lastVis && performance.now() - lastVis < 120000) return true;
    return false;
}

function classifyTrack(f) {
    if (isEmergency(f)) return 'emrg';
    if (!myFacility) return 'other';
    // Sectors must be selected to have own/ho tracks — prevents entire ARTCC from being FDB
    if (mySectors.size === 0) return 'other';

    const fac = f.controllingFacility || f.reportingFacility || '';
    const sec = f.controllingSector || '';
    const hoEvt = hoEventType(f.handoffEvent);

    // Active handoff involving our sector(s)
    if (hoEvt) {
        const recvFac = extractFac(f.handoffReceiving);
        const xferFac = extractFac(f.handoffTransferring);
        const recvSec = extractSec(f.handoffReceiving);
        const xferSec = extractSec(f.handoffTransferring);
        const recvIsMe = recvFac === myFacility && mySectors.has(recvSec);
        const xferIsMe = xferFac === myFacility && mySectors.has(xferSec);
        if (recvIsMe || xferIsMe) return 'ho';
    }

    if (fac === myFacility && mySectors.has(sec)) return 'own';
    return 'other';
}

function extractFac(unitStr) { return unitStr ? unitStr.split('/')[0] : ''; }
function extractSec(unitStr) { if (!unitStr) return ''; const p = unitStr.split('/'); return p.length > 1 ? p[1] : ''; }

// Get CID for the observed facility (each ARTCC assigns its own CID to a flight)
function getCid(f) {
    // Each ARTCC assigns its own CID — only show the selected facility's CID.
    // Never show a foreign facility's CID (controllers only see their own).
    if (myFacility && f.computerIds) {
        return f.computerIds[myFacility] || '';
    }
    // No facility selected ("All") — show most recent CID from any facility
    return f.computerId || '';
}

// Handoff event classification — SFDPS sends INITIATION/ACCEPTANCE/UPDATE/EXECUTION
function hoEventType(evt) {
    if (!evt) return '';
    const e = evt.toUpperCase();
    if (e === 'INITIATION' || e.startsWith('PROPOS')) return 'PROPOSED';
    if (e === 'ACCEPTANCE' || e.startsWith('ACCEPT')) return 'ACCEPTED';
    if (e === 'UPDATE') return 'PROPOSED';  // UPDATE during active handoff — treat as proposed
    if (e.startsWith('EXECUT')) return 'EXECUTING';
    return '';  // CANCELLATION, COMPLETED, etc. — not active
}

// ════════════════════════════════════════════════════════════════════════════
// ERAM Full Data Block formatting
// ════════════════════════════════════════════════════════════════════════════
//
// Line 0: P/A (point out) — above data block
// Column 0: R (not your control) — left of data block, bulges out
// Line 1: Field A (callsign) + SatComm (*)
// Line 2: Field B (assigned alt) + status char + Field C (reported alt)
// Line 3: Field D (CID) + Field E (GS/Hxxx/Oxxx/EMRG)
// Line 4: Field F (destination ICAO)
//
// Status chars: C=conforming(hide Field C), T=interim, L=local interim,
//   P=procedure, ↑=climbing, ↓=descending, +=above, -=below,
//   X=no Mode C, N=no target, B=block alt, /=VFR

const LDR_DX = 20;
const LDR_DY = 0;   // flat horizontal leader line (ERAM default position 5 = right)
const LDR_LEN = 40; // leader line length
let CHAR_W = fontSize * 0.625;  // approx char width in ERAM font
let LINE_H = fontSize * 1.25;   // line-height

// Data block position offsets (numpad layout):
//   7=NW  8=N   9=NE
//   4=W   5=def 6=E
//   1=SW  2=S   3=SE
function getLeaderOffset(gufi) {
    const pos = dbPositions.get(gufi);
    const level = ldrLenOverrides.get(gufi) ?? 1;
    const len = level * LDR_LEN;
    if (len === 0) return { dx: 0, dy: 0 };
    const D = len * 0.707; // diagonal distance
    if (!pos || pos === 9) return { dx: D, dy: -D };             // NE (default)
    switch (pos) {
        case 1: return { dx: -D, dy: D };      // SW
        case 2: return { dx: 0, dy: len };      // S
        case 3: return { dx: D, dy: D };        // SE
        case 4: return { dx: -len, dy: 0 };     // W
        case 5:
        case 6: return { dx: len, dy: 0 };      // E
        case 7: return { dx: -D, dy: -D };      // NW
        case 8: return { dx: 0, dy: -len };     // N
        case 9: return { dx: D, dy: -D };       // NE
        default: return { dx: D, dy: -D };     // NE (default)
    }
}

// Position data block so the leader line endpoint aligns with the correct edge/line.
// FDB anchor varies by direction:
//   N:  left edge, between lines 3-4    NE: left edge, between lines 2-3
//   E:  left edge, between lines 2-3    SE: left edge, between lines 1-2
//   S:  left edge, between lines 1-2    SW: right edge, between lines 1-2
//   W:  right edge, between lines 2-3   NW: right edge, between lines 2-3
// xShift: 0 = left-aligned (text extends right), -1 = right-aligned (text extends left)
function getDbAnchor(gufi, numLines) {
    const pos = dbPositions.get(gufi) || 9;
    const isLeft = (pos === 1 || pos === 4 || pos === 7);

    if (numLines === 2) {
        // LDB: anchor between lines 1-2 for all directions
        return { xShift: isLeft ? -1 : 0, yShift: -LINE_H };
    }

    // FDB (4 lines): direction-specific anchor
    switch (pos) {
        case 8: return { xShift: 0,  yShift: -3 * LINE_H };  // N:  left edge, between 3-4
        case 9: return { xShift: 0,  yShift: -2 * LINE_H };  // NE: left edge, between 2-3
        case 5:
        case 6: return { xShift: 0,  yShift: -2 * LINE_H };  // E:  left edge, between 2-3
        case 3: return { xShift: 0,  yShift: -LINE_H };       // SE: left edge, between 1-2
        case 2: return { xShift: 0,  yShift: -LINE_H };       // S:  left edge, between 1-2
        case 1: return { xShift: -1, yShift: -LINE_H };       // SW: right edge, between 1-2
        case 4: return { xShift: -1, yShift: -2 * LINE_H };   // W:  right edge, between 2-3
        case 7: return { xShift: -1, yShift: -2 * LINE_H };   // NW: right edge, between 2-3
        default: return { xShift: 0, yShift: -2 * LINE_H };
    }
}

// Check if flight is in reduced separation area (at or below FL230)
function isReducedSep(f) {
    const alt = f.reportedAltitude ?? f.assignedAltitude;
    return alt != null && alt <= 23000;
}

function isCoasting(f) {
    // Use server-side posAge (seconds since last position update) — immune to WebSocket message drops
    // Coast if: ACTIVE flight with no position update for >26s (2 SFDPS cycles + 1s batch + jitter)
    if (f.posAge != null && f.flightStatus === 'ACTIVE' && f.posAge > 26) return true;
    return false;
}

function getSymbolClass(f) {
    // Coast: no position update for >2 scan cycles
    if (isCoasting(f)) return 'ac-sym-coast';
    // Reduced separation: at or below FL230 → dot
    if (f.callsign && isReducedSep(f)) return 'ac-sym-reduced-sep';
    // SFDPS en route flights are virtually all transponder-equipped correlated targets.
    if (f.callsign) return 'ac-sym-corr-bcn';      // \ Correlated Beacon (most common)
    if (f.squawk) return 'ac-sym-uncorr-bcn';       // / Uncorrelated Beacon
    return 'ac-sym-flat-track';                      // ◇ Unknown/no identification
}

// History symbol character per target type (drawn on canvas)
function getSymbolChar(f) {
    // Coast: no position update for >2 scan cycles
    if (isCoasting(f)) return '#';
    // Reduced separation: at or below FL230 → dot
    if (f.callsign && isReducedSep(f)) return '\u2022';  // • dot
    if (f.callsign) return '\\';   // Correlated Beacon (most common)
    if (f.squawk) return '/';      // Uncorrelated Beacon
    return '\u25C7';               // ◇ Unknown
}

// Should column 0 "R" indicator show? (track not under our control)
// R = position does not own the track:
//   - Outgoing ACCEPTED/completed: we gave it away → R
//   - Incoming PROPOSED: offered to us but not yet accepted → R
//   - Incoming ACCEPTED/completed: we accepted, we own it → no R
//   - Outgoing PROPOSED: we initiated but still own it → no R
//   - Other tracks not ours at all → R
function shouldShowR(f, cls) {
    if (!myFacility || mySectors.size === 0) return false;
    if (cls === 'emrg') return false;

    // Controlling sector is authoritative — trust what SFDPS says
    if (cls === 'own') return false;
    const ctrlFac = f.controllingFacility || '';
    const ctrlSec = f.controllingSector || '';
    if (ctrlFac === myFacility && mySectors.has(ctrlSec)) return false;

    // Active handoff involving our sector(s)
    const hoEvt = hoEventType(f.handoffEvent);
    if (hoEvt && f.handoffReceiving) {
        const recvFac = extractFac(f.handoffReceiving);
        const recvSec = extractSec(f.handoffReceiving);
        const xferFac = extractFac(f.handoffTransferring);
        const xferSec = extractSec(f.handoffTransferring);
        const recvIsMe = recvFac === myFacility && mySectors.has(recvSec);
        const xferIsMe = xferFac === myFacility && mySectors.has(xferSec);

        if (xferIsMe && hoEvt === 'PROPOSED') return false;  // We initiated, still own it
        if (xferIsMe && hoEvt === 'ACCEPTED') return true;   // We gave it away
        if (recvIsMe && hoEvt === 'PROPOSED') return true;    // Incoming, not yet accepted
        if (recvIsMe && hoEvt === 'ACCEPTED') return false;   // We accepted, we own it
    }

    // Completed handoff — informational (O display), R follows controlling sector above
    const completed = hoCompletedInfo.get(f.gufi);
    if (completed) {
        const recvIsMe = extractFac(completed.receiving) === myFacility && mySectors.has(extractSec(completed.receiving));
        if (recvIsMe) return false;  // Incoming completed — we now own it, no R
        const xferIsMe = extractFac(completed.transferring) === myFacility && mySectors.has(extractSec(completed.transferring));
        if (xferIsMe) return true;   // Outgoing completed — show R
    }

    // Default: R for any track we don't own
    return true;
}

// Determine if a track should show FDB (full data block) or LDB (limited)
function shouldShowFdb(gufi, cls) {
    // User override takes priority
    if (fdbOverrides.has(gufi)) return fdbOverrides.get(gufi);
    // Quick Look sectors: force FDB on tracks in QL'd sectors
    if (quickLookSectors.size > 0) {
        const f = flights.get(gufi);
        if (f) {
            const sec = f.controllingSector || '';
            if (quickLookSectors.has(sec)) return true;
        }
    }
    // Quick Look destinations: force FDB on flights to QL'd airports
    if (quickLookDests.size > 0) {
        const f = flights.get(gufi);
        if (f && f.destination && quickLookDests.has(f.destination.toUpperCase())) return true;
    }
    // Point-out tracks force FDB
    {
        const f = flights.get(gufi);
        if (f && getPointoutIndicator(f)) return true;
    }
    // Default: own and handoff tracks get FDB, others get LDB
    return cls === 'own' || cls === 'ho' || cls === 'emrg';
}

// Dwell emphasis helpers — apply/remove box + LDB brightness boost
function applyDwell(el, gufi) {
    const dbEl = el.querySelector('.ac-db');
    if (!dbEl) return;
    dbEl.classList.add('dwell');
    // FDB: add a real border element sized from actual DOM measurements
    if (dbEl.classList.contains('fdb') && !dbEl.querySelector('.dwell-border')) {
        const b = document.createElement('div');
        b.className = 'dwell-border';
        const w = dbEl.offsetWidth;
        const h = dbEl.offsetHeight;
        const chOff = Math.round(CHAR_W * 2.2); // past column 0 + VCI, scales with font size
        // If Line 0 (point-out indicator) is present, exclude it from the dwell border
        const f0 = flights.get(gufi);
        const hasLine0 = f0 && getPointoutIndicator(f0);
        const topOff = hasLine0 ? Math.round(LINE_H) - 1 : -1;
        const heightAdj = hasLine0 ? Math.round(LINE_H) : 0;
        b.style.cssText = `left:${chOff}px;top:${topOff}px;width:${w - chOff + 2}px;height:${h - heightAdj + 2}px;`;
        dbEl.appendChild(b);
    }
    const f = flights.get(gufi);
    if (f && !shouldShowFdb(gufi, classifyTrack(f))) dbEl.style.opacity = '1';
}
function removeDwell(el, gufi) {
    const dbEl = el.querySelector('.ac-db');
    if (!dbEl) return;
    dbEl.classList.remove('dwell');
    const b = dbEl.querySelector('.dwell-border');
    if (b) b.remove();
    const f = flights.get(gufi);
    if (f && !shouldShowFdb(gufi, classifyTrack(f))) dbEl.style.opacity = String(ldbBrightness / 100);
}

// Build target symbol as pure CSS geometry — no font metrics, pixel-perfect centering at (0,0)
function buildTargetSym(symChar, isEmrg, extraStyle) {
    const c = isEmrg ? '#ff4444' : '#cccc44';
    const st = extraStyle ? extraStyle + ';' : '';
    // Invisible 16×16 hit area centered at (0,0) so thin symbols are easy to click
    const hit = `<div style="position:absolute;width:16px;height:16px;left:-8px;top:-8px;pointer-events:auto;cursor:inherit;z-index:2;"></div>`;
    if (symChar === '\\') {
        // Correlated beacon: 2px × 14px line, rotate(-45deg) = backslash \
        return hit + `<div style="position:absolute;width:2px;height:14px;left:-1px;top:-7px;background:${c};transform:rotate(-45deg);pointer-events:none;z-index:2;${st}"></div>`;
    }
    if (symChar === '/') {
        // Uncorrelated beacon: 2px × 14px line, rotate(45deg) = forward slash /
        return hit + `<div style="position:absolute;width:2px;height:14px;left:-1px;top:-7px;background:${c};transform:rotate(45deg);pointer-events:none;z-index:2;${st}"></div>`;
    }
    if (symChar === '\u2022') {
        // Reduced separation: 5px filled circle centered at (0,0)
        return hit + `<div style="position:absolute;width:5px;height:5px;left:-2.5px;top:-2.5px;border-radius:50%;background:${c};pointer-events:none;z-index:2;${st}"></div>`;
    }
    if (symChar === '#') {
        // Coast track: # — 2 horizontal lines + 2 slanted vertical lines (like /)
        const sz = 14, g = 5, w = 2, slant = 3;
        return hit + `<div style="position:absolute;pointer-events:none;z-index:2;${st}">`
            + `<div style="position:absolute;width:${sz}px;height:${w}px;left:${-sz/2}px;top:${-g/2 - w/2}px;background:${c}"></div>`
            + `<div style="position:absolute;width:${sz}px;height:${w}px;left:${-sz/2}px;top:${g/2 - w/2}px;background:${c}"></div>`
            + `<div style="position:absolute;width:${w}px;height:${sz}px;left:${-g/2 - w/2}px;top:${-sz/2}px;background:${c};transform:skewX(-15deg)"></div>`
            + `<div style="position:absolute;width:${w}px;height:${sz}px;left:${g/2 - w/2}px;top:${-sz/2}px;background:${c};transform:skewX(-15deg)"></div>`
            + `</div>`;
    }
    // Diamond (◇): FDB draws via ac-sym-flat-track; LDB still needs a hit area
    return hit;
}

function buildMarkerHtml(f, cls) {
    const isEmrg = cls === 'emrg';
    const emrgCls = isEmrg ? ' emrg' : '';

    const symChar = getSymbolChar(f);

    const coast = symChar === '#';

    if (!showFdb) {
        // Data blocks off — just target symbol + diamond (no diamond for coast tracks)
        let html = buildTargetSym(symChar, isEmrg);
        if (!coast) html += `<div class="ac-sym-flat-track${emrgCls}"></div>`;
        return html;
    }

    const useFdb = shouldShowFdb(f.gufi, cls);

    // FDB: diamond + symbol; LDB: just the symbol character (no diamond for coast tracks)
    let html;
    if (useFdb) {
        html = buildTargetSym(symChar, isEmrg);
        if (!coast) html += `<div class="ac-sym-flat-track${emrgCls}"></div>`;
    } else {
        const ldbOp = ldbBrightness / 100;
        html = buildTargetSym(symChar, isEmrg, `opacity:${ldbOp}`);
    }

    const color = isEmrg ? EMRG_COLOR : TRACK_COLOR;
    const ldr = getLeaderOffset(f.gufi);
    const numLines = useFdb ? 4 : 2;
    const anchor = getDbAnchor(f.gufi, numLines);
    const isLeftPos = anchor.xShift === -1;
    const pos = dbPositions.get(f.gufi) || 9;
    const isVertical = (pos === 2 || pos === 8);

    // Gap from leader endpoint to data block (Column 0 is inline, provides visual separation)
    const dbGap = Math.ceil(CHAR_W * 0.5);

    // Compute data block CSS position
    let leftStyle;
    if (isLeftPos) leftStyle = `right:${-ldr.dx + dbGap}px`;
    else if (isVertical) leftStyle = `left:${ldr.dx - Math.round(CHAR_W * 1.5) - 2}px`;  // N/S: col0 sits left of leader endpoint
    else leftStyle = `left:${ldr.dx + dbGap}px`;

    // Left-positioned blocks: fixed min-width to prevent jitter during flash
    const leftExtra = isLeftPos ? ` min-width:${Math.ceil(CHAR_W * 9.5)}px;` : '';

    if (useFdb) {
        // Full Data Block (lines 1-4) — with leader line
        const showR = shouldShowR(f, cls);
        const showVci = vciActive.has(f.gufi);
        // Leader extends into col0 area for right-side positions (E/NE/SE)
        let ldrX2 = ldr.dx, ldrY2 = ldr.dy;
        if (!isLeftPos && !isVertical && ldr.dx !== 0) {
            if (showR || showVci) {
                // R/VCI present: end just before the character (left edge of col0)
                ldrX2 += dbGap;
            } else {
                // No R/VCI: extend through empty col0 to reach text
                ldrX2 += dbGap + Math.round(CHAR_W * 1.5);
            }
        }
        html += `<svg class="ac-leader" width="1" height="1" overflow="visible"><line x1="0" y1="0" x2="${ldrX2}" y2="${ldrY2}" stroke="${color}" stroke-width="1"/></svg>`;

        const db = formatFdbHtml(f, cls);
        const dbCls = isEmrg ? ' emrg' : '';
        // Line 0 (point-out indicator) adds height — shift div up so Lines 1-4 stay anchored
        const poOffset = getPointoutIndicator(f) ? -LINE_H : 0;
        html += `<div class="ac-db fdb${dbCls}" style="${leftStyle}; top:${ldr.dy + anchor.yShift + poOffset}px;${leftExtra}">${db}</div>`;
    } else if (ldbBrightness > 0) {
        // VCI clears when track goes to LDB
        vciActive.delete(f.gufi);
        // Limited Data Block (2 lines) — no leader line, right next to target
        const ldbOp = ldbBrightness / 100;
        const l1 = f.callsign || '???';
        const alt = f.reportedAltitude ?? f.assignedAltitude;
        const l2 = alt != null ? String(Math.round(alt / 100)).padStart(3, '0') : '';
        const dbCls = isEmrg ? ' emrg' : '';
        html += `<div class="ac-db ldb${dbCls}" style="left:${Math.ceil(CHAR_W)}px; top:${-LINE_H}px; opacity:${ldbOp};">${l1}\n${l2}</div>`;
    }
    // ldbBrightness === 0 for LDB → no data block at all

    return html;
}

function formatDatablock(f, cls) {
    // Line 1: Field A (callsign)
    const l1 = f.callsign || '???';

    // Line 2: Field B + status + Field C (per ERAM spec)
    const l2 = formatAltLine(f);

    // Line 3: Field D (CID) + Field E
    const l3 = formatLine3(f, cls);

    // Line 4: Field F (full ICAO destination)
    const l4 = f.destination || '';

    return l4 ? `${l1}\n${l2}\n${l3}\n${l4}` : `${l1}\n${l2}\n${l3}`;
}

// Format FDB with Column 0 inline (VCI, R) — returns HTML
const VCI_SVG = '<svg viewBox="0 0 16 16" width="1.2em" height="1.2em" style="vertical-align:-0.2em;"><path d="M3,5 L3,13 L11,13" fill="none" stroke="currentColor" stroke-width="1.5"/><path d="M5,8 A3,3 0 0,1 8,11" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M5,5.5 A5.5,5.5 0 0,1 10.5,11" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';

function formatLine4(f, hsfCol) {
    const hsf = getEffectiveHsf(f);
    const showHsf = hsfShowMap.has(f.gufi);

    // HSF mode: show heading/speed/free text
    // Speed positioned so last digit sits under ↴ (at hsfCol), +/- extends one past
    if (showHsf && hsf) {
        if (hsf.freeText) return esc(hsf.freeText);
        const h = hsf.heading || '';
        const s = hsf.speed || '';
        if (s) {
            const hasModifier = /[+-]$/.test(s);
            // ↴ is at hsfCol; last digit under it, +/- one past
            const sEnd = hasModifier ? hsfCol + 2 : hsfCol + 1;
            const sStart = sEnd - s.length;
            if (h) {
                const pad = Math.max(1, sStart - h.length);
                return esc(h + '\u00a0'.repeat(pad) + s);
            }
            const pad = Math.max(0, sStart);
            return esc('\u00a0'.repeat(pad) + s);
        }
        return esc(h);
    }

    // Normal mode: based on line4Mode setting
    if (line4Mode === 'DEST') return f.destination ? esc(f.destination) : '';
    if (line4Mode === 'TYPE') {
        const t = f.aircraftType || '';
        const eq = f.equipmentQualifier ? '/' + f.equipmentQualifier : '';
        return t ? esc(t + eq) : '';
    }
    return ''; // OFF
}

function formatFdbHtml(f, cls) {
    const showVci = vciActive.has(f.gufi);
    const showR = shouldShowR(f, cls);
    const hsf = getEffectiveHsf(f);

    const l1 = esc(f.callsign || '???');
    const l2 = esc(formatAltLine(f));
    const l3text = formatLine3(f, cls);
    const l3esc = esc(l3text);
    const l4 = formatLine4(f, l3text.length);

    // ↴ indicator appended directly at end of line 3 (no gap)
    const hasServerClr = f.clearanceHeading || f.clearanceSpeed || f.clearanceText;
    let l3;
    if (hsf && (hasServerClr || hsf.heading || hsf.speed || hsf.freeText)) {
        const hsfInd = '<span class="ac-hsf-ind" style="pointer-events:auto;cursor:inherit;">\u21b4</span>';
        l3 = l3esc + hsfInd;
    } else {
        l3 = l3esc;
    }

    // Column 0: inline spans — VCI hit area on lines 1-2, R on line 3
    const col0Hit = '<span class="ac-vci-hit" style="display:inline-block;width:1.5ch;pointer-events:auto;cursor:inherit;">\u00a0</span>';
    const col0Vci = `<span class="ac-vci-hit ac-vci" style="display:inline-block;width:1.5ch;text-align:center;pointer-events:auto;cursor:inherit;">${VCI_SVG}</span>`;
    const col0R   = '<span class="ac-col0 ac-r" style="display:inline-block;width:1.5ch;text-align:center;">R</span>';
    const col0Sp  = '<span style="display:inline-block;width:1.5ch;">\u00a0</span>';

    // Line 0: Point-out P/A indicator (between 2nd and 3rd char position)
    const poInfo = getPointoutIndicator(f);
    let html = '';
    if (poInfo) {
        html += `<span class="ac-po-line0" style="pointer-events:auto;cursor:pointer;">${col0Sp}\u00a0\u00a0<span class="ac-po-${poInfo.cls}">${poInfo.ch}</span></span>\n`;
    }
    html += `${col0Hit}${l1}\n`;
    html += `${showVci ? col0Vci : col0Hit}${l2}\n`;
    html += `${showR ? col0R : col0Sp}${l3}`;
    if (l4) html += `\n${col0Sp}${l4}`;
    return html;
}

// Determine point-out indicator for a flight.
// Returns {ch, cls, role, origSector, recvSector, origFac, recvFac} or null.
function getPointoutIndicator(f) {
    if (!f.pointoutOriginatingUnit && !f.pointoutReceivingUnit) {
        pointoutFirstSeen.delete(f.gufi);
        return null;
    }
    // DROPPED flights should not show point-outs — clear the data
    if (f.flightStatus === 'DROPPED') {
        f.pointoutOriginatingUnit = null;
        f.pointoutReceivingUnit = null;
        pointoutAcked.delete(f.gufi);
        pointoutFirstSeen.delete(f.gufi);
        if (pointoutMenuGufi === f.gufi) closePointoutMenu();
        return null;
    }
    if (!myFacility || mySectors.size === 0) return null;

    const origFac = (f.pointoutOriginatingUnit || '').split('/')[0];
    const recvFac = (f.pointoutReceivingUnit || '').split('/')[0];
    const origSector = (f.pointoutOriginatingUnit || '').split('/')[1] || '';
    const recvSector = (f.pointoutReceivingUnit || '').split('/')[1] || '';

    // Show P only if a selected sector is the originator or receiver
    const isOrig = myFacility === origFac && mySectors.has(origSector);
    const isRecv = myFacility === recvFac && mySectors.has(recvSector);
    if (isOrig || isRecv) {
        // Client-side 3-minute timeout: auto-expire if user hasn't interacted
        const now = Date.now();
        if (!pointoutFirstSeen.has(f.gufi)) {
            pointoutFirstSeen.set(f.gufi, now);
        } else if (now - pointoutFirstSeen.get(f.gufi) > PO_CLIENT_TIMEOUT) {
            // Expired — clear point-out data silently
            f.pointoutOriginatingUnit = null;
            f.pointoutReceivingUnit = null;
            pointoutAcked.delete(f.gufi);
            pointoutFirstSeen.delete(f.gufi);
            if (pointoutMenuGufi === f.gufi) closePointoutMenu();
            return null;
        }
        const role = isOrig ? 'originator' : 'receiver';
        const acked = pointoutAcked.has(f.gufi);
        return { ch: acked ? 'A' : 'P', cls: acked ? 'accepted' : 'pending',
                 role, origSector, recvSector, origFac, recvFac };
    }
    return null;
}

function formatAltLine(f) {
    const localA = localAssignedAlt.get(f.gufi);
    const localI = localInterimAlt.get(f.gufi);
    const localR = localReportedAlt.get(f.gufi);

    // Local controller overrides win when present; server fills gaps
    // Server auto-clears local overrides only when it sends genuinely new values
    const assigned = localA ? localA.feet : (f.assignedAltitude ?? null);
    const reported = localR ? localR.feet : (f.reportedAltitude ?? null);
    const interim = localI ? localI.feet : (f.interimAltitude ?? null);

    const afl = assigned != null ? String(Math.round(assigned / 100)).padStart(3, '0') : '';
    const rfl = reported != null ? String(Math.round(reported / 100)).padStart(3, '0') : '';

    // VFR/OTP display — local QZ override wins, then server assignedVfr
    const isVfr = (localA && (localA.rules === 'VFR' || localA.rules === 'OTP')) || (!localA && f.assignedVfr);
    if (isVfr) {
        const localRules = localA ? localA.rules : null;
        const prefix = localRules === 'OTP' ? 'OTP' : 'VFR';
        // VFR with altitude (vfrPlus) → VFR/055; VFR without → just VFR
        if (afl) return rfl ? `${prefix}/${rfl}` : `${prefix}/${afl}`;
        return rfl ? `${prefix}/${rfl}` : prefix;
    }

    // Block altitude — local QZ override wins, then server blockFloor/blockCeiling
    if (localA && localA.block) {
        return rfl ? `${localA.block}${rfl}` : localA.block;
    }
    if (!localA && f.blockFloor != null && f.blockCeiling != null) {
        const floor = String(Math.round(f.blockFloor / 100)).padStart(3, '0');
        const ceil = String(Math.round(f.blockCeiling / 100)).padStart(3, '0');
        const blockDisp = `${floor}B${ceil}`;
        return rfl ? `${blockDisp}${rfl}` : blockDisp;
    }

    // Interim/procedure/local altitude → T, P, or L indicator
    if (interim != null) {
        const ifl = String(Math.round(interim / 100)).padStart(3, '0');
        const localType = localI ? localI.type : null;
        const indicator = localType === 'P' ? 'P' : localType === 'L' ? 'L' : 'T';
        return rfl ? `${ifl}${indicator}${rfl}` : `${ifl}${indicator}`;
    }

    if (assigned == null && reported == null) return '';
    if (assigned == null) return rfl;

    // No Mode C reported → X indicator: {assigned}XXXX
    if (reported == null) return `${afl}XXXX`;

    const aAlt = Math.round(assigned / 100);
    const rAlt = Math.round(reported / 100);
    const diff = rAlt - aAlt;

    // Conforming (at altitude, within ±2 FL / 200ft) → C, hide Field C
    if (Math.abs(diff) <= 2) return `${afl}C`;

    // Non-conforming: track initial side to distinguish ↑↓ (on course) vs +- (overshoot)
    // _altInitialSide records whether reported was above (+1) or below (-1) assigned
    // when the aircraft first became non-conforming (or when assigned altitude changed).
    // Same side as initial → ↑ or ↓ (still en route); crossed to opposite side → + or - (overshot).
    const initSide = f._altInitialSide || 0;
    if (initSide < 0) {
        // Started below assigned (was climbing)
        if (diff < 0) return `${afl}\u2191${rfl}`;  // ↑ still below, climbing to assigned
        return `${afl}+${rfl}`;  // + overshot above assigned
    } else if (initSide > 0) {
        // Started above assigned (was descending)
        if (diff > 0) return `${afl}\u2193${rfl}`;  // ↓ still above, descending to assigned
        return `${afl}-${rfl}`;  // - overshot below assigned
    }
    // No initial side recorded yet — fall back to current position
    if (diff < 0) return `${afl}\u2191${rfl}`;
    return `${afl}\u2193${rfl}`;
}

function formatLine3(f, cls) {
    const cidVal = getCid(f);
    const cid = cidVal ? String(cidVal).padStart(3, ' ') : '   ';
    const gs = f.groundSpeed != null ? String(Math.round(f.groundSpeed)).padStart(3, '0') : '';
    const destLetter = getDestinationLetter(f.destination);
    // Normal Field E: single-letter destination + 3-digit groundspeed, or just groundspeed
    const gsStr = destLetter && gs ? `${cid}${destLetter}${gs}` : gs ? `${cid} ${gs}` : cid;

    // ── ERAM Field E priority (per specification) ──

    // 1. Special squawk codes (highest priority, static display)
    if (f.squawk === '7500') return `${cid} HIJK`;
    if (f.squawk === '7600') return `${cid} RDOF`;
    if (f.squawk === '7700') return `${cid} EMRG`;
    if (f.squawk === '1276') return `${cid} ADIZ`;
    if (f.squawk === '7400') return `${cid} LLNK`;
    if (f.squawk === '7777') return `${cid} AFIO`;

    // 2. Active handoff — flash in Field E (uses global flashTime so ALL tracks sync)
    //    H = proposed, O = accepted/executing, K = forced acceptance (/OK)
    //    HUNK/OUNK/KUNK = unknown sector variant
    const hoEvt = hoEventType(f.handoffEvent);
    if (hoEvt && f.handoffReceiving) {
        const recvSec = extractSec(f.handoffReceiving);
        const isUnknown = !recvSec;
        let hoLetter;
        if (f.handoffForced) hoLetter = 'K';
        else if (hoEvt === 'PROPOSED') hoLetter = 'H';
        else hoLetter = 'O';

        const hoStr = isUnknown
            ? `${cid} ${hoLetter === 'H' ? 'HUNK' : hoLetter === 'K' ? 'KUNK' : 'OUNK'}`
            : `${cid}${hoLetter}${handoffSuffix(f.handoffReceiving, f.handoffTransferring)}`;
        const padLen = Math.max(hoStr.length, gsStr.length);
        if (hoEvt === 'PROPOSED' && !f.handoffForced) {
            // Fast blink: 0.5s on/off, alternate H-xx / GS every 6s
            const tick = Math.floor(flashTime / 500) % 24;
            const phase = tick < 12 ? 0 : 1;
            const visible = tick % 2 === 0;
            if (!visible) return cid.padEnd(padLen);
            if (phase === 0) return hoStr.padEnd(padLen);
            return gsStr.padEnd(padLen);
        } else {
            // Slow 6-second cycle: 3s indicator, 3s GS (O/K — no rapid on/off)
            const phase = Math.floor(flashTime / 3000) % 2;
            if (phase === 0) return hoStr.padEnd(padLen);
            return gsStr.padEnd(padLen);
        }
    }

    // 3. Completed handoff — rotate indicator / groundspeed for 60 seconds (5 cycles of 12s)
    //    Uses K for forced (/OK) completions, O for normal
    const completed = hoCompletedInfo.get(f.gufi);
    if (completed && flashTime - completed.time < 60000) {
        const recvSec = extractSec(completed.receiving);
        const isUnknown = !recvSec;
        const letter = completed.forced ? 'K' : 'O';
        const hoStr = isUnknown
            ? `${cid} ${letter === 'K' ? 'KUNK' : 'OUNK'}`
            : `${cid}${letter}${handoffSuffix(completed.receiving, completed.transferring)}`;
        const padLen = Math.max(hoStr.length, gsStr.length);
        // 12s per cycle: 6s indicator, 6s groundspeed
        const phase = Math.floor((flashTime - completed.time) / 6000) % 2;
        if (phase === 0) return hoStr.padEnd(padLen);
        return gsStr.padEnd(padLen);
    }

    // 4. Coast track → CST in Field E (per CRC spec)
    if (isCoasting(f)) return `${cid} CST`;

    // 5. Beacon code mismatch (per CRC spec: #### if received differs from assigned, NONE if no received)
    if (f.assignedSquawk) {
        if (!f.squawk) return `${cid} NONE`;
        if (f.squawk !== f.assignedSquawk) return `${cid} ${f.squawk}`;
    }

    // 6. Normal: destination letter + groundspeed
    return gsStr;
}

// Build handoff suffix: intra-facility = -xx, inter-facility = Nxx (handoff code)
function handoffSuffix(receiving, transferring) {
    const recvFac = extractFac(receiving);
    const recvSec = extractSec(receiving);
    const xferFac = transferring ? extractFac(transferring) : '';
    if (!recvFac || !recvSec) return `-${(recvSec || '??').padStart(2, '0')}`;
    // Inter-facility: use handoff code of receiving facility
    if (xferFac && xferFac !== recvFac) {
        const code = getHandoffCode(recvFac);
        return `${code}${recvSec.padStart(2, '0')}`;
    }
    // Intra-facility: use dash
    return `-${recvSec.padStart(2, '0')}`;
}

// ════════════════════════════════════════════════════════════════════════════
// History tracking
// ════════════════════════════════════════════════════════════════════════════
function addHistoryPoint(gufi, lat, lon, sym) {
    if (!flightHistory.has(gufi)) flightHistory.set(gufi, []);
    const hist = flightHistory.get(gufi);
    hist.push({ lat, lon, sym: sym || '\\', time: performance.now() });
    if (hist.length > MAX_HISTORY) hist.shift();
}

// ════════════════════════════════════════════════════════════════════════════
// Flight update processing (shared by 'update' and 'batch' message types)
// ════════════════════════════════════════════════════════════════════════════
function processFlightUpdate(f) {
    trackFacility(f);

    const existing = flights.get(f.gufi);
    if (existing) {
        existing._clientLastUpdate = performance.now();
        // Capture old state BEFORE overwriting
        const oldHoEvt = hoEventType(existing.handoffEvent);
        const oldHoRecv = existing.handoffReceiving;
        const oldHoXfer = existing.handoffTransferring;
        const oldHoForced = existing.handoffForced;
        const oldCuFac = existing.controllingFacility;
        const oldCuSec = existing.controllingSector;
        const hadClr = existing.clearanceHeading || existing.clearanceSpeed || existing.clearanceText;

        // Track vertical rate for altitude status indicators
        if (f.reportedAltitude != null && existing.reportedAltitude != null) {
            existing._vertRate = f.reportedAltitude - existing.reportedAltitude;
        }

        // Track initial side for altitude status indicators (↑↓ vs +-)
        // Reset when assigned altitude changes (new clearance = new intent)
        if ('assignedAltitude' in f && f.assignedAltitude !== existing.assignedAltitude) {
            existing._altInitialSide = 0;
        }

        // Record history from old position, then apply new position immediately
        if (f.latitude != null && f.longitude != null) {
            const oldLat = existing.latitude;
            const oldLon = existing.longitude;
            if (oldLat != null && oldLon != null) {
                const dlat = Math.abs(oldLat - f.latitude);
                const dlon = Math.abs(oldLon - f.longitude);
                if (dlat > 0.0001 || dlon > 0.0001) {
                    addHistoryPoint(f.gufi, oldLat, oldLon, getSymbolChar(existing));
                }
            }
        }
        // Suppress server clearance fields that were manually cleared via QS *
        const sup = hsfClrSuppressed.get(f.gufi);
        if (sup) {
            if ('clearanceHeading' in f) {
                if ((f.clearanceHeading || null) === sup.h) f.clearanceHeading = null;
                else sup.h = null;
            }
            if ('clearanceSpeed' in f) {
                if ((f.clearanceSpeed || null) === sup.s) f.clearanceSpeed = null;
                else sup.s = null;
            }
            if ('clearanceText' in f) {
                if ((f.clearanceText || null) === sup.t) f.clearanceText = null;
                else sup.t = null;
            }
            if (!sup.h && !sup.s && !sup.t) hsfClrSuppressed.delete(f.gufi);
        }

        // Apply all fields including position
        for (const key in f) {
            existing[key] = f[key];
        }

        // Set initial side for altitude indicators after merge (when we have both values)
        // _altInitialSide: -1 = started below assigned (climbing), +1 = started above (descending)
        if (existing.assignedAltitude != null && existing.reportedAltitude != null) {
            const aAlt = Math.round(existing.assignedAltitude / 100);
            const rAlt = Math.round(existing.reportedAltitude / 100);
            const d = rAlt - aAlt;
            if (Math.abs(d) <= 2) {
                existing._altInitialSide = 0;  // Conforming — clear
            } else if (!existing._altInitialSide) {
                existing._altInitialSide = d < 0 ? -1 : 1;  // First non-conforming — record side
            }
        }

        // SWIM data overrides local controller entries ONLY when genuinely new
        // (stale repeats of the same value don't clear local overrides)
        if ('assignedAltitude' in f) {
            const la = localAssignedAlt.get(f.gufi);
            if (la && f.assignedAltitude !== la.serverVal) localAssignedAlt.delete(f.gufi);
        }
        if ('interimAltitude' in f) {
            const li = localInterimAlt.get(f.gufi);
            if (li && f.interimAltitude !== li.serverVal) localInterimAlt.delete(f.gufi);
        }
        if ('reportedAltitude' in f) {
            const lr = localReportedAlt.get(f.gufi);
            if (lr && f.reportedAltitude !== lr.serverVal) localReportedAlt.delete(f.gufi);
        }

        // Auto-show HSF when server clearance data first arrives
        const hasClr = existing.clearanceHeading || existing.clearanceSpeed || existing.clearanceText;
        if (hasClr && !hadClr) hsfShowMap.add(f.gufi);

        // Detect handoff completion via two paths:
        // 1) HO event cleared by server (HO-DONE) + CU matches recv
        // 2) CU changed to match recv (covers missed initiation)
        const newHoEvt = hoEventType(existing.handoffEvent);
        const cuChanged = existing.controllingFacility !== oldCuFac || existing.controllingSector !== oldCuSec;
        const recv = oldHoRecv || existing.handoffReceiving;
        if (recv && !hoCompletedInfo.has(f.gufi)) {
            const recvFac = extractFac(recv);
            const recvSec = extractSec(recv);
            const cuMatchesRecv = existing.controllingFacility === recvFac && existing.controllingSector === recvSec;
            if (cuMatchesRecv && ((!newHoEvt && oldHoEvt) || cuChanged)) {
                hoCompletedInfo.set(f.gufi, {
                    time: performance.now(),
                    receiving: recv,
                    transferring: oldHoXfer || existing.handoffTransferring || '',
                    forced: oldHoForced || existing.handoffForced || false
                });
            }
        }
    } else {
        // New flight — add fully (including position)
        f._clientLastUpdate = performance.now();
        if (f.assignedAltitude != null && f.reportedAltitude != null) {
            const aAlt = Math.round(f.assignedAltitude / 100);
            const rAlt = Math.round(f.reportedAltitude / 100);
            const d = rAlt - aAlt;
            f._altInitialSide = Math.abs(d) <= 2 ? 0 : (d < 0 ? -1 : 1);
        }
        flights.set(f.gufi, f);
    }

    // Handoff targeting our sector → immediately set FDB + rebuild marker
    if (hoEventType(f.handoffEvent)) {
        const cur = flights.get(f.gufi);
        if (cur) {
            const cls = classifyTrack(cur);
            if (cls === 'ho' && !fdbOverrides.has(f.gufi)) {
                fdbOverrides.set(f.gufi, true);
                const marker = markers.get(f.gufi);
                if (marker) {
                    const el = marker.getElement();
                    if (el) el._lastHash = '';
                }
                lastRenderTime = 0;
            }
        }
    }

    // Auto-switch QP T → QP J when aircraft climbs above FL230
    if (driActive.get(f.gufi) === 'T') {
        const alt = f.reportedAltitude ?? f.assignedAltitude;
        if (alt != null && alt > 23000) {
            driActive.set(f.gufi, 'J');
            lastRenderTime = 0;
        }
    }
}

// ════════════════════════════════════════════════════════════════════════════
// WebSocket
// ════════════════════════════════════════════════════════════════════════════
function connectWs() {
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${proto}//${location.host}/ws`);

    ws.onopen = () => {
        wsConnected = true;
        document.getElementById('connection-status').textContent = 'Connected';
        document.getElementById('connection-status').style.color = '#cccc44';
    };

    ws.onclose = () => {
        wsConnected = false;
        document.getElementById('connection-status').textContent = 'Disconnected \u2014 reconnecting...';
        document.getElementById('connection-status').style.color = '#cc4444';
        setTimeout(connectWs, 3000);
    };

    ws.onmessage = (evt) => {
        const msg = JSON.parse(evt.data);

        if (msg.type === 'snapshot') {
            // Fresh start — seed history from server (survives refresh)
            for (const [, m] of markers) map.removeLayer(m);
            markers.clear();
            flights.clear();
            flightHistory.clear();
            for (const f of msg.data) {
                // Apply clearance suppression from QS * clears (survives reconnect within session)
                const sup = hsfClrSuppressed.get(f.gufi);
                if (sup) {
                    if (sup.h && (f.clearanceHeading || null) === sup.h) f.clearanceHeading = null;
                    else if (f.clearanceHeading) sup.h = null;
                    if (sup.s && (f.clearanceSpeed || null) === sup.s) f.clearanceSpeed = null;
                    else if (f.clearanceSpeed) sup.s = null;
                    if (sup.t && (f.clearanceText || null) === sup.t) f.clearanceText = null;
                    else if (f.clearanceText) sup.t = null;
                    if (!sup.h && !sup.s && !sup.t) hsfClrSuppressed.delete(f.gufi);
                }
                f._clientLastUpdate = performance.now();
                // Initialize altitude initial side for snapshot flights
                if (f.assignedAltitude != null && f.reportedAltitude != null) {
                    const aAlt = Math.round(f.assignedAltitude / 100);
                    const rAlt = Math.round(f.reportedAltitude / 100);
                    const d = rAlt - aAlt;
                    f._altInitialSide = Math.abs(d) <= 2 ? 0 : (d < 0 ? -1 : 1);
                }
                flights.set(f.gufi, f);
                trackFacility(f);
                if (f.history && f.history.length > 0) {
                    const now = performance.now();
                    const hist = f.history.map(h => ({
                        lat: h.lat, lon: h.lon, sym: h.sym || '\\',
                        time: now - ((h.age || 0) * 1000)
                    }));
                    while (hist.length > MAX_HISTORY) hist.shift();
                    flightHistory.set(f.gufi, hist);
                }
                // Auto-show HSF for flights with server clearance data
                if (f.clearanceHeading || f.clearanceSpeed || f.clearanceText) {
                    hsfShowMap.add(f.gufi);
                }
            }
        } else if (msg.type === 'update') {
            processFlightUpdate(msg.data);
        } else if (msg.type === 'batch') {
            // Batched updates — array of flight summaries
            for (const f of msg.data) {
                processFlightUpdate(f);
            }
        } else if (msg.type === 'remove') {
            flights.delete(msg.data.gufi);
            flightHistory.delete(msg.data.gufi);
            fdbOverrides.delete(msg.data.gufi);
            wasOwnOrHo.delete(msg.data.gufi);
            manuallyHidden.delete(msg.data.gufi);
            hoCompletedInfo.delete(msg.data.gufi);
            lastVisibleAt.delete(msg.data.gufi);
            driActive.delete(msg.data.gufi);
            const m = markers.get(msg.data.gufi);
            if (m) { map.removeLayer(m); markers.delete(msg.data.gufi); }
            removeRoute(msg.data.gufi);
        } else if (msg.type === 'stats') {
            msgRate = msg.data.rate;
        }
    };
}
connectWs();

// ════════════════════════════════════════════════════════════════════════════
// Facility/sector tracking
// ════════════════════════════════════════════════════════════════════════════
function trackFacility(f) {
    const fac = f.controllingFacility || f.reportingFacility || '';
    if (!fac) return;
    const sec = f.controllingSector || '';
    if (!knownFacilities.has(fac)) knownFacilities.set(fac, new Set());
    if (sec) knownFacilities.get(fac).add(sec);
}

let _lastFacilityInDropdown = false;
function rebuildFacilityDropdown() {
    const sel = document.getElementById('sel-facility');
    const facs = [...knownFacilities.keys()].filter(f => f.startsWith('Z')).sort();
    let html = '<option value="">All</option>';
    for (const fac of facs) html += `<option value="${esc(fac)}">${esc(fac)}</option>`;
    sel.innerHTML = html;
    // Restore selection (myFacility may have been set from URL before facilities were known)
    sel.value = myFacility || '';
    // First time our facility appears in the dropdown — trigger boundary display
    if (myFacility && !_lastFacilityInDropdown && facs.includes(myFacility)) {
        _lastFacilityInDropdown = true;
        showBoundariesForFacility(myFacility);
        rebuildSectorCheckboxes();
    }
}

function rebuildSectorCheckboxes() {
    const container = document.getElementById('sector-checkboxes');
    if (!myFacility) {
        container.innerHTML = '<span style="color:#666; font-size:10px;">Select facility first</span>';
        return;
    }
    const secs = knownFacilities.has(myFacility) ? [...knownFacilities.get(myFacility)].sort() : [];
    if (secs.length === 0) {
        container.innerHTML = '<span style="color:#666; font-size:10px;">No sectors found yet</span>';
        return;
    }
    let html = '';
    for (const sec of secs) {
        const checked = mySectors.has(sec) ? ' checked' : '';
        html += `<label style="display:block; padding:1px 0; cursor:pointer; color:#aaa;">` +
            `<input type="checkbox" class="sec-chk" value="${esc(sec)}"${checked} style="accent-color:#cccc44;"> ${esc(sec)}` +
            `</label>`;
    }
    container.innerHTML = html;
    container.querySelectorAll('.sec-chk').forEach(chk => {
        chk.addEventListener('change', function () {
            if (this.checked) {
                mySectors.add(this.value);
            } else {
                mySectors.delete(this.value);
                // Deactivating a sector: revert all flights associated with that sector to LDB
                demoteSectorFlights(this.value);
            }
            invalidateAllMarkers(); // immediately update R indicators and FDB/LDB
            saveSettingsToUrl();
        });
    });
}

// When a sector is deactivated, revert all flights that were own/ho for that sector back to LDB
function demoteSectorFlights(sector) {
    for (const [gufi, f] of flights) {
        const fac = f.controllingFacility || f.reportingFacility || '';
        const sec = f.controllingSector || '';
        const hoRecvSec = extractSec(f.handoffReceiving);
        const hoXferSec = extractSec(f.handoffTransferring);
        // Flight belongs to the deactivated sector if it's controlled by it or in handoff with it
        if (fac === myFacility && sec === sector ||
            extractFac(f.handoffReceiving) === myFacility && hoRecvSec === sector ||
            extractFac(f.handoffTransferring) === myFacility && hoXferSec === sector) {
            fdbOverrides.delete(gufi);
            wasOwnOrHo.delete(gufi);
        }
    }
}

function esc(s) {
    return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ════════════════════════════════════════════════════════════════════════════
// Change detection — lightweight hash to avoid rebuilding marker HTML
// ════════════════════════════════════════════════════════════════════════════
function flightHash(f, cls) {
    const useFdb = shouldShowFdb(f.gufi, cls);
    // Flash animation is handled by the 500ms flash timer (data block text only),
    // so flashKey is NOT in the hash — prevents full marker rebuild every tick.
    // Include hoCompleted + R state so marker rebuilds when handoff completes
    const hoc = hoCompletedInfo.has(f.gufi) ? 1 : 0;
    const rInd = shouldShowR(f, cls) ? 1 : 0;
    const dbPos = dbPositions.get(f.gufi) || 0;
    const ldrLen = ldrLenOverrides.get(f.gufi) ?? 1;
    const vci = vciActive.has(f.gufi) ? 1 : 0;
    const la = localAssignedAlt.get(f.gufi);
    const li = localInterimAlt.get(f.gufi);
    const lr = localReportedAlt.get(f.gufi);
    const laH = la ? `${la.feet}${la.rules||''}${la.block||''}` : '';
    const liH = li ? `${li.feet}${li.type}` : '';
    const lrH = lr ? lr.feet : '';
    const hsf = getEffectiveHsf(f);
    const hsfH = hsf ? `${hsf.heading||''}${hsf.speed||''}${hsf.freeText||''}` : '';
    const hsfS = hsfShowMap.has(f.gufi) ? 1 : 0;
    const poAck = pointoutAcked.has(f.gufi) ? 1 : 0;
    const coast = isCoasting(f) ? 1 : 0;
    const ais = f._altInitialSide || 0;
    return `${f.latitude}|${f.longitude}|${f.callsign}|${f.reportedAltitude}|${f.assignedAltitude}|${f.interimAltitude}|${f.assignedVfr||0}|${f.blockFloor||''}|${f.blockCeiling||''}|${f.squawk}|${f.assignedSquawk||''}|${f.handoffEvent}|${f.handoffReceiving}|${f.controllingFacility}|${f.controllingSector}|${f.groundSpeed}|${f.destination}|${getCid(f)}|${cls}|${useFdb}|${useFdb ? 0 : ldbBrightness}|${hoc}|${rInd}|${dbPos}|${ldrLen}|${vci}|${laH}|${liH}|${lrH}|${line4Mode}|${f.aircraftType||''}|${hsfH}|${hsfS}|${f.clearanceHeading||''}|${f.clearanceSpeed||''}|${f.clearanceText||''}|${poAck}|${f.pointoutOriginatingUnit||''}|${f.pointoutReceivingUnit||''}|${coast}|${f.flightStatus||''}|${ais}`;
}

// ════════════════════════════════════════════════════════════════════════════
// Render loop — guaranteed to never stop via requestAnimationFrame-first
// ════════════════════════════════════════════════════════════════════════════
let lastRenderTime = 0;

// Force all markers to rebuild on next render (invalidate hashes)
function invalidateAllMarkers() {
    for (const [, m] of markers) {
        const el = m.getElement();
        if (el) el._lastHash = '';
    }
    lastRenderTime = 0; // trigger immediate render on next frame
}

function render() {
    requestAnimationFrame(render);  // ALWAYS schedule next — loop never dies

    const now = performance.now();
    if (now - lastRenderTime < RENDER_INTERVAL) return;
    lastRenderTime = now;

    try {
        doRender();
    } catch (e) {
        console.error('[Render]', e);
    }
}

function doRender() {
    // Auto-close point-out menu if the flight no longer has an indicator
    if (pointoutMenuGufi) {
        const pmf = flights.get(pointoutMenuGufi);
        if (!pmf || !getPointoutIndicator(pmf)) closePointoutMenu();
    }
    const now = performance.now();
    // Update QU route lines to follow aircraft positions
    if (activeRoutes.size > 0) updateActiveRoutes();

    const mapBounds = map.getBounds();
    const onScreenGufis = new Set();
    const counts = { own: 0, ho: 0, other: 0, emrg: 0 };

    // Deduplicate: same callsign reported by multiple ARTCCs → keep only the best GUFI.
    // Priority: (1) has position, (2) facility matches, (3) ACTIVE over DROPPED, (4) first seen.
    // During handoff the old GUFI may be DROPPED with position while the new GUFI is ACTIVE
    // but has no position yet — we prefer the one with position so the target doesn't vanish.
    bestGufiByCallsign.clear();
    if (myFacility) {
        for (const [gufi, f] of flights) {
            if (!f.callsign) continue;
            if (f.flightStatus === 'CANCELLED') continue;  // skip cancelled
            const cs = f.callsign;
            const prev = bestGufiByCallsign.get(cs);
            if (!prev) { bestGufiByCallsign.set(cs, gufi); continue; }
            const prevF = flights.get(prev);
            const prevHasPos = prevF.latitude != null && prevF.longitude != null;
            const curHasPos = f.latitude != null && f.longitude != null;
            // Strong preference: has position beats no position
            if (curHasPos && !prevHasPos) { bestGufiByCallsign.set(cs, gufi); continue; }
            if (!curHasPos && prevHasPos) continue;
            // Both have position (or neither): prefer our facility
            const prevFac = prevF.controllingFacility || prevF.reportingFacility || '';
            const curFac = f.controllingFacility || f.reportingFacility || '';
            if (curFac === myFacility && prevFac !== myFacility) {
                bestGufiByCallsign.set(cs, gufi);
            }
        }
    }

    for (const [gufi, f] of flights) {
        if (!isVisible(f)) continue;
        // Skip duplicate callsigns — only show the best GUFI per callsign
        if (isDedupHidden(gufi, f)) continue;
        // Skip manually hidden flights (middle-click cycle or QX command)
        if (manuallyHidden.has(gufi)) continue;
        lastVisibleAt.set(gufi, now);  // stamp for grace period

        const cls = classifyTrack(f);
        counts[cls]++;

        // Sticky FDB: when a track transitions from own/ho to other, keep FDB
        if (cls === 'own' || cls === 'ho') {
            wasOwnOrHo.add(gufi);
        } else if (cls === 'other' && wasOwnOrHo.has(gufi) && !fdbOverrides.has(gufi)) {
            fdbOverrides.set(gufi, true);
        }

        // Viewport culling — count all visible flights but only render on-screen ones
        if (!mapBounds.contains([f.latitude, f.longitude])) continue;

        onScreenGufis.add(gufi);
        const ll = [f.latitude, f.longitude];
        const hash = flightHash(f, cls);

        const existing = markers.get(gufi);
        if (existing) {
            existing.setLatLng(ll);
            const el = existing.getElement();
            if (el) {
                // Unhide if previously hidden (flight became visible again)
                if (el.style.display === 'none') el.style.display = '';
                // Only rebuild HTML when flight data actually changes
                if (el._lastHash !== hash) {
                    el.innerHTML = buildMarkerHtml(f, cls);
                    el._lastHash = hash;
                    // Re-apply dwell emphasis after rebuild
                    if (dwellLocked.has(gufi) || el._isHovering) applyDwell(el, gufi);
                }
            }
        } else {
            const html = buildMarkerHtml(f, cls);
            const icon = L.divIcon({ className: 'ac-group', html, iconSize: [0, 0], iconAnchor: [0, 0] });
            const m = L.marker(ll, { icon, pane: 'targets', interactive: false });
            m.addTo(map);
            const el = m.getElement();
            if (el) {
                el._lastHash = hash;
                el.style.pointerEvents = 'auto';
                el.style.cursor = 'inherit';
                el._isHovering = false;
                el._gufi = gufi;
                // Dwell emphasis — hover
                el.addEventListener('mouseenter', () => {
                    el._isHovering = true;
                    applyDwell(el, gufi);
                });
                el.addEventListener('mouseleave', () => {
                    el._isHovering = false;
                    if (!dwellLocked.has(gufi)) removeDwell(el, gufi);
                });
                // Click: VCI hit area → toggle VCI; Field A → dwell lock; MCA has text → insert target ▽; else → toggle
                el.addEventListener('click', (e) => {
                    // Target symbol priority: if click is on another target's symbol, redirect
                    const redirectGufi = findTargetUnderClick(e, gufi);
                    if (redirectGufi) {
                        if (mca.text.trim().length > 0) {
                            e.stopPropagation();
                            const rf = flights.get(redirectGufi);
                            const rflid = getFlid(rf);
                            if (rflid) mcaInsertTarget(rflid);
                        } else {
                            toggleTrackSelect(redirectGufi);
                        }
                        return;
                    }
                    // Point-out Line 0: P → open menu; A → remove indicator (CRC spec)
                    if (e.target.closest('.ac-po-line0')) {
                        const pf = flights.get(gufi);
                        if (pf) {
                            const poInfo = getPointoutIndicator(pf);
                            if (poInfo) {
                                if (poInfo.cls === 'accepted') {
                                    // Click A (originator) → remove indicator from FDB
                                    pointoutAcked.delete(pf.gufi);
                                    pf.pointoutOriginatingUnit = null;
                                    pf.pointoutReceivingUnit = null;
                                    closePointoutMenu();
                                    invalidateMarker(pf.gufi);
                                } else {
                                    // Click P (either role) → open pop-up menu
                                    openPointoutMenu(pf, poInfo, e.clientX, e.clientY);
                                }
                            }
                        }
                        return;
                    }
                    // VCI toggle: click on Column 0 hit area
                    if (e.target.closest('.ac-vci-hit')) {
                        if (vciActive.has(gufi)) vciActive.delete(gufi);
                        else vciActive.add(gufi);
                        el._lastHash = '';
                        lastRenderTime = 0;
                        return;
                    }
                    // HSF indicator toggle: click ↴ to switch line 4 between DEST/TYPE and HSF
                    if (e.target.closest('.ac-hsf-ind')) {
                        if (hsfShowMap.has(gufi)) hsfShowMap.delete(gufi);
                        else hsfShowMap.add(gufi);
                        el._lastHash = '';
                        lastRenderTime = 0;
                        return;
                    }
                    const dbEl = el.querySelector('.ac-db');
                    if (dbEl) {
                        const rect = dbEl.getBoundingClientRect();
                        // Offset Field A detection when Line 0 (point-out) is present
                        const lf = flights.get(gufi);
                        const hasL0 = lf && getPointoutIndicator(lf);
                        const fieldATop = rect.top + (hasL0 ? LINE_H : 0);
                        if (e.clientX >= rect.left && e.clientX <= rect.right &&
                            e.clientY >= fieldATop && e.clientY <= fieldATop + LINE_H) {
                            // Click on Field A → toggle dwell lock
                            if (dwellLocked.has(gufi)) {
                                dwellLocked.delete(gufi);
                                if (!el._isHovering) removeDwell(el, gufi);
                            } else {
                                dwellLocked.add(gufi);
                                applyDwell(el, gufi);
                            }
                            return;
                        }
                    }
                    // If MCA has content, left-click inserts a ▽ target placeholder
                    if (mca.text.trim().length > 0) {
                        e.stopPropagation(); // prevent map click from also firing
                        const f = flights.get(gufi);
                        const flid = getFlid(f);
                        if (flid) mcaInsertTarget(flid);
                        return;
                    }
                    // Left-click does NOT toggle FDB/LDB — use middle-click on target symbol
                });
                // Middle-click: target symbol → toggle FDB/LDB; Field A → QF; VCI → toggle; MCA content → CID Enter
                el.addEventListener('auxclick', (e) => {
                    if (e.button !== 1) return;
                    e.preventDefault();
                    // Target symbol priority: if click is on another target's symbol, redirect
                    const redirectGufi = findTargetUnderClick(e, gufi);
                    if (redirectGufi) {
                        if (mca.text.trim().length > 0) {
                            const rf = flights.get(redirectGufi);
                            const rflid = getFlid(rf);
                            if (rflid) {
                                if (mca.text[mca.text.length - 1] !== ' ') mca.text += ' ';
                                mca.text += rflid;
                                mca.cursor = mca.text.length;
                                mcaExecute();
                            }
                        } else {
                            toggleTrackSelect(redirectGufi);
                        }
                        return;
                    }
                    // Check if click is on the target symbol (within 8px of marker center)
                    const markerPos = map.latLngToContainerPoint(m.getLatLng());
                    const onTarget = Math.abs(e.clientX - markerPos.x - mapEl.getBoundingClientRect().left) <= 8
                                  && Math.abs(e.clientY - markerPos.y - mapEl.getBoundingClientRect().top) <= 8;
                    if (onTarget) {
                        // MCA has content → middle-click target = append FLID + execute (CRC spec)
                        if (mca.text.trim().length > 0) {
                            const tf = flights.get(gufi);
                            const tflid = getFlid(tf);
                            if (tflid) {
                                if (mca.text[mca.text.length - 1] !== ' ') mca.text += ' ';
                                mca.text += tflid;
                                mca.cursor = mca.text.length;
                                mcaExecute();
                            }
                        } else {
                            toggleTrackSelect(gufi);
                        }
                        return;
                    }
                    // Point-out Line 0: P → open menu; A → remove indicator (CRC spec)
                    if (e.target.closest('.ac-po-line0')) {
                        const pf = flights.get(gufi);
                        if (pf) {
                            const poInfo = getPointoutIndicator(pf);
                            if (poInfo) {
                                if (poInfo.cls === 'accepted') {
                                    // Click A (originator) → remove indicator from FDB
                                    pointoutAcked.delete(pf.gufi);
                                    pf.pointoutOriginatingUnit = null;
                                    pf.pointoutReceivingUnit = null;
                                    closePointoutMenu();
                                    invalidateMarker(pf.gufi);
                                } else {
                                    // Click P (either role) → open pop-up menu
                                    openPointoutMenu(pf, poInfo, e.clientX, e.clientY);
                                }
                            }
                        }
                        return;
                    }
                    // VCI hit area: toggle VCI
                    if (e.target.closest('.ac-vci-hit')) {
                        if (vciActive.has(gufi)) vciActive.delete(gufi);
                        else vciActive.add(gufi);
                        el._lastHash = '';
                        lastRenderTime = 0;
                        return;
                    }
                    // HSF indicator: toggle HSF display on line 4
                    if (e.target.closest('.ac-hsf-ind')) {
                        if (hsfShowMap.has(gufi)) hsfShowMap.delete(gufi);
                        else hsfShowMap.add(gufi);
                        el._lastHash = '';
                        lastRenderTime = 0;
                        return;
                    }
                    const f = flights.get(gufi);
                    if (!f) return;
                    const flid = getFlid(f);
                    // Field A (line 1): middle-click → execute QF
                    const dbEl = el.querySelector('.ac-db');
                    if (dbEl) {
                        const rect = dbEl.getBoundingClientRect();
                        // Offset Field A detection when Line 0 (point-out) is present
                        const hasL0 = f && getPointoutIndicator(f);
                        const fieldATop = rect.top + (hasL0 ? LINE_H : 0);
                        if (e.clientX >= rect.left && e.clientX <= rect.right &&
                            e.clientY >= fieldATop && e.clientY <= fieldATop + LINE_H) {
                            showFlightInRA(f);
                            return;
                        }
                    }
                    // Middle-click on data block area:
                    //   MCA has content → append FLID + execute (CID Enter)
                    if (mca.text.trim().length > 0 && flid) {
                        if (mca.text.length > 0 && mca.text[mca.text.length - 1] !== ' ') {
                            mca.text += ' ';
                        }
                        mca.text += flid;
                        mca.cursor = mca.text.length;
                        mcaExecute();
                    }
                });
            }
            markers.set(gufi, m);
        }
    }

    // Persistent markers: only REMOVE markers for flights that no longer exist (server removed).
    // All other off-screen/invisible flights just get hidden — no DOM destroy/recreate flicker.
    for (const [gufi, m] of markers) {
        if (!flights.has(gufi)) {
            map.removeLayer(m);
            markers.delete(gufi);
        } else if (!onScreenGufis.has(gufi)) {
            const el = m.getElement();
            if (el && el.style.display !== 'none') el.style.display = 'none';
        }
    }

    // Redraw canvas overlay
    drawOverlay();

    // Update counters
    document.getElementById('cnt-own').textContent = counts.own;
    document.getElementById('cnt-ho').textContent = counts.ho;
    document.getElementById('cnt-other').textContent = counts.other;
    document.getElementById('cnt-total').textContent = counts.own + counts.ho + counts.other + counts.emrg;
}

requestAnimationFrame(render);

// ── Handoff flash timer (500ms) ─────────────────────────────────────────────
// Updates DATA BLOCK TEXT for tracks in active handoff OR completed handoff (O display).
// Does NOT rebuild the entire marker — symbol and leader line stay intact.
setInterval(() => {
    // Update global flash reference — ALL tracks see the same phase
    flashTime = performance.now();

    // Cleanup expired hoCompletedInfo entries
    for (const [gufi, info] of hoCompletedInfo) {
        if (flashTime - info.time >= 60000) hoCompletedInfo.delete(gufi);
    }

    for (const [gufi, m] of markers) {
        const f = flights.get(gufi);
        if (!f) continue;

        const hasActiveHo = hoEventType(f.handoffEvent) && f.handoffReceiving;
        const hasCompletedHo = hoCompletedInfo.has(gufi);
        if (!hasActiveHo && !hasCompletedHo) continue;

        const el = m.getElement();
        if (!el) continue;
        const dbEl = el.querySelector('.ac-db');
        if (!dbEl) continue;
        const cls = classifyTrack(f);
        if (shouldShowFdb(gufi, cls)) {
            // Column 0 is inline — just regenerate full HTML (includes R, VCI)
            dbEl.innerHTML = formatFdbHtml(f, cls);
        }
    }
}, 500);

// ════════════════════════════════════════════════════════════════════════════
// Sidebar controls
// ════════════════════════════════════════════════════════════════════════════
document.getElementById('sidebar-toggle').addEventListener('click', function () {
    const sidebar = document.getElementById('sidebar');
    sidebar.classList.toggle('collapsed');
    this.innerHTML = sidebar.classList.contains('collapsed') ? '&#9654;' : '&#9664;';
});

document.getElementById('sel-facility').addEventListener('change', function () {
    myFacility = this.value;
    mySectors.clear();
    // Changing facility: revert all tracks to default LDB
    fdbOverrides.clear();
    quickLookSectors.clear();
    quickLookDests.clear();
    wasOwnOrHo.clear();
    manuallyHidden.clear();
    closePointoutMenu();
    invalidateAllMarkers();
    rebuildSectorCheckboxes();
    showBoundariesForFacility(myFacility);
    zoomToFacility(myFacility);
    saveSettingsToUrl();
});

document.getElementById('chk-facility-only').addEventListener('change', function () {
    facilityOnly = this.checked;
    invalidateAllMarkers();
    saveSettingsToUrl();
});

document.getElementById('sel-histcount').addEventListener('change', function () {
    MAX_HISTORY = parseInt(this.value);
    for (const [, hist] of flightHistory) {
        while (hist.length > MAX_HISTORY) hist.shift();
    }
    invalidateAllMarkers();
    saveSettingsToUrl();
});

document.getElementById('rng-ldb-brightness').addEventListener('input', function () {
    ldbBrightness = parseInt(this.value);
    document.getElementById('lbl-ldb-brightness').textContent = ldbBrightness;
    saveSettingsToUrl();
});

document.getElementById('sel-vector').addEventListener('change', function () {
    vectorMinutes = parseInt(this.value);
    invalidateAllMarkers();
    saveSettingsToUrl();
});

document.getElementById('sel-line4').addEventListener('change', function () {
    line4Mode = this.value;
    invalidateAllMarkers();
    saveSettingsToUrl();
});

for (const [cat, id] of Object.entries(BOUNDARY_CAT_SLIDER)) {
    const lblId = BOUNDARY_CAT_LABEL[cat];
    document.getElementById(id).addEventListener('input', function () {
        setBoundaryBrightness(cat, parseInt(this.value));
        document.getElementById(lblId).textContent = this.value;
    });
    document.getElementById(id).addEventListener('change', function () {
        setBoundaryBrightness(cat, parseInt(this.value));
        document.getElementById(lblId).textContent = this.value;
        saveSettingsToUrl();
    });
}

document.getElementById('chk-mapbg').addEventListener('change', function () {
    showMapBg = this.checked;
    if (showMapBg) tileLayer.addTo(map);
    else map.removeLayer(tileLayer);
    saveSettingsToUrl();
});

document.getElementById('chk-mca-kb').addEventListener('change', function () {
    document.getElementById('mca').classList.toggle('show-kb', this.checked);
    saveSettingsToUrl();
});

// Transp MCA: reserved for future use
// document.getElementById('chk-transp-mca').addEventListener('change', function () {
//     document.getElementById('map-container').classList.toggle('transp-mca', this.checked);
//     saveSettingsToUrl();
// });

document.getElementById('btn-fullscreen').addEventListener('click', function () {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
    } else {
        document.exitFullscreen();
    }
});

document.getElementById('sel-fontsize').addEventListener('change', function () {
    fontSize = parseInt(this.value);
    updateFontSize();
    saveSettingsToUrl();
});

document.getElementById('inp-alt-low').addEventListener('change', function () {
    altFilterLow = parseInt(this.value) || 0;
    saveSettingsToUrl();
});

document.getElementById('inp-alt-high').addEventListener('change', function () {
    altFilterHigh = parseInt(this.value) || 999;
    saveSettingsToUrl();
});

function updateFontSize() {
    CHAR_W = fontSize * 0.625;
    LINE_H = fontSize * 1.25;
    // Update data block and symbol CSS dynamically
    let styleEl = document.getElementById('dynamic-fontsize');
    if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = 'dynamic-fontsize';
        document.head.appendChild(styleEl);
    }
    styleEl.textContent = `
        .ac-db {
            font-size: ${fontSize}px !important;
            line-height: ${LINE_H}px !important;
        }
    `;
}

setInterval(() => {
    rebuildFacilityDropdown();
    rebuildSectorCheckboxes();
    document.getElementById('stat-flights').textContent = flights.size;
    document.getElementById('stat-rate').textContent = msgRate;
    // Debug metrics: flight plan coverage
    let nRoute = 0, nCallsign = 0, nType = 0, nAlt = 0, nPos = 0;
    for (const [, f] of flights) {
        if (f.route) nRoute++;
        if (f.callsign) nCallsign++;
        if (f.aircraftType) nType++;
        if (f.assignedAltitude) nAlt++;
        if (f.latitude != null && f.longitude != null) nPos++;
    }
    const t = flights.size || 1;
    document.getElementById('stat-fp').textContent =
        `FP: ${nRoute}/${t} rte ${nCallsign}/${t} cs ${nType}/${t} typ ${nAlt}/${t} alt ${nPos}/${t} pos`;
}, 5000);

// ════════════════════════════════════════════════════════════════════════════
// Click target priority: symbols win over overlapping data blocks
// ════════════════════════════════════════════════════════════════════════════
// When a click lands on a data block that overlaps another target's position symbol,
// redirect the click to the underlying target. Returns the target gufi, or null.
function findTargetUnderClick(e, currentGufi) {
    const m = markers.get(currentGufi);
    if (!m) return null;
    const mapRect = map.getContainer().getBoundingClientRect();
    const cx = e.clientX - mapRect.left;
    const cy = e.clientY - mapRect.top;
    // If click is near our own symbol center, no redirect needed
    const myPt = map.latLngToContainerPoint(m.getLatLng());
    if (Math.hypot(cx - myPt.x, cy - myPt.y) <= 10) return null;
    // Check if another target's symbol is at the click point
    for (const [gufi, om] of markers) {
        if (gufi === currentGufi || !om._icon) continue;
        const pt = map.latLngToContainerPoint(om.getLatLng());
        if (Math.abs(cx - pt.x) <= 10 && Math.abs(cy - pt.y) <= 10) return gufi;
    }
    return null;
}

// ════════════════════════════════════════════════════════════════════════════
// Flight detail panel
// ════════════════════════════════════════════════════════════════════════════
function toggleTrackSelect(gufi) {
    const f = flights.get(gufi);
    if (!f) return;
    const cls = classifyTrack(f);

    // Own/handoff/emergency tracks: default FDB, clicking does NOT toggle to LDB
    if (cls === 'own' || cls === 'ho' || cls === 'emrg') {
        mca.feedback = [
            { type: 'err', text: 'USER ACTION NOT ALLOWED ON A\nCONTROLLED FLIGHT' },
            { type: 'info', text: `FORCED DATA BLK ${f.callsign || '???'}` }
        ];
        mcaRender();
        showFlightDetail(gufi);
        return;
    }

    // Point-out active: cannot toggle to LDB — use QP command
    if (getPointoutIndicator(f)) {
        mca.feedback = [
            { type: 'err', text: 'POINT OUT ACTIVE \u2014 USE QP' },
            { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
        ];
        mcaRender();
        showFlightDetail(gufi);
        return;
    }

    // Other tracks: toggle LDB ↔ FDB (use QX to explicitly drop/hide)
    if (manuallyHidden.has(gufi)) {
        // Currently hidden (via QX) → restore to FDB
        manuallyHidden.delete(gufi);
        fdbOverrides.set(gufi, true);
    } else {
        const currentlyFdb = shouldShowFdb(gufi, cls);
        if (currentlyFdb) {
            // FDB → LDB
            fdbOverrides.delete(gufi);
            wasOwnOrHo.delete(gufi);
        } else {
            // LDB → FDB
            fdbOverrides.set(gufi, true);
        }
    }

    // Immediately rebuild the marker so the change is instant (don't wait for render cycle)
    const m = markers.get(gufi);
    if (m) {
        const el = m.getElement();
        if (el) {
            if (el.style.display === 'none') el.style.display = '';
            const newHash = flightHash(f, cls);
            el.innerHTML = buildMarkerHtml(f, cls);
            el._lastHash = newHash;
            if (dwellLocked.has(gufi) || el._isHovering) applyDwell(el, gufi);
        }
    }

    showFlightDetail(gufi);
}

function showFlightDetail(gufi) {
    selectedGufi = gufi;
    const f = flights.get(gufi);
    if (!f) return;

    document.getElementById('fd-title').textContent =
        `${f.callsign || '???'}  ${f.aircraftType || ''}`;

    const cls = classifyTrack(f);
    const heading = (f.trackVelocityX != null && f.trackVelocityY != null)
        ? `${Math.round((Math.atan2(f.trackVelocityX, f.trackVelocityY) * 180 / Math.PI + 360) % 360)}\u00b0` : '';
    const tvSpd = (f.trackVelocityX != null && f.trackVelocityY != null)
        ? `${Math.round(Math.sqrt(f.trackVelocityX ** 2 + f.trackVelocityY ** 2))} kt` : '';

    const rows = [
        ['ODP', `${f.origin || ''}\u2192${f.destination || ''}`],
        ['Track', cls === 'own' ? 'OWN' : cls === 'ho' ? 'HANDOFF' : cls === 'emrg' ? 'EMERGENCY' : 'OTHER'],
        ['Facility', `${f.controllingFacility || f.reportingFacility || ''}`],
        ['Sector', f.controllingSector || ''],
        ['Squawk', f.assignedSquawk && f.squawk !== f.assignedSquawk
            ? `${f.squawk || 'NONE'} (asgn ${f.assignedSquawk})` : f.squawk],
        ['Assigned', f.blockFloor != null && f.blockCeiling != null
            ? `FL${Math.round(f.blockFloor / 100)}B${Math.round(f.blockCeiling / 100)}`
            : f.assignedVfr
                ? (f.assignedAltitude != null ? `VFR/FL${Math.round(f.assignedAltitude / 100)}` : 'VFR')
                : f.assignedAltitude != null ? `FL${Math.round(f.assignedAltitude / 100)}` : ''],
        ['Reported', f.reportedAltitude != null ? `FL${Math.round(f.reportedAltitude / 100)}` : ''],
        ['Interim', f.interimAltitude != null ? `FL${Math.round(f.interimAltitude / 100)}` : ''],
        ['GS', f.groundSpeed != null ? `${Math.round(f.groundSpeed)} kt` : ''],
        ['Heading', heading],
        ['T/V Speed', tvSpd],
        ['Route', f.route || ''],
        ['Rules', f.flightRules || ''],
        ['STAR', f.star || ''],
        ['Coord Fix', f.coordinationFix || ''],
        ['Coord Time', f.coordinationTime || ''],
        ['ETD', f.actualDepartureTime || ''],
        ['ETA', f.eta || ''],
        ['Handoff', f.handoffEvent ? `${f.handoffEvent} ${f.handoffReceiving || ''} \u2190 ${f.handoffTransferring || ''}` : ''],
        ['HO Debug', (() => {
            const parts = [];
            const hoEvt = hoEventType(f.handoffEvent);
            if (hoEvt) parts.push(`active=${hoEvt}`);
            if (f.handoffReceiving) parts.push(`recv=${f.handoffReceiving}`);
            if (f.handoffTransferring) parts.push(`xfer=${f.handoffTransferring}`);
            if (f.handoffAccepting) parts.push(`accept=${f.handoffAccepting}`);
            const comp = hoCompletedInfo.get(f.gufi);
            if (comp) {
                const secsAgo = Math.round((performance.now() - comp.time) / 1000);
                parts.push(`completed=${secsAgo}s ago recv=${comp.receiving}`);
            }
            return parts.join(' | ');
        })()],
        ['CID', getCid(f) || (myFacility ? '' : f.computerId)],
        ['Operator', f.operator],
        ['A/C Type', f.aircraftType || ''],
        ['Reg', f.registration || ''],
        ['Wake', f.wakeCategory],
        ['Equip', f.equipmentQualifier || ''],
        ['Datalink', f.dataLinkCode],
        ['Remarks', f.remarks || ''],
        ['Last msg', f.lastMsgSource],
        ['Last seen', f.lastSeen],
    ];

    let html = '';
    for (const [label, val] of rows) {
        if (!val) continue;
        html += `<div class="fd-row"><span class="fd-label">${label}</span><span class="fd-val">${esc(String(val))}</span></div>`;
    }
    document.getElementById('fd-body').innerHTML = html;
    document.getElementById('flight-detail-section').style.display = 'block';
}

function closeFd() {
    selectedGufi = null;
    document.getElementById('flight-detail-section').style.display = 'none';
}

// ── Route line display ──
// ── QU route display system ──────────────────────────────────────────────
// Great-circle distance in nautical miles between two lat/lon points
function gcDistNm(lat1, lon1, lat2, lon2) {
    const toRad = Math.PI / 180;
    const dLat = (lat2 - lat1) * toRad;
    const dLon = (lon2 - lon1) * toRad;
    const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.sin(dLon / 2) ** 2;
    return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * 3440.065;  // Earth radius in nm
}

// Initial true bearing (degrees 0-360) from point 1 to point 2
function gcBearing(lat1, lon1, lat2, lon2) {
    const toRad = Math.PI / 180;
    const dLon = (lon2 - lon1) * toRad;
    const y = Math.sin(dLon) * Math.cos(lat2 * toRad);
    const x = Math.cos(lat1 * toRad) * Math.sin(lat2 * toRad) -
              Math.sin(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.cos(dLon);
    return (Math.atan2(y, x) / toRad + 360) % 360;
}

// Magnetic declination for CONUS (2025 epoch, bilinear interpolation)
// Returns degrees (positive = east, negative = west)
const _magVarGrid = {
    lats: [25, 30, 35, 40, 45, 50],
    lons: [-125, -115, -105, -95, -85, -75, -65],
    // Rows = lat (25→50), cols = lon (-125→-65)
    data: [
        [11, 9, 5, 1, -4, -8, -13],
        [12, 10, 6, 1, -5, -10, -15],
        [13, 11, 7, 2, -5, -11, -16],
        [14, 12, 8, 3, -6, -12, -17],
        [15, 14, 9, 3, -7, -14, -18],
        [17, 16, 11, 4, -8, -16, -20],
    ]
};
function magDeclination(lat, lon) {
    const g = _magVarGrid;
    // Clamp to grid bounds
    const clat = Math.max(g.lats[0], Math.min(g.lats[g.lats.length - 1], lat));
    const clon = Math.max(g.lons[0], Math.min(g.lons[g.lons.length - 1], lon));
    // Find grid cell
    let li = 0, lj = 0;
    for (let i = 0; i < g.lats.length - 1; i++) { if (clat >= g.lats[i]) li = i; }
    for (let j = 0; j < g.lons.length - 1; j++) { if (clon >= g.lons[j]) lj = j; }
    // Bilinear interpolation
    const tLat = (clat - g.lats[li]) / (g.lats[li + 1] - g.lats[li]);
    const tLon = (clon - g.lons[lj]) / (g.lons[lj + 1] - g.lons[lj]);
    const v00 = g.data[li][lj], v10 = g.data[li + 1][lj];
    const v01 = g.data[li][lj + 1], v11 = g.data[li + 1][lj + 1];
    return v00 * (1 - tLat) * (1 - tLon) + v10 * tLat * (1 - tLon) +
           v01 * (1 - tLat) * tLon + v11 * tLat * tLon;
}

// Resolve a location string to { lat, lon, gs, isTrack, name }
// Accepts: FLID (callsign/CID), DDMMN/DDDMMW lat/lon, or fix/navaid/airport
async function resolveLocation(loc) {
    // Try as DDMMN/DDDMMW lat/lon first
    const llMatch = loc.match(/^(\d{2,4})([NS])\/(\d{3,5})([EW])$/i);
    if (llMatch) {
        const rawLat = llMatch[1], latDir = llMatch[2].toUpperCase();
        const rawLon = llMatch[3], lonDir = llMatch[4].toUpperCase();
        let lat, lon;
        if (rawLat.length <= 2) lat = parseInt(rawLat);
        else { lat = parseInt(rawLat.substring(0, rawLat.length - 2)) + parseInt(rawLat.substring(rawLat.length - 2)) / 60; }
        if (rawLon.length <= 3) lon = parseInt(rawLon);
        else { lon = parseInt(rawLon.substring(0, rawLon.length - 2)) + parseInt(rawLon.substring(rawLon.length - 2)) / 60; }
        if (latDir === 'S') lat = -lat;
        if (lonDir === 'W') lon = -lon;
        return { lat, lon, gs: null, isTrack: false, name: loc };
    }
    // Try as track (callsign/CID)
    const f = findFlight(loc);
    if (f && f.latitude != null && f.longitude != null) {
        return { lat: f.latitude, lon: f.longitude, gs: f.groundSpeed, isTrack: true, name: f.callsign || loc };
    }
    // Try as fix/navaid/airport via NASR
    try {
        const resp = await fetch(`/api/nasr/find/${encodeURIComponent(loc)}`);
        if (resp.ok) {
            const data = await resp.json();
            return { lat: data.lat, lon: data.lon, gs: null, isTrack: false, name: data.ident };
        }
    } catch {}
    return null;
}

// Format bearing/distance/time for RA display
function formatRangeResult(dist, bearing, useMag, fromLat, fromLon, speed, name1, name2) {
    let brg = bearing;
    let brgLabel = 'T';
    if (useMag) {
        brg = (bearing - magDeclination(fromLat, fromLon) + 360) % 360;
        brgLabel = 'M';
    }
    let text = `${name1} - ${name2}\n`;
    text += `${String(Math.round(brg)).padStart(3, '0')}${brgLabel}  ${dist.toFixed(1)} NM`;
    if (speed != null && speed > 0) {
        const hours = dist / speed;
        const min = Math.round(hours * 60);
        text += `  GS${Math.round(speed)}  ${min < 60 ? min + ' MIN' : Math.floor(hours) + ':' + String(min % 60).padStart(2, '0')}`;
    }
    return text;
}

// Find closest segment on route to aircraft position, return { index, frac }
// index = segment start index, frac = 0-1 fraction along that segment
function findRouteProgress(waypoints, lat, lon, vx, vy) {
    // vx/vy = trackVelocityX/Y (knots, X=east, Y=north) — used for direction tiebreaking
    let bestDist = Infinity, bestIdx = 0, bestFrac = 0;
    const hasVel = vx != null && vy != null && (vx !== 0 || vy !== 0);

    for (let i = 0; i < waypoints.length - 1; i++) {
        const [aLat, aLon] = waypoints[i];
        const [bLat, bLon] = waypoints[i + 1];
        // Project point onto segment (flat approximation for nearby points)
        const dx = bLon - aLon, dy = bLat - aLat;
        const lenSq = dx * dx + dy * dy;
        let t = lenSq > 0 ? ((lon - aLon) * dx + (lat - aLat) * dy) / lenSq : 0;
        t = Math.max(0, Math.min(1, t));
        const pLat = aLat + t * dy, pLon = aLon + t * dx;
        let d = gcDistNm(lat, lon, pLat, pLon);
        // Direction penalty: if aircraft velocity opposes this segment direction, add penalty
        if (hasVel && lenSq > 0) {
            // Segment direction (in lon/lat space, similar to vx/vy east/north)
            const segLen = Math.sqrt(lenSq);
            const segDx = dx / segLen, segDy = dy / segLen;
            const velLen = Math.sqrt(vx * vx + vy * vy);
            const velDx = vx / velLen, velDy = vy / velLen;
            const dot = segDx * velDx + segDy * velDy;  // -1 to 1
            if (dot < 0) d += 50;  // 50nm penalty for backwards-facing segments
        }
        if (d < bestDist) { bestDist = d; bestIdx = i; bestFrac = t; }
    }
    // Also check if aircraft is closest to a waypoint directly (within forward direction)
    for (let i = 0; i < waypoints.length; i++) {
        let d = gcDistNm(lat, lon, waypoints[i][0], waypoints[i][1]);
        // For waypoint-only check, penalize waypoints that are behind the aircraft
        if (hasVel && i < waypoints.length - 1) {
            const toBearing = Math.atan2(waypoints[i][1] - lon, waypoints[i][0] - lat);
            const velBearing = Math.atan2(vx, vy);
            const angleDiff = Math.abs(((toBearing - velBearing + Math.PI * 3) % (Math.PI * 2)) - Math.PI);
            if (angleDiff > Math.PI / 2) d += 50;  // behind the aircraft
        }
        if (d < bestDist) { bestDist = d; bestIdx = Math.max(0, i - 1); bestFrac = i === 0 ? 0 : 1; }
    }
    return { index: bestIdx, frac: bestFrac };
}

// Trim route from aircraft position forward by maxNm nautical miles
// Returns { latlngs, reachedDest } — latlngs is array of [lat,lon], reachedDest is bool
function trimRouteForward(waypoints, startIdx, startFrac, maxNm) {
    if (waypoints.length < 2) return { latlngs: [], reachedDest: false };
    const result = [];
    // Interpolated start point
    const [aLat, aLon] = waypoints[startIdx];
    const [bLat, bLon] = waypoints[Math.min(startIdx + 1, waypoints.length - 1)];
    const sLat = aLat + startFrac * (bLat - aLat);
    const sLon = aLon + startFrac * (bLon - aLon);
    result.push([sLat, sLon]);

    if (maxNm === null) {
        // Full route — add all remaining waypoints
        for (let i = startIdx + 1; i < waypoints.length; i++) {
            result.push(waypoints[i]);
        }
        return { latlngs: result, reachedDest: true };
    }

    let remaining = maxNm;
    // Distance from start point to end of current segment
    const segRemain = gcDistNm(sLat, sLon, bLat, bLon);
    if (segRemain >= remaining) {
        // Trim within this segment
        const f = remaining / Math.max(segRemain, 0.001);
        result.push([sLat + f * (bLat - sLat), sLon + f * (bLon - sLon)]);
        return { latlngs: result, reachedDest: false };
    }
    remaining -= segRemain;
    result.push([bLat, bLon]);

    for (let i = startIdx + 2; i < waypoints.length; i++) {
        const segDist = gcDistNm(waypoints[i - 1][0], waypoints[i - 1][1],
            waypoints[i][0], waypoints[i][1]);
        if (segDist >= remaining) {
            const f = remaining / Math.max(segDist, 0.001);
            const pLat = waypoints[i - 1][0] + f * (waypoints[i][0] - waypoints[i - 1][0]);
            const pLon = waypoints[i - 1][1] + f * (waypoints[i][1] - waypoints[i - 1][1]);
            result.push([pLat, pLon]);
            return { latlngs: result, reachedDest: false };
        }
        remaining -= segDist;
        result.push(waypoints[i]);
    }
    return { latlngs: result, reachedDest: true };
}

// Remove a single route display by gufi
function removeRoute(gufi) {
    const r = activeRoutes.get(gufi);
    if (!r) return;
    if (r.polyline) map.removeLayer(r.polyline);
    if (r.destMarker) map.removeLayer(r.destMarker);
    activeRoutes.delete(gufi);
}

// Clear all route displays
function clearAllRoutes() {
    for (const [gufi] of activeRoutes) removeRoute(gufi);
}

// Show route line for a flight — called by QU command and dwell/detail
// minutes: number of minutes to show, null = full route, 0 = max
// persistent: if true, no 30s auto-remove (used by dwell lock / flight detail)
async function showRouteForFlight(gufi, minutes = null, persistent = false) {
    const f = flights.get(gufi);
    if (!f || !f.route) return 'NO ROUTE';

    // Fetch full route waypoints from server
    let waypoints;
    try {
        const resp = await fetch(`/api/route/${encodeURIComponent(gufi)}`);
        if (!resp.ok) return 'ROUTE RESOLVE FAILED';
        const data = await resp.json();
        waypoints = data.waypoints;
        if (!waypoints || waypoints.length < 2) return 'ROUTE NOT RESOLVED';
    } catch (e) { return 'ROUTE FETCH ERROR'; }

    // Remove existing route for this flight
    removeRoute(gufi);

    // Calculate route from aircraft's current position
    let latlngs, reachedDest;
    if (f.latitude != null && f.longitude != null && minutes !== null) {
        // Use filed speed (requestedSpeed / nasAirspeed), fall back to groundSpeed
        const speed = f.requestedSpeed || f.groundSpeed || 250;
        const mins = minutes === 0 ? 9999 : (minutes || 20);  // 0 = /M (max), default 20
        const maxNm = speed * mins / 60;
        const prog = findRouteProgress(waypoints, f.latitude, f.longitude,
            f.trackVelocityX, f.trackVelocityY);
        ({ latlngs, reachedDest } = trimRouteForward(waypoints, prog.index, prog.frac, maxNm));
        // Always start the route line from the aircraft's actual position
        if (latlngs.length > 0) {
            latlngs[0] = [f.latitude, f.longitude];
        }
    } else {
        // No position or full route requested — show entire route
        latlngs = waypoints;
        reachedDest = true;
    }

    if (latlngs.length < 2) return 'ROUTE TOO SHORT';

    const polyline = L.polyline(latlngs, {
        pane: 'routes',
        color: '#cccc44',
        weight: 2,
        opacity: 0.8,
        interactive: false
    }).addTo(map);

    // Endpoint marker: X at destination, or small solid square at truncated endpoint
    let destMarker = null;
    if (latlngs.length >= 2) {
        const last = latlngs[latlngs.length - 1];
        if (reachedDest) {
            destMarker = L.marker(last, {
                pane: 'routes',
                interactive: false,
                icon: L.divIcon({
                    className: '',
                    html: `<div style="color:#cccc44;font-family:ERAM,Consolas,monospace;font-size:${fontSize}px;text-decoration:underline;width:${fontSize}px;height:${fontSize}px;line-height:${fontSize}px;text-align:center;">X</div>`,
                    iconSize: [fontSize, fontSize],
                    iconAnchor: [fontSize / 2, fontSize / 2]
                })
            }).addTo(map);
        } else {
            const sz = Math.max(4, Math.round(fontSize * 0.4));
            destMarker = L.marker(last, {
                pane: 'routes',
                interactive: false,
                icon: L.divIcon({
                    className: '',
                    html: `<div style="width:${sz}px;height:${sz}px;background:#cccc44;"></div>`,
                    iconSize: [sz, sz],
                    iconAnchor: [sz / 2, sz / 2]
                })
            }).addTo(map);
        }
    }

    activeRoutes.set(gufi, {
        polyline,
        destMarker,
        time: persistent ? null : performance.now(),
        minutes,
        waypoints  // cached for dynamic updates
    });

    return null;  // success
}

// Update active QU routes to follow aircraft position
function updateActiveRoutes() {
    for (const [gufi, r] of activeRoutes) {
        if (!r.waypoints || r.minutes === null) continue; // full route, no trimming
        const f = flights.get(gufi);
        if (!f || f.latitude == null || f.longitude == null) continue;

        const speed = f.requestedSpeed || f.groundSpeed || 250;
        const mins = r.minutes === 0 ? 9999 : (r.minutes || 20);
        const maxNm = speed * mins / 60;
        const prog = findRouteProgress(r.waypoints, f.latitude, f.longitude,
            f.trackVelocityX, f.trackVelocityY);
        const { latlngs, reachedDest } = trimRouteForward(r.waypoints, prog.index, prog.frac, maxNm);
        if (latlngs.length > 0) latlngs[0] = [f.latitude, f.longitude];
        if (latlngs.length < 2) continue;

        r.polyline.setLatLngs(latlngs);
        // Update endpoint marker position
        if (r.destMarker) {
            r.destMarker.setLatLng(latlngs[latlngs.length - 1]);
        }
    }
}

// Auto-remove expired QU route displays (30s timeout)
setInterval(() => {
    const now = performance.now();
    for (const [gufi, r] of activeRoutes) {
        if (r.time !== null && now - r.time >= 30000) {
            removeRoute(gufi);
        }
    }
}, 1000);

setInterval(() => { if (selectedGufi) showFlightDetail(selectedGufi); }, 5000);

// ════════════════════════════════════════════════════════════════════════════
// URL-based settings persistence
// ════════════════════════════════════════════════════════════════════════════
function loadSettingsFromUrl() {
    const params = new URLSearchParams(window.location.hash.slice(1));
    myFacility = params.get('facility') || '';
    const sectors = params.get('sectors');
    mySectors = sectors ? new Set(sectors.split(',').filter(s => s)) : new Set();
    if (params.has('fdb')) showFdb = params.get('fdb') !== '0';
    if (params.has('history')) showHistory = params.get('history') !== '0';
    if (params.has('histcount')) MAX_HISTORY = parseInt(params.get('histcount')) || 5;
    if (params.has('vector')) vectorMinutes = parseInt(params.get('vector'));
    if (params.has('bndbr')) {
        const vals = params.get('bndbr').split(',').map(Number);
        BOUNDARY_CATS.forEach((cat, i) => { if (!isNaN(vals[i])) boundaryBrightness[cat] = vals[i]; });
    }
    if (params.has('fontsize')) fontSize = parseInt(params.get('fontsize')) || 10;
    if (params.has('altlow')) altFilterLow = parseInt(params.get('altlow')) || 0;
    if (params.has('althigh')) altFilterHigh = parseInt(params.get('althigh')) || 999;
    if (params.has('ldb')) ldbBrightness = parseInt(params.get('ldb'));
    if (params.has('faconly')) facilityOnly = params.get('faconly') === '1';
    if (params.has('mapbg')) showMapBg = params.get('mapbg') === '1';
    if (params.has('kb')) {
        document.getElementById('chk-mca-kb').checked = true;
        document.getElementById('mca').classList.add('show-kb');
    }
    // Transp MCA: reserved for future use
    // if (params.has('tmca')) {
    //     document.getElementById('map-container').classList.toggle('transp-mca', true);
    //     document.getElementById('chk-transp-mca').checked = true;
    // }
    if (params.has('nasrbr')) {
        const vals = params.get('nasrbr').split(',').map(Number);
        if (!isNaN(vals[0])) nasrBrightness.jroutes = vals[0];
        if (!isNaN(vals[1])) nasrBrightness.vroutes = vals[1];
        if (!isNaN(vals[2])) nasrBrightness.vors = vals[2];
        if (!isNaN(vals[3])) nasrBrightness.airports = vals[3];
        if (!isNaN(vals[4])) nasrBrightness.centerlines = vals[4];
        if (!isNaN(vals[5])) nasrBrightness.proc = vals[5];
    }
    if (params.has('line4')) line4Mode = params.get('line4') || 'DEST';
    if (params.has('nxlvl')) {
        const v = params.get('nxlvl');
        nexradLevel = v === '123' ? 3 : v === '23' ? 2 : v === '3' ? 1 : 0;
    }
    if (params.has('nxbr')) nexradBrightness = parseInt(params.get('nxbr'));

    // Restore map position/zoom
    if (params.has('lat') && params.has('lng') && params.has('z')) {
        const lat = parseFloat(params.get('lat'));
        const lng = parseFloat(params.get('lng'));
        const z = parseInt(params.get('z'));
        if (!isNaN(lat) && !isNaN(lng) && !isNaN(z)) map.setView([lat, lng], z);
    }

    // Apply to UI controls
    document.getElementById('sel-facility').value = myFacility;
    document.getElementById('sel-histcount').value = MAX_HISTORY;
    document.getElementById('sel-vector').value = vectorMinutes;
    for (const [cat, id] of Object.entries(BOUNDARY_CAT_SLIDER)) {
        document.getElementById(id).value = boundaryBrightness[cat];
        document.getElementById(BOUNDARY_CAT_LABEL[cat]).textContent = boundaryBrightness[cat];
    }
    document.getElementById('chk-facility-only').checked = facilityOnly;
    document.getElementById('chk-mapbg').checked = showMapBg;
    document.getElementById('sel-line4').value = line4Mode;
    document.getElementById('sel-fontsize').value = fontSize;
    document.getElementById('inp-alt-low').value = altFilterLow;
    document.getElementById('inp-alt-high').value = altFilterHigh;
    document.getElementById('rng-ldb-brightness').value = ldbBrightness;
    document.getElementById('lbl-ldb-brightness').textContent = ldbBrightness;
    document.getElementById('rng-jroutes').value = nasrBrightness.jroutes;
    document.getElementById('lbl-jroutes').textContent = nasrBrightness.jroutes;
    document.getElementById('rng-vroutes').value = nasrBrightness.vroutes;
    document.getElementById('lbl-vroutes').textContent = nasrBrightness.vroutes;
    document.getElementById('rng-vors').value = nasrBrightness.vors;
    document.getElementById('lbl-vors').textContent = nasrBrightness.vors;
    document.getElementById('rng-airports').value = nasrBrightness.airports;
    document.getElementById('lbl-airports').textContent = nasrBrightness.airports;
    document.getElementById('rng-centerlines').value = nasrBrightness.centerlines;
    document.getElementById('lbl-centerlines').textContent = nasrBrightness.centerlines;
    document.getElementById('rng-proc').value = nasrBrightness.proc;
    document.getElementById('lbl-proc').textContent = nasrBrightness.proc;
    document.getElementById('sel-nxlvl').value = nexradLevel === 3 ? '123' : nexradLevel === 2 ? '23' : nexradLevel === 1 ? '3' : '0';
    document.getElementById('rng-nx').value = nexradBrightness;
    document.getElementById('lbl-nx').textContent = nexradBrightness;
    updateFontSize();
    if (showMapBg) tileLayer.addTo(map);
    if (nexradLevel > 0) updateNexrad();
    // Restore NASR overlays if brightness > 0
    if (nasrBrightness.jroutes > 0) showNasrLayer('jroutes', '/api/nasr/airways?type=hi', renderAirways);
    if (nasrBrightness.vroutes > 0) showNasrLayer('vroutes', '/api/nasr/airways?type=lo', renderAirways);
    if (nasrBrightness.vors > 0) showNasrLayer('vors', '/api/nasr/navaids', renderVors);
    if (nasrBrightness.airports > 0 && !airportOverlayData) {
        fetch('/api/nasr/airports').then(r => r.ok ? r.json() : null).then(d => { if (d) { airportOverlayData = d; drawOverlay(); } });
    }
    if (nasrBrightness.centerlines > 0 && !centerlineData) {
        fetch('/api/nasr/centerlines').then(r => r.ok ? r.json() : null).then(d => { if (d) { centerlineData = d; drawOverlay(); } });
    }
    showBoundariesForFacility(myFacility);
}

function saveSettingsToUrl() {
    const params = new URLSearchParams();
    if (myFacility) params.set('facility', myFacility);
    if (mySectors.size) params.set('sectors', [...mySectors].join(','));
    if (!showFdb) params.set('fdb', '0');
    if (!showHistory) params.set('history', '0');
    if (MAX_HISTORY !== 5) params.set('histcount', MAX_HISTORY);
    if (vectorMinutes !== 0) params.set('vector', vectorMinutes);
    const brVals = BOUNDARY_CATS.map(c => boundaryBrightness[c]);
    const defaultBr = [60, 60, 60, 30];
    if (brVals.join(',') !== defaultBr.join(',')) params.set('bndbr', brVals.join(','));
    if (line4Mode !== 'DEST') params.set('line4', line4Mode);
    if (showMapBg) params.set('mapbg', '1');
    // if (document.getElementById('chk-transp-mca').checked) params.set('tmca', '1');
    if (fontSize !== 10) params.set('fontsize', fontSize);
    if (altFilterLow !== 0) params.set('altlow', altFilterLow);
    if (altFilterHigh !== 999) params.set('althigh', altFilterHigh);
    if (ldbBrightness !== 30) params.set('ldb', ldbBrightness);
    if (facilityOnly) params.set('faconly', '1');
    if (document.getElementById('chk-mca-kb').checked) params.set('kb', '1');
    const nasrVals = [nasrBrightness.jroutes, nasrBrightness.vroutes, nasrBrightness.vors, nasrBrightness.airports, nasrBrightness.centerlines, nasrBrightness.proc];
    const nasrDefaults = [0, 0, 15, 0, 0, 0];
    if (nasrVals.join(',') !== nasrDefaults.join(',')) params.set('nasrbr', nasrVals.join(','));
    if (nexradLevel !== 3) params.set('nxlvl', nexradLevel === 0 ? '0' : nexradLevel === 2 ? '23' : nexradLevel === 1 ? '3' : '123');
    if (nexradBrightness !== 30) params.set('nxbr', nexradBrightness);
    // Map position/zoom
    const center = map.getCenter();
    params.set('lat', center.lat.toFixed(4));
    params.set('lng', center.lng.toFixed(4));
    params.set('z', map.getZoom());
    const hash = params.toString();
    history.replaceState(null, '', hash ? '#' + hash : window.location.pathname);
}

// ════════════════════════════════════════════════════════════════════════════
// Right-click pan (replaces default left-click drag)
// ════════════════════════════════════════════════════════════════════════════
const mapEl = document.getElementById('map');
mapEl.addEventListener('contextmenu', e => e.preventDefault());
// Prevent middle-click auto-scroll icon on the map
mapEl.addEventListener('mousedown', e => { if (e.button === 1) e.preventDefault(); });

let _rightDragging = false;
let _rightDragStart = null;

mapEl.addEventListener('mousedown', e => {
    if (e.button === 2) {
        _rightDragging = true;
        _rightDragStart = { x: e.clientX, y: e.clientY };
        mapEl.style.cursor = 'grabbing';
        e.preventDefault();
    }
});

document.addEventListener('mousemove', e => {
    if (!_rightDragging) return;
    const dx = e.clientX - _rightDragStart.x;
    const dy = e.clientY - _rightDragStart.y;
    map.panBy([-dx, -dy], { animate: false });
    _rightDragStart = { x: e.clientX, y: e.clientY };
});

document.addEventListener('mouseup', e => {
    if (e.button === 2 && _rightDragging) {
        _rightDragging = false;
        mapEl.style.cursor = '';
    }
});

// Map click: when MCA has content, left-clicking empty map inserts a ▽ location placeholder
map.on('click', (e) => {
    if (mca.text.trim().length > 0) {
        // Format lat/lon as DDMMN/DDDMMW for ERAM-style location entry
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        const latDir = lat >= 0 ? 'N' : 'S';
        const lonDir = lon >= 0 ? 'E' : 'W';
        const absLat = Math.abs(lat);
        const absLon = Math.abs(lon);
        const latDeg = Math.floor(absLat).toString().padStart(2, '0');
        const latMin = Math.round((absLat % 1) * 60).toString().padStart(2, '0');
        const lonDeg = Math.floor(absLon).toString().padStart(3, '0');
        const lonMin = Math.round((absLon % 1) * 60).toString().padStart(2, '0');
        const locStr = `${latDeg}${latMin}${latDir}/${lonDeg}${lonMin}${lonDir}`;
        mcaInsertTarget(locStr);
    }
});

// Map middle-click: when MCA has content, insert location + execute immediately (CRC spec)
mapEl.addEventListener('auxclick', (e) => {
    if (e.button !== 1) return;
    if (mca.text.trim().length === 0) return;
    e.preventDefault();
    const pt = map.containerPointToLatLng([e.clientX - mapEl.getBoundingClientRect().left,
                                           e.clientY - mapEl.getBoundingClientRect().top]);
    const lat = pt.lat, lon = pt.lng;
    const latDir = lat >= 0 ? 'N' : 'S';
    const lonDir = lon >= 0 ? 'E' : 'W';
    const absLat = Math.abs(lat);
    const absLon = Math.abs(lon);
    const latDeg = Math.floor(absLat).toString().padStart(2, '0');
    const latMin = Math.round((absLat % 1) * 60).toString().padStart(2, '0');
    const lonDeg = Math.floor(absLon).toString().padStart(3, '0');
    const lonMin = Math.round((absLon % 1) * 60).toString().padStart(2, '0');
    const locStr = `${latDeg}${latMin}${latDir}/${lonDeg}${lonMin}${lonDir}`;
    if (mca.text[mca.text.length - 1] !== ' ') mca.text += ' ';
    mca.text += locStr;
    mca.cursor = mca.text.length;
    mcaExecute();
});

// ════════════════════════════════════════════════════════════════════════════
// MCA (Message Composition Area)
// ════════════════════════════════════════════════════════════════════════════
const mca = {
    text: '',
    cursor: 0,
    overstrike: true,   // true = overstrike (_), false = insert (|)
    feedback: [],       // array of { type: 'ok'|'err'|'info', text: string }
    lastCommand: '',
    maxChars: 120,      // max total characters in preview area
    targetFlids: [],    // FLIDs/locations for ▽ characters in preview, in insertion order
};

// Get the best FLID for a flight: CID (if facility selected) or callsign
function getFlid(f) {
    if (!f) return '';
    const cid = getCid(f);
    if (cid) return cid;
    return f.callsign || '';
}

function mcaInsertChar(ch) {
    if (mca.text.length >= mca.maxChars && !mca.overstrike) {
        mca.feedback = [{ type: 'err', text: 'MESSAGE TOO LONG' }];
        mcaRender();
        return;
    }
    if (mca.overstrike && mca.cursor < mca.text.length) {
        mca.text = mca.text.substring(0, mca.cursor) + ch + mca.text.substring(mca.cursor + 1);
    } else {
        if (mca.text.length >= mca.maxChars) {
            mca.feedback = [{ type: 'err', text: 'MESSAGE TOO LONG' }];
            mcaRender();
            return;
        }
        mca.text = mca.text.substring(0, mca.cursor) + ch + mca.text.substring(mca.cursor);
    }
    mca.cursor++;
    mcaRender();
}

// Insert a target/location ▽ into MCA, storing the FLID or location string
function mcaInsertTarget(flid) {
    // Add space separator if needed (not at start, and last char isn't space)
    if (mca.text.length > 0 && mca.cursor > 0 && mca.text[mca.cursor - 1] !== ' ') {
        mca.text = mca.text.substring(0, mca.cursor) + ' ' + mca.text.substring(mca.cursor);
        mca.cursor++;
    }
    mca.text = mca.text.substring(0, mca.cursor) + '\u25bd' + mca.text.substring(mca.cursor);
    mca.targetFlids.push(flid);
    mca.cursor++;
    mcaRender();
}

function mcaBackspace() {
    if (mca.cursor > 0) {
        const ch = mca.text[mca.cursor - 1];
        mca.text = mca.text.substring(0, mca.cursor - 1) + mca.text.substring(mca.cursor);
        mca.cursor--;
        // Remove the corresponding FLID if a ▽ was deleted
        if (ch === '\u25bd') {
            // Count how many ▼ are before (and including) this position to find the right index
            let idx = 0;
            for (let i = 0; i < mca.cursor; i++) {
                if (mca.text[i] === '\u25bd') idx++;
            }
            mca.targetFlids.splice(idx, 1);
        }
        mcaRender();
    }
}

function mcaDelete() {
    if (mca.cursor < mca.text.length) {
        const ch = mca.text[mca.cursor];
        mca.text = mca.text.substring(0, mca.cursor) + mca.text.substring(mca.cursor + 1);
        if (ch === '\u25bd') {
            let idx = 0;
            for (let i = 0; i < mca.cursor; i++) {
                if (mca.text[i] === '\u25bd') idx++;
            }
            mca.targetFlids.splice(idx, 1);
        }
        mcaRender();
    }
}

function mcaExecute() {
    // Resolve ▽ target/location placeholders to actual FLIDs or coordinates
    let resolved = mca.text;
    const flids = [...mca.targetFlids];
    let flidIdx = 0;
    resolved = resolved.replace(/\u25bd/g, () => flids[flidIdx++] || '');
    const cmd = resolved.trim();
    mca.lastCommand = mca.text;
    mca.text = '';
    mca.cursor = 0;
    mca.targetFlids = [];
    if (!cmd) { mcaRender(); return; }
    const result = processCommand(cmd);
    if (result instanceof Promise) {
        // Async command (e.g., QU) — show pending then update when done
        mca.feedback = [{ type: 'info', text: 'PROCESSING...' }];
        mcaRender();
        result.then(r => { mca.feedback = r.feedback || []; mcaRender(); });
    } else {
        mca.feedback = result.feedback || [];
        mcaRender();
    }
}

function mcaClear() {
    mca.text = '';
    mca.cursor = 0;
    mca.feedback = [];
    mca.targetFlids = [];
    mcaRender();
}

function mcaRecall() {
    mca.text = mca.lastCommand;
    mca.cursor = mca.text.length;
    mcaRender();
}

function mcaRender() {
    const previewEl = document.getElementById('mca-preview');
    const feedbackEl = document.getElementById('mca-feedback');

    // Preview: text with blinking cursor (backtick → ⵔ︎ display)
    const mcaDisp = t => esc(t).replace(/`/g, '\u2D54\uFE0E');
    const before = mcaDisp(mca.text.substring(0, mca.cursor));
    if (mca.overstrike) {
        // Overstrike: cursor replaces character at position (or shows _ at end)
        const after = mca.cursor < mca.text.length ? mcaDisp(mca.text.substring(mca.cursor + 1)) : '';
        previewEl.innerHTML = before + '<span class="mca-cursor">_</span>' + after;
    } else {
        // Insert: cursor between characters (thin bar)
        const after = mcaDisp(mca.text.substring(mca.cursor));
        previewEl.innerHTML = before + '<span class="mca-cursor">|</span>' + after;
    }

    // Feedback area
    if (mca.feedback.length === 0) {
        feedbackEl.innerHTML = '';
    } else {
        feedbackEl.innerHTML = mca.feedback.map(f => {
            if (f.type === 'ok') return '<span style="color:#44cc44;">\u2713</span> ' + esc(f.text);
            if (f.type === 'err') return '<span style="color:#cc4444;">\u2717</span> ' + esc(f.text);
            return esc(f.text);
        }).join('\n');
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Command processor
// ════════════════════════════════════════════════════════════════════════════

// Find flight by FLID: CID (facility-specific only), callsign, or squawk
function findFlight(id) {
    const needle = id.toUpperCase();
    // CID match — matches the CID shown in the FDB (getCid logic)
    // Priority: 1) own-facility + visible, 2) visible, 3) ACTIVE, 4) any
    // "Own-facility" = controllingFacility or reportingFacility matches selected.
    // This prevents recycled CIDs from matching the wrong flight after handoff.
    if (myFacility) {
        let ownFacMatch = null;   // controlled by our facility + visible
        let visibleMatch = null;  // visible but not our facility
        let activeFallback = null;
        let anyFallback = null;
        for (const [gufi, f] of flights) {
            // Match by displayed CID (same logic as getCid)
            const displayedCid = getCid(f);
            if (displayedCid && displayedCid.toUpperCase() === needle) {
                const active = !f.flightStatus || f.flightStatus === 'ACTIVE';
                const visible = active && isVisible(f) && !isDedupHidden(gufi, f);
                const ownFac = f.controllingFacility === myFacility || f.reportingFacility === myFacility;
                if (visible && ownFac && !ownFacMatch) ownFacMatch = f;
                else if (visible && !visibleMatch) visibleMatch = f;
                else if (active && !activeFallback) activeFallback = f;
                if (!anyFallback) anyFallback = f;
            }
        }
        if (ownFacMatch) return ownFacMatch;
        if (visibleMatch) return visibleMatch;
        if (activeFallback) return activeFallback;
        if (anyFallback) return anyFallback;
    } else {
        for (const f of flights.values()) {
            if (f.computerId && f.computerId.toUpperCase() === needle) return f;
        }
    }
    // Then callsign match — prefer visible
    let csFallback = null;
    for (const [gufi, f] of flights) {
        if (f.callsign?.toUpperCase() === needle) {
            if (isVisible(f) && !isDedupHidden(gufi, f)) return f;
            if (!csFallback) csFallback = f;
        }
    }
    if (csFallback) return csFallback;
    // Then squawk (beacon code) match — prefer visible, per CRC "beacon codes are FLIDs"
    let sqFallback = null;
    for (const [gufi, f] of flights) {
        if (f.squawk === needle) {
            if (isVisible(f) && !isDedupHidden(gufi, f)) return f;
            if (!sqFallback) sqFallback = f;
        }
    }
    if (sqFallback) return sqFallback;
    return null;
}

// Parse altitude string (2-3 digit FL) → feet, returns null if invalid
function parseAltitude(s) {
    if (!s || !/^\d{2,3}$/.test(s)) return null;
    return parseInt(s) * 100;
}

// Resolve multiple FLIDs (split by /) → { found: [flight...], notFound: [string...] }
function resolveFlids(flids) {
    const found = [], notFound = [];
    for (const flid of flids) {
        const f = findFlight(flid);
        if (f) found.push(f);
        else notFound.push(flid);
    }
    return { found, notFound };
}

// Check if a flight is owned by our position (own or handoff to us)
function isOwnTrack(f) {
    const cls = classifyTrack(f);
    return cls === 'own' || cls === 'ho';
}

// Standard rejection for commands requiring track ownership
function rejectNotOwned(cmdName, f) {
    return { feedback: [
        { type: 'err', text: 'REJECT - NOT YOUR TRACK' },
        { type: 'info', text: cmdName },
        { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
    ]};
}

// Invalidate a single marker's hash to force rebuild on next render
function invalidateMarker(gufi) {
    const m = markers.get(gufi);
    if (m) { const el = m.getElement(); if (el) el._lastHash = ''; }
    lastRenderTime = 0;
}

function processCommand(cmd) {
    const parts = cmd.trim().split(/\s+/);
    const verb = parts[0]?.toUpperCase();

    // <1-9>/<0-3> <FLID> — Combined position + leader length (CRC spec)
    if (/^[1-9]\/[0-3]$/.test(verb) && parts.length >= 2) {
        const pos = parseInt(verb.charAt(0));
        const level = parseInt(verb.charAt(2));
        const flid = parts.slice(1).join('').toUpperCase();
        const f = findFlight(flid);
        if (f) {
            dbPositions.set(f.gufi, pos);
            ldrLenOverrides.set(f.gufi, level);
            const m = markers.get(f.gufi);
            if (m) { const el = m.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: `OFFSET DATA BLK LDR ${level}` },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // <1-9> <FLID> — Position data block (numpad layout)
    if (/^[1-9]$/.test(verb) && parts.length >= 2) {
        const pos = parseInt(verb);
        const flid = parts.slice(1).join('').toUpperCase();
        const f = findFlight(flid);
        if (f) {
            dbPositions.set(f.gufi, pos);
            // Invalidate marker hash so it rebuilds immediately
            const m = markers.get(f.gufi);
            if (m) { const el = m.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'OFFSET DATA BLK' },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // //<FLID> or // <FLID> — Toggle VCI (Visual Communications Indicator)
    {
        let vciFlid = null;
        if (verb === '//' && parts.length >= 2) vciFlid = parts.slice(1).join('').toUpperCase();
        else if (verb.startsWith('//') && verb.length > 2) vciFlid = verb.substring(2).toUpperCase();
        if (vciFlid) {
            const f = findFlight(vciFlid);
            if (f) {
                const cls = classifyTrack(f);
                if (!shouldShowFdb(f.gufi, cls)) {
                    return { feedback: [{ type: 'err', text: 'NOT IN FDB' }] };
                }
                if (vciActive.has(f.gufi)) vciActive.delete(f.gufi);
                else vciActive.add(f.gufi);
                const m4 = markers.get(f.gufi);
                if (m4) { const el = m4.getElement(); if (el) el._lastHash = ''; }
                lastRenderTime = 0;
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: 'TOGGLE ON-FREQUENCY' },
                    { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
                ]};
            }
            return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
        }
    }

    // /<0-3> <FLID> — Set individual leader line length
    if (/^\/[0-3]$/.test(verb) && parts.length >= 2) {
        const level = parseInt(verb.charAt(1));
        const flid = parts.slice(1).join('').toUpperCase();
        const f = findFlight(flid);
        if (f) {
            ldrLenOverrides.set(f.gufi, level);
            const m3 = markers.get(f.gufi);
            if (m3) { const el = m3.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: `LDR LEN ${level}` },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // QU [minutes] [FLID...] — Route display
    // QU alone clears all route lines
    // QU <FLID> clears route for that flight
    // QU <minutes> <FLID> shows route for N minutes (default 20, /M = max)
    // Multiple FLIDs: QU 30 JBU123/429/AAL924
    if (verb === 'QU') {
        if (parts.length === 1) {
            // QU alone — clear all QU route displays
            clearAllRoutes();
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'ROUTE DISPLAY' }
            ]};
        }

        // Parse: first non-verb token might be minutes or /M, rest are FLIDs
        // Minutes: 1-99 (1-2 digit number). CID: always 3 alphanumeric chars.
        let minutes = 20;  // default
        let flidStart = 1;
        const arg1 = parts[1].toUpperCase();
        if (arg1 === '/M') {
            minutes = 0;  // 0 = max/full route
            flidStart = 2;
        } else if (/^\d{1,2}$/.test(arg1) && parts.length > 2) {
            // 1-2 digit number with more args — treat as minutes
            minutes = parseInt(arg1);
            flidStart = 2;
        }
        // 3+ char tokens (including 3-digit CIDs) treated as FLIDs

        // Remaining parts are FLIDs — may contain slashes for multiple (QU 30 JBU123/429/AAL924)
        const flidStr = parts.slice(flidStart).join(' ').toUpperCase();
        if (!flidStr) {
            // QU <minutes> with no FLID — error
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        // Split on / to get individual FLIDs
        const flids = flidStr.split('/').map(s => s.trim()).filter(s => s);

        // If single FLID with no minutes specified and arg1 is the FLID itself
        if (flidStart === 1) {
            // QU <FLID> — if flight has active route, clear it; else show default 20 min
            if (flids.length === 1) {
                const f = findFlight(flids[0]);
                if (!f) {
                    return { feedback: [
                        { type: 'err', text: 'REJECT - FLID NOT STORED' },
                        { type: 'info', text: 'REROUTE' },
                        { type: 'info', text: cmd }
                    ]};
                }
                if (activeRoutes.has(f.gufi)) {
                    removeRoute(f.gufi);
                    return { feedback: [
                        { type: 'ok', text: 'ACCEPT' },
                        { type: 'info', text: 'ROUTE DISPLAY' },
                        { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
                    ]};
                }
            }
        }

        // Show route for each FLID
        const found = [];
        const notFound = [];
        for (const flid of flids) {
            const f = findFlight(flid);
            if (f) found.push(f);
            else notFound.push(flid);
        }
        if (found.length === 0) {
            return { feedback: [
                { type: 'err', text: 'REJECT - FLID NOT STORED' },
                { type: 'info', text: 'REROUTE' },
                { type: 'info', text: cmd }
            ]};
        }

        // Async: fetch routes for all found flights
        return (async () => {
            const feedback = [{ type: 'ok', text: 'ACCEPT' }];
            for (const f of found) {
                const err = await showRouteForFlight(f.gufi, minutes, false);
                if (err) {
                    feedback.push({ type: 'err', text: `${f.callsign}: ${err}` });
                } else {
                    feedback.push({ type: 'info', text: 'ROUTE DISPLAY' });
                    feedback.push({ type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` });
                }
            }
            if (notFound.length > 0) {
                for (const nf of notFound) {
                    feedback.push({ type: 'err', text: `REJECT - FLID NOT STORED` });
                    feedback.push({ type: 'info', text: `QU ${nf}` });
                }
            }
            return { feedback };
        })();
    }

    // QF <callsign> — Query Flight plan → show in RA
    if (verb === 'QF' && parts.length >= 2) {
        const cs = parts.slice(1).join('').toUpperCase();
        const f = findFlight(cs);
        if (f) {
            showFlightInRA(f);
            return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // QD — clear Response Area
    if (verb === 'QD') {
        document.getElementById('ra-content').textContent = '';
        return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // WR R <station>        — weather request: display METAR in Response Area
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'WR') {
        if (parts.length < 3 || parts[1].toUpperCase() !== 'R') {
            return { feedback: [{ type: 'err', text: 'FORMAT: WR R <STATION>' }] };
        }
        const station = parts.slice(2).join('').toUpperCase();
        if (!station) return { feedback: [{ type: 'err', text: 'WR R REQUIRES STATION ID' }] };
        const icao = station.length === 3 ? 'K' + station : station;
        return (async () => {
            try {
                const resp = await fetch(`/api/metar/${encodeURIComponent(station)}`);
                if (resp.status === 404) {
                    return { feedback: [{ type: 'err', text: `NO METAR FOR ${icao}` }] };
                }
                if (!resp.ok) {
                    return { feedback: [{ type: 'err', text: `WX REQ FAILED (${resp.status})` }] };
                }
                const text = (await resp.text()).trim();
                if (!text) {
                    return { feedback: [{ type: 'err', text: `NO METAR FOR ${icao}` }] };
                }
                const ra = document.getElementById('ra-content');
                ra.textContent = text;
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: `METAR ${icao}` }
                ]};
            } catch {
                return { feedback: [{ type: 'err', text: 'WX REQ FAILED' }] };
            }
        })();
    }

    // ═══════════════════════════════════════════════════════════════════════
    // LA <loc1> <loc2> [/<speed>|T/<speed>|T]  — range/bearing between two locations
    // LB <fix> <loc> | LB <fix>/<speed> <track> — range/bearing from fix to location
    // LC <fix>/<time> <track>                   — speed adjustment to reach fix at time
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'LA' || verb === 'LB' || verb === 'LC') {
        const ra = document.getElementById('ra-content');
        return (async () => {
            try {
                if (verb === 'LA') {
                    // LA <loc1> <loc2> [/<speed> | T/<speed> | T]
                    if (parts.length < 3) return { feedback: [{ type: 'err', text: 'LA REQUIRES 2 LOCATIONS' }] };
                    const loc1Str = parts[1].toUpperCase();
                    const loc2Str = parts[2].toUpperCase();
                    // Optional 3rd param: /<speed>, T/<speed>, or T
                    let overrideSpeed = null, useTrueBearing = false;
                    if (parts.length >= 4) {
                        const opt = parts[3].toUpperCase();
                        if (opt === 'T') {
                            useTrueBearing = true;
                        } else if (opt.startsWith('T/')) {
                            useTrueBearing = true;
                            overrideSpeed = parseInt(opt.substring(2));
                        } else if (opt.startsWith('/')) {
                            overrideSpeed = parseInt(opt.substring(1));
                        }
                    }

                    const loc1 = await resolveLocation(loc1Str);
                    const loc2 = await resolveLocation(loc2Str);
                    if (!loc1) return { feedback: [{ type: 'err', text: `${loc1Str} NOT FOUND` }] };
                    if (!loc2) return { feedback: [{ type: 'err', text: `${loc2Str} NOT FOUND` }] };

                    const dist = gcDistNm(loc1.lat, loc1.lon, loc2.lat, loc2.lon);
                    const trueBrg = gcBearing(loc1.lat, loc1.lon, loc2.lat, loc2.lon);
                    const speed = overrideSpeed || (loc1.isTrack ? loc1.gs : null);
                    ra.textContent = formatRangeResult(dist, trueBrg, !useTrueBearing, loc1.lat, loc1.lon, speed, loc1.name, loc2.name);
                    return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
                }

                if (verb === 'LB') {
                    // LB <fix>[/<speed>] <loc|track>
                    if (parts.length < 3) return { feedback: [{ type: 'err', text: 'LB REQUIRES FIX AND LOCATION' }] };
                    let fixStr = parts[1].toUpperCase();
                    const loc2Str = parts[2].toUpperCase();
                    let overrideSpeed = null;
                    // Check for /<speed> appended to fix
                    const slashIdx = fixStr.indexOf('/');
                    if (slashIdx > 0) {
                        overrideSpeed = parseInt(fixStr.substring(slashIdx + 1));
                        fixStr = fixStr.substring(0, slashIdx);
                    }

                    const fix = await resolveLocation(fixStr);
                    const loc2 = await resolveLocation(loc2Str);
                    if (!fix) return { feedback: [{ type: 'err', text: `${fixStr} NOT FOUND` }] };
                    if (!loc2) return { feedback: [{ type: 'err', text: `${loc2Str} NOT FOUND` }] };

                    const dist = gcDistNm(fix.lat, fix.lon, loc2.lat, loc2.lon);
                    const trueBrg = gcBearing(fix.lat, fix.lon, loc2.lat, loc2.lon);
                    const speed = overrideSpeed || (loc2.isTrack ? loc2.gs : null);
                    ra.textContent = formatRangeResult(dist, trueBrg, true, fix.lat, fix.lon, speed, fix.name, loc2.name);
                    return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
                }

                if (verb === 'LC') {
                    // LC <fix>/<time> <track>
                    if (parts.length < 3) return { feedback: [{ type: 'err', text: 'LC REQUIRES FIX/TIME AND TRACK' }] };
                    let fixStr = parts[1].toUpperCase();
                    const trackStr = parts[2].toUpperCase();
                    const slashIdx = fixStr.indexOf('/');
                    if (slashIdx <= 0) return { feedback: [{ type: 'err', text: 'FORMAT: LC <FIX>/<TIME> <TRACK>' }] };
                    const timeStr = fixStr.substring(slashIdx + 1);
                    fixStr = fixStr.substring(0, slashIdx);
                    // Parse time as HHMM zulu
                    if (!/^\d{4}$/.test(timeStr)) return { feedback: [{ type: 'err', text: `INVALID TIME ${timeStr}` }] };
                    const tgtHours = parseInt(timeStr.substring(0, 2));
                    const tgtMinutes = parseInt(timeStr.substring(2, 4));

                    const fix = await resolveLocation(fixStr);
                    const track = await resolveLocation(trackStr);
                    if (!fix) return { feedback: [{ type: 'err', text: `${fixStr} NOT FOUND` }] };
                    if (!track || !track.isTrack) return { feedback: [{ type: 'err', text: `${trackStr} NOT A TRACK` }] };

                    const dist = gcDistNm(track.lat, track.lon, fix.lat, fix.lon);
                    const trueBrg = gcBearing(track.lat, track.lon, fix.lat, fix.lon);
                    // Time until target time
                    const now = new Date();
                    const nowMin = now.getUTCHours() * 60 + now.getUTCMinutes();
                    let tgtMin = tgtHours * 60 + tgtMinutes;
                    if (tgtMin <= nowMin) tgtMin += 1440; // next day
                    const minutesLeft = tgtMin - nowMin;
                    if (minutesLeft <= 0) return { feedback: [{ type: 'err', text: 'TIME ALREADY PASSED' }] };
                    const reqSpeed = Math.round(dist / (minutesLeft / 60));
                    const magBrg = (trueBrg - magDeclination(track.lat, track.lon) + 360) % 360;
                    let text = `${track.name} - ${fix.name}\n`;
                    text += `${String(Math.round(magBrg)).padStart(3, '0')}M  ${dist.toFixed(1)} NM\n`;
                    text += `REQ SPD ${reqSpeed} KT  AT ${timeStr}Z (${minutesLeft} MIN)`;
                    if (track.gs != null) text += `\nCUR GS${Math.round(track.gs)}  ADJ ${reqSpeed - Math.round(track.gs) >= 0 ? '+' : ''}${reqSpeed - Math.round(track.gs)}`;
                    ra.textContent = text;
                    return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
                }
            } catch {
                return { feedback: [{ type: 'err', text: 'RANGE CALC FAILED' }] };
            }
        })();
    }

    // QL [sector/dest ...] — Quick Look: force FDB on specific sectors or destinations; QL alone clears all
    // Sectors are numeric-only (e.g. 32, 05); destinations contain letters (e.g. KCLT, DCA)
    if (verb === 'QL') {
        const args = parts.slice(1).map(s => s.toUpperCase());
        quickLookSectors.clear();
        quickLookDests.clear();
        for (const a of args) {
            if (/^\d+$/.test(a)) {
                quickLookSectors.add(a);
            } else {
                // SFDPS stores ICAO (KDCA); accept both KDCA and DCA
                quickLookDests.add(a);
                if (a.length === 3) quickLookDests.add('K' + a);
            }
        }
        invalidateAllMarkers();
        lastRenderTime = 0;
        const feedback = [
            { type: 'ok', text: 'ACCEPT' },
            { type: 'info', text: 'QUICK LOOK' },
        ];
        if (args.length > 0) feedback.push({ type: 'info', text: args.join(' ') });
        return { feedback };
    }

    // QP J <FLID>          — toggle standard DRI (5nm halo)
    // QP T <FLID>          — toggle reduced DRI (3nm halo)
    // QP A [sector] <FLID> — acknowledge a pending point out (P→A)
    // QP <FLID>            — clear point-out + FDB→LDB
    if (verb === 'QP') {
        if (parts.length < 2) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }
        const sub = parts[1].toUpperCase();

        // DRI: QP J / QP T
        if ((sub === 'J' || sub === 'T') && parts.length >= 3) {
            const flid = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flid);
            if (f) {
                const cid = getCid(f) || '???';
                if (sub === 'T') {
                    const alt = f.reportedAltitude ?? f.assignedAltitude;
                    if (alt != null && alt > 23000) {
                        return { feedback: [
                            { type: 'err', text: `REJECT - ${cid} NOT ELIGIBLE` },
                            { type: 'err', text: 'FOR REDUCED SEPARATION' },
                            { type: 'info', text: `REQ/DELETE DRI ${f.callsign}` }
                        ]};
                    }
                }
                const existing = driActive.get(f.gufi);
                if (existing === sub) {
                    driActive.delete(f.gufi);
                } else {
                    driActive.set(f.gufi, sub);
                }
                lastRenderTime = 0;
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: 'REQ/DELETE DRI' },
                    { type: 'info', text: `${f.callsign}/${cid}` }
                ]};
            }
            return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
        }

        // Point-out acknowledge: QP A [sector] <FLID>
        if (sub === 'A' && parts.length >= 3) {
            const flidStr = parts[parts.length - 1].toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            const poInfo = getPointoutIndicator(f);
            if (!poInfo) {
                return { feedback: [{ type: 'err', text: 'NO POINT OUT' }] };
            }
            if (poInfo.role === 'receiver') {
                f.pointoutOriginatingUnit = null;
                f.pointoutReceivingUnit = null;
                pointoutAcked.delete(f.gufi);
            } else {
                pointoutAcked.add(f.gufi);
            }
            closePointoutMenu();
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT \u2014 ACKNOWLEDGE PO' },
                { type: 'info', text: f.callsign || '???' }
            ]};
        }

        // Clear point-out + FDB→LDB: QP <FLID>
        {
            const flidStr = parts.slice(1).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            pointoutAcked.delete(f.gufi);
            f.pointoutOriginatingUnit = null;
            f.pointoutReceivingUnit = null;
            pointoutFirstSeen.delete(f.gufi);
            closePointoutMenu();
            const cls = classifyTrack(f);
            if (cls !== 'own' && cls !== 'ho' && cls !== 'emrg') {
                fdbOverrides.set(f.gufi, false);
            }
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: `PO CLR ${f.callsign || '???'}` }
            ]};
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QZ <altitude> <FLID> — Set assigned (flight plan) altitude
    // QZ VFR <FLID> | QZ VFR/<alt> <FLID> | QZ OTP <FLID>
    // QZ <floor>B<ceiling> <FLID> — Block altitude
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QZ') {
        if (parts.length < 2) {
            return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
        }

        const arg1 = parts[1].toUpperCase();

        // QZ VFR <FLID> or QZ VFR/<alt> <FLID> or QZ OTP <FLID>
        if (arg1 === 'VFR' || arg1.startsWith('VFR/') || arg1 === 'OTP') {
            let rules, altFeet = null;
            if (arg1 === 'OTP') {
                rules = 'OTP';
            } else if (arg1.startsWith('VFR/')) {
                rules = 'VFR';
                const altStr = arg1.substring(4);
                altFeet = parseAltitude(altStr);
                if (altFeet == null) return { feedback: [{ type: 'err', text: 'INVALID ALTITUDE' }] };
            } else {
                rules = 'VFR';
            }
            const flidStr = parts.slice(2).join('').toUpperCase();
            if (!flidStr) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('ASSIGNED ALT', f);
            localAssignedAlt.set(f.gufi, { feet: altFeet, rules, block: null, serverVal: f.assignedAltitude ?? null });
            invalidateMarker(f.gufi);
            const altDisp = altFeet != null ? '/' + String(Math.round(altFeet / 100)).padStart(3, '0') : '';
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'ASSIGNED ALT' },
                { type: 'info', text: `${f.callsign || '???'}/${rules}${altDisp}` }
            ]};
        }

        // QZ <floor>B<ceiling> <FLID> — Block altitude
        const blockMatch = arg1.match(/^(\d{2,3})B(\d{2,3})$/);
        if (blockMatch) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            if (!flidStr) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('ASSIGNED ALT', f);
            const floor = parseInt(blockMatch[1]) * 100;
            const ceil = parseInt(blockMatch[2]) * 100;
            const blockDisp = blockMatch[1].padStart(3, '0') + 'B' + blockMatch[2].padStart(3, '0');
            localAssignedAlt.set(f.gufi, { feet: floor, rules: null, block: blockDisp, serverVal: f.assignedAltitude ?? null });
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'ASSIGNED ALT' },
                { type: 'info', text: `${f.callsign || '???'}/${blockDisp}` }
            ]};
        }

        // QZ <altitude> <FLID> — Normal assigned altitude
        const altFeet = parseAltitude(arg1);
        if (altFeet != null) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            if (!flidStr) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('ASSIGNED ALT', f);
            localAssignedAlt.set(f.gufi, { feet: altFeet, rules: null, block: null, serverVal: f.assignedAltitude ?? null });
            invalidateMarker(f.gufi);
            const altDisp = String(Math.round(altFeet / 100)).padStart(3, '0');
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'ASSIGNED ALT' },
                { type: 'info', text: `${f.callsign || '???'}/${altDisp}` }
            ]};
        }

        // QZ <FLID> with no altitude — error
        return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QQ <altitude> <FLID...> — Set interim altitude
    // QQ R<alt> <FLID> — Set interim + reported altitude
    // QQ L<alt> <FLID> — Set local interim altitude
    // QQ P<alt> <FLID> — Set procedure altitude
    // QQ <FLID> — Clear interim/procedure altitude
    // QQ L <FLID> — Clear local interim altitude
    // Multiple FLIDs: QQ 110 JBU123/429/AAL924
    // Override: QQ /TT P150 JBU123
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QQ') {
        if (parts.length < 2) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        // Check for /TT override prefix (skip logic checks)
        let argStart = 1;
        if (parts[1].toUpperCase() === '/TT' || parts[1] === '///') {
            argStart = 2;
            if (parts.length < 3) return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        const qqArg1 = parts[argStart].toUpperCase();

        // QQ L <FLID> — Clear local interim altitude (L followed by space then FLID)
        if (qqArg1 === 'L' && parts.length > argStart + 1) {
            const qqFlids = parts.slice(argStart + 1).join('').toUpperCase().split('/').filter(s => s);
            const qqRes = resolveFlids(qqFlids);
            if (qqRes.found.length === 0) {
                return { feedback: [
                    { type: 'err', text: 'REJECT - CID NOT STORED' },
                    { type: 'info', text: 'INTERIM ALT' },
                    { type: 'info', text: `QQ ${parts.slice(1).join(' ')}` }
                ]};
            }
            const qqFb = [{ type: 'ok', text: 'ACCEPT' }, { type: 'info', text: 'INTERIM ALT' }];
            for (const f of qqRes.found) {
                const li = localInterimAlt.get(f.gufi);
                if (li && li.type === 'L') {
                    localInterimAlt.delete(f.gufi);
                    invalidateMarker(f.gufi);
                    qqFb.push({ type: 'info', text: `${f.callsign || '???'}/CLR` });
                } else {
                    qqFb.push({ type: 'err', text: 'REJECT - NO INTERIM ALTITUDE' });
                    qqFb.push({ type: 'info', text: `QQ ${getCid(f) || f.callsign || '???'}` });
                }
            }
            return { feedback: qqFb };
        }

        // Parse altitude prefix: R, L, P, or plain
        let qqAltPrefix = '';
        let qqAltArg = qqArg1;
        if (/^[RLP]\d/.test(qqArg1)) {
            qqAltPrefix = qqArg1.charAt(0);
            qqAltArg = qqArg1.substring(1);
        }

        const qqAltFeet = parseAltitude(qqAltArg);
        const qqFlidAfter = parts.slice(argStart + 1).join('').toUpperCase();

        // QQ [R|L|P]<altitude> <FLID...> — Set interim/procedure/local altitude
        if (qqAltFeet != null && qqFlidAfter) {
            const qqFlids = qqFlidAfter.split('/').filter(s => s);
            const qqRes = resolveFlids(qqFlids);
            if (qqRes.found.length === 0) {
                return { feedback: [
                    { type: 'err', text: 'REJECT - CID NOT STORED' },
                    { type: 'info', text: 'INTERIM ALT' },
                    { type: 'info', text: `QQ ${parts.slice(1).join(' ')}` }
                ]};
            }
            const qqAltDisp = String(Math.round(qqAltFeet / 100)).padStart(3, '0');
            const qqFb = [];
            let qqAnyOk = false;
            for (const f of qqRes.found) {
                // Ownership check: QQ L (local interim) exempt; all others require ownership
                if (qqAltPrefix !== 'L' && !isOwnTrack(f)) {
                    qqFb.push({ type: 'err', text: 'REJECT - NOT YOUR TRACK' });
                    qqFb.push({ type: 'info', text: `INTERIM ALT ${f.callsign || '???'}` });
                    continue;
                }
                const itype = qqAltPrefix === 'P' ? 'P' : qqAltPrefix === 'L' ? 'L' : 'I';
                localInterimAlt.set(f.gufi, { feet: qqAltFeet, type: itype, serverVal: f.interimAltitude ?? null });
                if (qqAltPrefix === 'R') localReportedAlt.set(f.gufi, { feet: qqAltFeet, serverVal: f.reportedAltitude ?? null });
                invalidateMarker(f.gufi);
                qqFb.push({ type: 'info', text: `${f.callsign || '???'}/${qqAltDisp}` });
                qqAnyOk = true;
            }
            if (qqAnyOk) qqFb.unshift({ type: 'ok', text: 'ACCEPT' }, { type: 'info', text: 'INTERIM ALT' });
            for (const nf of qqRes.notFound) {
                qqFb.push({ type: 'err', text: 'REJECT - CID NOT STORED' });
                qqFb.push({ type: 'info', text: `QQ ${nf}` });
            }
            return { feedback: qqFb };
        }

        // QQ P<alt> or QQ R<alt> with no FLID — error (prefixed altitudes require a FLID)
        if (qqAltFeet != null && qqAltPrefix) {
            return { feedback: [
                { type: 'err', text: 'REJECT - CID NOT STORED' },
                { type: 'info', text: 'INTERIM ALT' },
                { type: 'info', text: `QQ ${parts.slice(1).join(' ')}` }
            ]};
        }

        // QQ <FLID> — Clear interim/procedure altitude
        // (includes bare numbers like QQ 046 where 046 is a CID, not an altitude)
        const qqClearStr = parts.slice(argStart).join('').toUpperCase();
        const qqClearFlids = qqClearStr.split('/').filter(s => s);
        const qqClearRes = resolveFlids(qqClearFlids);
        if (qqClearRes.found.length === 0) {
            return { feedback: [
                { type: 'err', text: 'REJECT - CID NOT STORED' },
                { type: 'info', text: 'INTERIM ALT' },
                { type: 'info', text: `QQ ${parts.slice(1).join(' ')}` }
            ]};
        }
        const qqClearFb = [];
        let qqClearAnyOk = false;
        for (const f of qqClearRes.found) {
            if (!isOwnTrack(f)) {
                qqClearFb.push({ type: 'err', text: 'REJECT - NOT YOUR TRACK' });
                qqClearFb.push({ type: 'info', text: `INTERIM ALT ${f.callsign || '???'}` });
                continue;
            }
            const li = localInterimAlt.get(f.gufi);
            const hasSwimInterim = f.interimAltitude != null;
            if (li || hasSwimInterim) {
                // Set null sentinel to suppress stale server interim (local wins = null = no interim)
                // Auto-clear will remove this when server sends genuinely new data
                if (hasSwimInterim) {
                    localInterimAlt.set(f.gufi, { feet: null, type: null, serverVal: f.interimAltitude });
                } else {
                    localInterimAlt.delete(f.gufi);
                }
                invalidateMarker(f.gufi);
                qqClearFb.push({ type: 'info', text: `${f.callsign || '???'}/CLR` });
                qqClearAnyOk = true;
            } else {
                qqClearFb.push({ type: 'err', text: 'REJECT - NO INTERIM ALTITUDE' });
                qqClearFb.push({ type: 'info', text: 'INTERIM ALT' });
                qqClearFb.push({ type: 'info', text: `QQ ${getCid(f) || f.callsign || '???'}` });
            }
        }
        if (qqClearAnyOk) qqClearFb.unshift({ type: 'ok', text: 'ACCEPT' }, { type: 'info', text: 'INTERIM ALT' });
        return { feedback: qqClearFb };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QR <altitude> <FLID> — Set controller-entered reported altitude (CERA)
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QR') {
        if (parts.length < 3) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }
        const altFeet = parseAltitude(parts[1].toUpperCase());
        if (altFeet == null) {
            return { feedback: [{ type: 'err', text: 'INVALID ALTITUDE' }] };
        }
        const flidStr = parts.slice(2).join('').toUpperCase();
        const f = findFlight(flidStr);
        if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
        if (!isOwnTrack(f)) return rejectNotOwned('REPORTED ALT', f);
        localReportedAlt.set(f.gufi, { feet: altFeet, serverVal: f.reportedAltitude ?? null });
        invalidateMarker(f.gufi);
        const altDisp = String(Math.round(altFeet / 100)).padStart(3, '0');
        return { feedback: [
            { type: 'ok', text: 'ACCEPT' },
            { type: 'info', text: 'REPORTED ALT' },
            { type: 'info', text: `${f.callsign || '???'}/${altDisp}` }
        ]};
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QS — Heading/Speed/Free text (HSF) data
    // QS `<text> <FLID>   — set free text (backtick = ⵔ clear weather symbol)
    // QS <heading> <FLID>  — set heading (3-digit, 001-360)
    // QS /<speed> <FLID>   — set speed
    // QS */ <FLID>         — delete heading
    // QS /* <FLID>         — delete speed
    // QS * <FLID>          — delete all HSF
    // QS <FLID>            — toggle HSF display on line 4
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QS') {
        if (parts.length < 2) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        const qsArg1 = parts[1];
        const qsArg1Up = qsArg1.toUpperCase();

        // QS * <FLID> — delete all HSF
        if (qsArg1 === '*' && parts.length >= 3) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            hsfData.delete(f.gufi);
            hsfShowMap.delete(f.gufi);
            // Suppress server clearance data — record what we're hiding so incoming
            // updates with the SAME values don't re-apply. New/different values will show.
            hsfClrSuppressed.set(f.gufi, {
                h: f.clearanceHeading || null, s: f.clearanceSpeed || null, t: f.clearanceText || null
            });
            f.clearanceHeading = null;
            f.clearanceSpeed = null;
            f.clearanceText = null;
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'CLR ALL HSF' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS */ <FLID> — delete heading
        if (qsArg1 === '*/' && parts.length >= 3) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            const hsf = hsfData.get(f.gufi);
            if (hsf) { hsf.heading = null; if (!hsf.speed && !hsf.freeText) { hsfData.delete(f.gufi); hsfShowMap.delete(f.gufi); } }
            const sup = hsfClrSuppressed.get(f.gufi) || { h: null, s: null, t: null };
            sup.h = f.clearanceHeading || null;
            hsfClrSuppressed.set(f.gufi, sup);
            f.clearanceHeading = null;
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'CLR HEADING' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS /* <FLID> — delete speed
        if (qsArg1 === '/*' && parts.length >= 3) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            const hsf = hsfData.get(f.gufi);
            if (hsf) { hsf.speed = null; if (!hsf.heading && !hsf.freeText) { hsfData.delete(f.gufi); hsfShowMap.delete(f.gufi); } }
            const sup2 = hsfClrSuppressed.get(f.gufi) || { h: null, s: null, t: null };
            sup2.s = f.clearanceSpeed || null;
            hsfClrSuppressed.set(f.gufi, sup2);
            f.clearanceSpeed = null;
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'CLR SPEED' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS `<text> <FLID> — set free text (backtick prefix)
        if (qsArg1.startsWith('`') && parts.length >= 3) {
            const text = qsArg1.substring(1) + (parts.length > 3 ? ' ' + parts.slice(2, -1).join(' ') : '');
            const flidStr = parts[parts.length - 1].toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            const hsf = hsfData.get(f.gufi) || {};
            hsf.freeText = text.toUpperCase();
            hsf.heading = null;
            hsf.speed = null;
            hsfData.set(f.gufi, hsf);
            hsfShowMap.add(f.gufi);
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'FDB DATA' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS /<speed> <FLID> — set speed (/ prefix required)
        // Speed formats: /S<knots>, /M<mach>, /M<mach>+, /M<mach>-, /<knots>+, /<knots>-
        if (qsArg1.startsWith('/') && qsArg1.length > 1 && parts.length >= 3) {
            const spdVal = qsArg1.substring(1).toUpperCase();
            let qsSpeed = null;
            // S<knots>
            const sMatch = /^S(\d{1,4})$/i.exec(spdVal);
            if (sMatch) qsSpeed = 'S' + sMatch[1];
            // M<digits>[+/-]
            if (!qsSpeed) {
                const mMatch = /^M(\d{1,3})([+-]?)$/i.exec(spdVal);
                if (mMatch) qsSpeed = 'M' + mMatch[1] + mMatch[2];
            }
            // <digits>+/-
            if (!qsSpeed) {
                const kMatch = /^(\d{1,4})([+-])$/.exec(spdVal);
                if (kMatch) qsSpeed = kMatch[1] + kMatch[2];
            }
            if (!qsSpeed) return { feedback: [{ type: 'err', text: 'INVALID SPEED FORMAT' }] };
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            const hsf = hsfData.get(f.gufi) || { heading: null, speed: null, freeText: null };
            hsf.speed = qsSpeed;
            hsf.freeText = null;
            hsfData.set(f.gufi, hsf);
            hsfShowMap.add(f.gufi);
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'FDB DATA' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS <heading> <FLID> — set heading
        // Heading formats: H<degrees 001-360>, <degrees>L, <degrees>R (deviation)
        if (parts.length >= 3) {
            const val = qsArg1Up;
            let qsHeading = null;
            // H<degrees>
            const hMatch = /^H(\d{1,3})$/i.exec(val);
            if (hMatch) {
                const deg = parseInt(hMatch[1]);
                if (deg >= 1 && deg <= 360) qsHeading = 'H' + String(deg).padStart(3, '0');
            }
            // Heading deviation: <digits>L or <digits>R
            if (!qsHeading) {
                const devMatch = /^(\d{1,3})([LR])$/i.exec(val);
                if (devMatch) {
                    const deg = parseInt(devMatch[1]);
                    if (deg >= 1 && deg <= 180) qsHeading = String(deg) + devMatch[2].toUpperCase();
                }
            }
            if (qsHeading) {
                const flidStr = parts.slice(2).join('').toUpperCase();
                const f = findFlight(flidStr);
                if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
                if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
                const hsf = hsfData.get(f.gufi) || { heading: null, speed: null, freeText: null };
                hsf.heading = qsHeading;
                hsf.freeText = null;
                hsfData.set(f.gufi, hsf);
                hsfShowMap.add(f.gufi);
                invalidateMarker(f.gufi);
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: 'FDB DATA' },
                    { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
                ]};
            }
            // Invalid heading format if it looks like a heading attempt
            if (/^H/i.test(val) || /\d[LR]$/i.test(val)) {
                return { feedback: [{ type: 'err', text: 'INVALID HEADING FORMAT' }] };
            }
        }

        // QS <FLID> — toggle HSF display (single argument, not a heading)
        {
            const flidStr = parts.slice(1).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (f) {
                if (hsfShowMap.has(f.gufi)) hsfShowMap.delete(f.gufi);
                else hsfShowMap.add(f.gufi);
                invalidateMarker(f.gufi);
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: hsfShowMap.has(f.gufi) ? 'SHOW HSF' : 'HIDE HSF' },
                    { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
                ]};
            }
        }

        return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
    }

    // (QP handler consolidated above with DRI + point-out + clear)

    // ═══════════════════════════════════════════════════════════════════════
    // QX <FLID>            — drop a track from display (instant timeout)
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QX') {
        if (parts.length < 2) return { feedback: [{ type: 'err', text: 'QX REQUIRES FLID' }] };
        const flid = parts.slice(1).join('').toUpperCase();
        const f = findFlight(flid);
        if (!f) return { feedback: [{ type: 'err', text: `${flid} NOT FOUND` }] };
        manuallyHidden.add(f.gufi);
        wasOwnOrHo.delete(f.gufi);
        fdbOverrides.delete(f.gufi);
        const m = markers.get(f.gufi);
        if (m) { const el = m.getElement(); if (el) el.style.display = 'none'; }
        return { feedback: [
            { type: 'ok', text: 'ACCEPT' },
            { type: 'info', text: `DROP ${f.callsign || '???'}` }
        ]};
    }

    // .FIND <ident> — highlight a fix/navaid/airport on the scope
    if ((verb === '.FIND' || verb === '.F') && parts.length >= 2) {
        const ident = parts.slice(1).join('').toUpperCase();
        return (async () => {
            try {
                const resp = await fetch(`/api/nasr/find/${encodeURIComponent(ident)}`);
                if (!resp.ok) {
                    return { feedback: [{ type: 'err', text: `${ident} NOT FOUND` }] };
                }
                const data = await resp.json();
                setFindMarker(data.ident, data.lat, data.lon);
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: `FIND ${data.ident}` }
                ]};
            } catch {
                return { feedback: [{ type: 'err', text: 'NASR DATA UNAVAILABLE' }] };
            }
        })();
    }

    // .SID/.STAR/.PROC — toggle procedure overlays on the map
    if (verb === '.SID' || verb === '.STAR' || verb === '.PROC') {
        const apiType = verb === '.SID' ? 'DP' : verb === '.STAR' ? 'STAR' : '';
        const displayType = verb === '.SID' ? 'SID' : verb === '.STAR' ? 'STAR' : 'PROC';
        const args = parts.slice(1).map(a => a.toUpperCase());

        // No args: show active procedures in Response Area
        if (args.length === 0) {
            const relevant = [...activeProcedures.entries()]
                .filter(([k]) => displayType === 'PROC' || k.startsWith(displayType + ':'));
            if (relevant.length === 0) return { feedback: [{ type: 'info', text: `NO ACTIVE ${displayType}` }] };
            const ra = document.getElementById('ra-content');
            let text = `ACTIVE ${displayType}\n`;
            for (const [k, v] of relevant) {
                const names = v.procs.map(p => `${p.airport}/${p.id}`).join(' ');
                text += `${k}: ${names}\n`;
            }
            ra.textContent = text.trimEnd();
            return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
        }

        // Ensure PROC slider brightness > 0
        if (nasrBrightness.proc <= 0) {
            nasrBrightness.proc = 60;
            document.getElementById('rng-proc').value = 60;
            document.getElementById('lbl-proc').textContent = 60;
        }

        return (async () => {
            const feedback = [];
            for (const arg of args) {
                const key = `${displayType}:${arg}`;
                // Toggle: if already active, remove
                if (activeProcedures.has(key)) {
                    const entry = activeProcedures.get(key);
                    if (map.hasLayer(entry.layer)) map.removeLayer(entry.layer);
                    activeProcedures.delete(key);
                    feedback.push({ type: 'info', text: `${key} REMOVED` });
                    continue;
                }
                // Fetch from server
                try {
                    const typeParam = apiType ? `&type=${apiType}` : '';
                    const resp = await fetch(`/api/nasr/procgeo?q=${encodeURIComponent(arg)}${typeParam}`);
                    if (!resp.ok) { feedback.push({ type: 'err', text: `${arg} NOT FOUND` }); continue; }
                    const data = await resp.json();
                    if (!data || data.length === 0) { feedback.push({ type: 'err', text: `${arg} NOT FOUND` }); continue; }
                    const group = L.layerGroup();
                    renderProcedureLegs(data, group, nasrBrightness.proc);
                    group.addTo(map);
                    activeProcedures.set(key, { layer: group, procs: data, query: arg });
                    const names = data.map(p => `${p.airport}/${p.id}`).join(' ');
                    feedback.push({ type: 'info', text: `${key}: ${names}` });
                } catch {
                    feedback.push({ type: 'err', text: 'NASR DATA UNAVAILABLE' });
                }
            }
            if (feedback.length === 0) return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
            return { feedback: [{ type: 'ok', text: 'ACCEPT' }, ...feedback] };
        })();
    }

    // .NOPROC — clear all procedure overlays
    if (verb === '.NOPROC') {
        clearProcOverlay();
        return { feedback: [{ type: 'ok', text: 'ACCEPT' }, { type: 'info', text: 'CLEAR PROCEDURES' }] };
    }

    // <FLID> — toggle FDB/LDB (single argument, not a known verb)
    if (parts.length === 1 && verb) {
        const f = findFlight(verb);
        if (f) {
            // If manually hidden, restore it first
            if (manuallyHidden.has(f.gufi)) {
                manuallyHidden.delete(f.gufi);
                fdbOverrides.set(f.gufi, true);
                invalidateMarker(f.gufi);
                lastRenderTime = 0;
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: `RESTORE ${f.callsign || '???'}` }
                ]};
            }
            const cls = classifyTrack(f);
            const currentlyFdb = shouldShowFdb(f.gufi, cls);
            // Controlled flights (own/ho) cannot be toggled to LDB
            if (currentlyFdb && (cls === 'own' || cls === 'ho')) {
                return { feedback: [
                    { type: 'err', text: 'USER ACTION NOT ALLOWED ON A\nCONTROLLED FLIGHT' },
                    { type: 'info', text: `FORCED DATA BLK ${f.callsign}` }
                ]};
            }
            // Point-out tracks cannot be toggled to LDB — use QP <FLID> instead
            if (currentlyFdb && getPointoutIndicator(f)) {
                return { feedback: [
                    { type: 'err', text: 'POINT OUT ACTIVE — USE QP' },
                    { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
                ]};
            }
            fdbOverrides.set(f.gufi, !currentlyFdb);
            // Invalidate marker hash so it rebuilds immediately
            const m2 = markers.get(f.gufi);
            if (m2) { const el = m2.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: currentlyFdb ? 'SUPPRESS DATA BLK' : 'FORCE DATA BLK' },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
    }

    return { feedback: [{ type: 'err', text: 'INVALID ENTRY' }] };
}

function showFlightInRA(f) {
    const ra = document.getElementById('ra-content');
    const now = new Date();
    const zulu = String(now.getUTCHours()).padStart(2, '0') + String(now.getUTCMinutes()).padStart(2, '0');
    const cidVal = getCid(f);
    const cid = cidVal ? String(cidVal).padStart(4, '0') : '????';
    // Sector display: prefix with ARTCC handoff code if different facility
    const ctrlFac = f.controllingFacility || '';
    const ctrlSec = f.controllingSector || '??';
    const sector = (ctrlFac && myFacility && ctrlFac !== myFacility)
        ? getHandoffCode(ctrlFac) + ctrlSec
        : ctrlSec;
    const cs = f.callsign || '???';
    const type = f.aircraftType || '????';
    const equip = f.equipmentQualifier ? '/' + f.equipmentQualifier : '';
    const bcn = f.squawk || '????';
    const spd = f.groundSpeed != null ? String(Math.round(f.groundSpeed)).padStart(4, ' ') : '    ';
    const aalt = f.blockFloor != null && f.blockCeiling != null
        ? `${String(Math.round(f.blockFloor / 100)).padStart(3, '0')}B${String(Math.round(f.blockCeiling / 100)).padStart(3, '0')}`
        : f.assignedVfr
            ? (f.assignedAltitude != null ? `VFR/${String(Math.round(f.assignedAltitude / 100)).padStart(3, '0')}` : 'VFR')
            : f.assignedAltitude != null ? String(Math.round(f.assignedAltitude / 100)).padStart(3, '0') : '???';
    const origin = f.origin || '????';
    const dest = f.destination || '????';
    const route = f.route || '';
    const star = f.star || '';
    const remarks = f.remarks || '';

    // Build route line: route + STAR, append destination if not already present
    let routeStr = route;
    if (star) routeStr += (routeStr ? '.' : '') + star;
    const destUp = dest.toUpperCase();
    // Check if route already ends with destination (dot-separated or space-separated)
    const routeUp = routeStr.toUpperCase();
    const endsWithDest = routeUp.endsWith(destUp) || routeUp.endsWith('.' + destUp) || routeUp.endsWith(' ' + destUp);
    if (routeStr && !endsWithDest) {
        routeStr += '.' + dest;
    } else if (!routeStr) {
        routeStr = dest;
    }

    let text = `${zulu}\n`;
    text += `${cid} ${cs}(${sector}) ${type}${equip}\n`;
    text += `${bcn} ${spd} ${aalt} ${origin}..\n`;
    text += `${routeStr}\n`;
    if (remarks) text += `${remarks}`;
    ra.textContent = text;
}

// ════════════════════════════════════════════════════════════════════════════
// Global keyboard capture → MCA
// ════════════════════════════════════════════════════════════════════════════
// ── Mobile keyboard bridge ──
const mcaMobileInput = document.getElementById('mca-mobile-input');
document.getElementById('mca-kb-btn').addEventListener('click', e => {
    e.stopPropagation();
    mcaMobileInput.value = '';
    mcaMobileInput.focus();
});
mcaMobileInput.addEventListener('input', () => {
    const val = mcaMobileInput.value.toUpperCase();
    mcaMobileInput.value = '';
    for (const ch of val) mcaInsertChar(ch);
});

document.addEventListener('keydown', e => {
    // Don't capture when focused on sidebar form elements (but allow our mobile input)
    const ae = document.activeElement;
    const tag = ae?.tagName;
    if ((tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') && ae !== mcaMobileInput) return;

    // Escape → clear MCA
    if (e.key === 'Escape') { clearFindMarker(); mcaClear(); e.preventDefault(); return; }

    // Ctrl+R → recall last command
    if (e.ctrlKey && (e.key === 'r' || e.key === 'R')) { mcaRecall(); e.preventDefault(); return; }

    // Ctrl+Delete → clear RA
    if (e.ctrlKey && e.key === 'Delete') {
        document.getElementById('ra-content').textContent = '';
        e.preventDefault(); return;
    }

    // PageUp / PageDown → cycle vector line minutes (0,1,2,4,8)
    const vectorSteps = [0, 1, 2, 4, 8];
    if (e.key === 'PageUp' && !e.ctrlKey) {
        const idx = vectorSteps.indexOf(vectorMinutes);
        const next = idx < vectorSteps.length - 1 ? vectorSteps[idx + 1] : vectorSteps[vectorSteps.length - 1];
        vectorMinutes = next;
        document.getElementById('sel-vector').value = vectorMinutes;
        saveSettingsToUrl();
        e.preventDefault(); return;
    }
    if (e.key === 'PageDown' && !e.ctrlKey) {
        const idx = vectorSteps.indexOf(vectorMinutes);
        const next = idx > 0 ? vectorSteps[idx - 1] : vectorSteps[0];
        vectorMinutes = next;
        document.getElementById('sel-vector').value = vectorMinutes;
        saveSettingsToUrl();
        e.preventDefault(); return;
    }

    // Enter → execute command
    if (e.key === 'Enter' && !e.ctrlKey) { mcaExecute(); e.preventDefault(); return; }

    // Ctrl+Enter → newline in preview
    if (e.key === 'Enter' && e.ctrlKey) { mcaInsertChar('\n'); e.preventDefault(); return; }

    // Arrow keys
    if (e.key === 'ArrowLeft') {
        if (mca.cursor > 0) mca.cursor--;
        mcaRender(); e.preventDefault(); return;
    }
    if (e.key === 'ArrowRight') {
        if (mca.cursor < mca.text.length) mca.cursor++;
        mcaRender(); e.preventDefault(); return;
    }

    // Home / End / Ctrl+PgUp / Ctrl+PgDn
    if (e.key === 'Home' || (e.ctrlKey && e.key === 'PageUp')) {
        mca.cursor = 0; mcaRender(); e.preventDefault(); return;
    }
    if (e.key === 'End' || (e.ctrlKey && e.key === 'PageDown')) {
        mca.cursor = mca.text.length; mcaRender(); e.preventDefault(); return;
    }

    // Backspace / Delete
    if (e.key === 'Backspace') { mcaBackspace(); e.preventDefault(); return; }
    if (e.key === 'Delete') { mcaDelete(); e.preventDefault(); return; }

    // Insert → toggle overstrike/insert mode
    if (e.key === 'Insert') { mca.overstrike = !mca.overstrike; mcaRender(); e.preventDefault(); return; }

    // F-key shortcuts: initiate commands in MCA (CRC spec)
    const fKeyMap = {
        'F1':  'QF ', 'F2':  'QP ', 'F4': 'QX ', 'F5': 'QZ ',
        'F6':  'QU ', 'F7':  'QL ', 'F8': 'QQ ', 'F9': 'QB '
    };
    const fKeyShiftMap = {
        'F2': 'QD ', 'F7': 'WR ', 'F8': 'QR '
    };
    if (e.shiftKey && fKeyShiftMap[e.key]) {
        mcaClear();
        for (const ch of fKeyShiftMap[e.key]) mcaInsertChar(ch);
        e.preventDefault(); return;
    }
    if (!e.shiftKey && !e.ctrlKey && fKeyMap[e.key]) {
        mcaClear();
        for (const ch of fKeyMap[e.key]) mcaInsertChar(ch);
        e.preventDefault(); return;
    }

    // Printable characters → type into MCA (uppercase)
    if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
        mcaInsertChar(e.key.toUpperCase());
        e.preventDefault();
        return;
    }
});

// ════════════════════════════════════════════════════════════════════════════
// MCA & RA box drag/drop (click to pick up, click to drop)
// ════════════════════════════════════════════════════════════════════════════
let _boxDragging = null;
let _boxDragOffset = { x: 0, y: 0 };

function clampBox(el) {
    const container = el.parentElement;
    if (!container) return;
    const cRect = container.getBoundingClientRect();
    const eRect = el.getBoundingClientRect();
    let left = eRect.left - cRect.left;
    let top = eRect.top - cRect.top;
    left = Math.max(0, Math.min(left, cRect.width - eRect.width));
    top = Math.max(0, Math.min(top, cRect.height - eRect.height));
    el.style.left = left + 'px';
    el.style.top = top + 'px';
    el.style.bottom = 'auto';
    el.style.right = 'auto';
}

function saveBoxPosition(el) {
    const key = 'boxPos_' + el.id;
    localStorage.setItem(key, JSON.stringify({ left: el.style.left, top: el.style.top }));
}

function restoreBoxPosition(el) {
    const key = 'boxPos_' + el.id;
    const saved = localStorage.getItem(key);
    if (saved) {
        try {
            const pos = JSON.parse(saved);
            if (pos.left) el.style.left = pos.left;
            if (pos.top) { el.style.top = pos.top; el.style.bottom = 'auto'; el.style.right = 'auto'; }
        } catch(e) {}
    }
    // Clamp to viewport on restore (handles window resize since last save)
    requestAnimationFrame(() => clampBox(el));
}

function dropBox() {
    if (!_boxDragging) return;
    clampBox(_boxDragging);
    saveBoxPosition(_boxDragging);
    _boxDragging.classList.remove('box-dragging');
    _boxDragging = null;
}

function setupBoxDrag(el, handleEl) {
    restoreBoxPosition(el);
    (handleEl || el).addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        e.stopPropagation();

        if (_boxDragging === el) {
            // Already dragging this box → drop it
            dropBox();
            return;
        }
        // Drop any currently dragged box
        if (_boxDragging) dropBox();
        // Pick up this box
        _boxDragging = el;
        el.classList.add('box-dragging');
        const rect = el.getBoundingClientRect();
        _boxDragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    });
}

document.addEventListener('mousemove', e => {
    if (!_boxDragging) return;
    const container = _boxDragging.parentElement;
    const cRect = container.getBoundingClientRect();
    const eRect = _boxDragging.getBoundingClientRect();
    let left = e.clientX - cRect.left - _boxDragOffset.x;
    let top = e.clientY - cRect.top - _boxDragOffset.y;
    left = Math.max(0, Math.min(left, cRect.width - eRect.width));
    top = Math.max(0, Math.min(top, cRect.height - eRect.height));
    _boxDragging.style.left = left + 'px';
    _boxDragging.style.top = top + 'px';
    _boxDragging.style.bottom = 'auto';
    _boxDragging.style.right = 'auto';
});

// Click outside the dragged box → drop it
document.addEventListener('mousedown', e => {
    if (_boxDragging && e.button === 0 && !_boxDragging.contains(e.target)) {
        dropBox();
    }
});

// Re-clamp on window resize
window.addEventListener('resize', () => {
    clampBox(document.getElementById('mca'));
    clampBox(document.getElementById('ra'));
    const poMenu = document.getElementById('po-menu');
    if (poMenu.style.display !== 'none') clampBox(poMenu);
});

setupBoxDrag(document.getElementById('mca'));
setupBoxDrag(document.getElementById('ra'));
setupBoxDrag(document.getElementById('po-menu'), document.getElementById('po-menu-title'));

// Point-out menu: close button (left + middle click)
document.getElementById('po-menu-close').addEventListener('click', (e) => {
    e.stopPropagation();
    closePointoutMenu();
});
document.getElementById('po-menu-close').addEventListener('auxclick', (e) => {
    if (e.button === 1) { e.preventDefault(); e.stopPropagation(); closePointoutMenu(); }
});
// Point-out menu: middle-click title bar → close menu
document.getElementById('po-menu-title').addEventListener('auxclick', (e) => {
    if (e.button === 1) { e.preventDefault(); e.stopPropagation(); closePointoutMenu(); }
});

// Point-out menu: sector row click handler (shared for left + middle click)
function handlePoSectorClick(e) {
    const row = e.target.closest('.po-sector-row');
    if (!row) return;
    e.stopPropagation();
    const gufi = row.dataset.gufi;
    const role = row.dataset.role;
    const f = flights.get(gufi);
    if (!f) return;
    const isAcked = pointoutAcked.has(gufi);

    if (role === 'receiver' && !isAcked) {
        // Acknowledge the point-out → P removed from line 0, menu closes
        // Since we only have one originating sector per PO, acking it = acking all
        f.pointoutOriginatingUnit = null;
        f.pointoutReceivingUnit = null;
        pointoutAcked.delete(gufi);
        invalidateMarker(gufi);
        closePointoutMenu();
        mca.feedback = [
            { type: 'ok', text: 'ACCEPT \u2014 ACKNOWLEDGE PO' },
            { type: 'info', text: f.callsign || '???' }
        ];
        mcaRender();
    } else if (role === 'receiver' && isAcked) {
        // Already acked → remove from display, clear PO
        f.pointoutOriginatingUnit = null;
        f.pointoutReceivingUnit = null;
        pointoutAcked.delete(gufi);
        invalidateMarker(gufi);
        closePointoutMenu();
    } else if (role === 'originator' && !isAcked) {
        // Originator clicks pending sector → simulate remote ack (P→A on line 0)
        pointoutAcked.add(gufi);
        invalidateMarker(gufi);
        // Update menu in place (stays open, now shows white/unboxed)
        const poInfo = getPointoutIndicator(f);
        if (poInfo) updatePointoutMenuBody(f, poInfo);
    } else if (role === 'originator' && isAcked) {
        // Originator clicks acked sector → clear PO, close menu
        pointoutAcked.delete(gufi);
        f.pointoutOriginatingUnit = null;
        f.pointoutReceivingUnit = null;
        invalidateMarker(gufi);
        closePointoutMenu();
    }
}
document.getElementById('po-menu-body').addEventListener('click', handlePoSectorClick);
document.getElementById('po-menu-body').addEventListener('auxclick', (e) => {
    if (e.button === 1) { e.preventDefault(); handlePoSectorClick(e); }
});

// ════════════════════════════════════════════════════════════════════════════
// Init
// ════════════════════════════════════════════════════════════════════════════
loadSettingsFromUrl();
rebuildFacilityDropdown();
rebuildSectorCheckboxes();

// Save map position/zoom on pan/zoom (debounced)
let _mapSaveTimer = null;
map.on('moveend', () => {
    clearTimeout(_mapSaveTimer);
    _mapSaveTimer = setTimeout(saveSettingsToUrl, 500);
});
</script>
</body>
</html>
