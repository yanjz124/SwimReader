<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SFDPS ERAM</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
@font-face { font-family: 'ERAM'; src: url('ERAMv110.ttf') format('truetype'); }
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000000; color: #cccc44; font-family: 'ERAM', 'Consolas', 'Courier New', monospace; overflow: hidden; height: 100vh; }

/* ── Layout ── */
#app { position: relative; height: 100vh; }
#sidebar-wrapper { display: flex; position: absolute; top: 0; left: 0; bottom: 0; z-index: 500; }
#sidebar { width: 260px; min-width: 260px; background: #111; border-right: 1px solid #333; display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; transition: margin-left 0.2s ease; }
#sidebar.collapsed { margin-left: -260px; }
#sidebar-toggle {
    width: 20px; background: #1a1a1a; border: none; border-right: 1px solid #333;
    color: #666; cursor: pointer; display: flex; align-items: center; justify-content: center;
    font-size: 14px; padding: 0; flex-shrink: 0; z-index: 10;
    transition: color 0.15s, height 0.2s, border-radius 0.2s, margin-top 0.2s;
}
#sidebar-toggle:hover { color: #cccc44; background: #222; }
#sidebar.collapsed ~ #sidebar-toggle {
    height: 36px; align-self: flex-start; margin-top: 8px;
    border-radius: 0 4px 4px 0; border: 1px solid #333; border-left: none;
    opacity: 0.5;
}
#sidebar.collapsed ~ #sidebar-toggle:hover { opacity: 1; }
#map-container { position: absolute; top: 0; left: 0; right: 0; bottom: 0; }
#map { width: 100%; height: 100%; }

/* ── Sidebar ── */
#sidebar-header { padding: 10px 12px; border-bottom: 1px solid #333; }
#sidebar-header h2 { font-size: 13px; color: #aaa; font-weight: normal; letter-spacing: 1px; }
#connection-status { font-size: 11px; margin-top: 4px; }

.panel-section { padding: 10px 12px; border-bottom: 1px solid #222; }
.panel-label { font-size: 10px; color: #666; letter-spacing: 1.5px; margin-bottom: 8px; font-weight: bold; }

.ctrl-row { display: flex; align-items: center; margin-bottom: 6px; font-size: 11px; }
.ctrl-row label { color: #aaa; min-width: 60px; cursor: pointer; display: flex; align-items: center; gap: 6px; }
.ctrl-row select {
    flex: 1; background: #1a1a1a; color: #cccc44; border: 1px solid #333;
    padding: 3px 6px; font-family: inherit; font-size: 11px; outline: none;
}
.ctrl-row select:focus { border-color: #cccc44; }
.ctrl-row input[type="checkbox"] { accent-color: #cccc44; }

#sector-checkboxes {
    max-height: 200px; overflow-y: auto; font-size: 11px; color: #aaa;
    scrollbar-width: thin; scrollbar-color: #444 #1a1a1a;
}
#sector-checkboxes::-webkit-scrollbar { width: 6px; }
#sector-checkboxes::-webkit-scrollbar-track { background: #1a1a1a; }
#sector-checkboxes::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
#sector-checkboxes::-webkit-scrollbar-thumb:hover { background: #666; }

.traffic-row { font-size: 12px; padding: 2px 0; display: flex; justify-content: space-between; }
.traffic-row.own { color: #cccc44; }
.traffic-row.ho { color: #cccc44; }
.traffic-row.other { color: #cccc44; }
.traffic-row.total { color: #aaa; border-top: 1px solid #333; margin-top: 4px; padding-top: 6px; }

#sidebar-footer {
    margin-top: auto; padding: 8px 12px; border-top: 1px solid #333;
    font-size: 11px; color: #666;
}

/* ── Map overrides ── */
.leaflet-container {
    background: #000000 !important;
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cline x1='16' y1='9' x2='16' y2='12' stroke='white' stroke-width='4.5'/%3E%3Cline x1='16' y1='20' x2='16' y2='23' stroke='white' stroke-width='4.5'/%3E%3Cline x1='9' y1='16' x2='12' y2='16' stroke='white' stroke-width='4.5'/%3E%3Cline x1='20' y1='16' x2='23' y2='16' stroke='white' stroke-width='4.5'/%3E%3Crect x='12' y='12' width='8' height='8' fill='none' stroke='white' stroke-width='1.3'/%3E%3C/svg%3E") 16 16, crosshair !important;
}
.leaflet-control-zoom a { background: #222 !important; color: #cccc44 !important; border-color: #444 !important; }
.leaflet-control-attribution { display: none !important; }
/* Boundary/overlay lines: lighten blend so brighter line always shows through overlaps */
.bnd-path { mix-blend-mode: lighten; }

/* ── Aircraft target group ── */
.ac-group { position: absolute; pointer-events: none; }

/* ── Target symbols (Table 1 — radar return present) ── */
/* Correlated Beacon: \ backslash — transponder on, correlated to flight plan */
.ac-sym-corr-bcn {
    position: absolute; width: 2px; height: 12px;
    background: #cccc44;
    transform: translate(-1px, -6px) rotate(-45deg);
    pointer-events: auto; cursor: inherit;
}
.ac-sym-corr-bcn.emrg { background: #ff4444; }

/* Reduced Separation: • dot — correlated beacon in reduced separation area (at/below FL230) */
.ac-sym-reduced-sep {
    position: absolute;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 16px; font-weight: bold; line-height: 1;
    color: #cccc44;
    transform: translate(-50%, -50%);
    pointer-events: auto; cursor: inherit;
}
.ac-sym-reduced-sep.emrg { color: #ff4444; }

/* Uncorrelated Beacon: / forward slash — transponder on, no flight plan */
.ac-sym-uncorr-bcn {
    position: absolute; width: 2px; height: 12px;
    background: #cccc44;
    transform: translate(-1px, -6px) rotate(45deg);
    pointer-events: auto; cursor: inherit;
}

/* Uncorrelated Primary: + plus — transponder off/standby */
.ac-sym-uncorr-pri {
    position: absolute; width: 12px; height: 12px;
    transform: translate(-6px, -6px);
    pointer-events: auto; cursor: inherit;
}
.ac-sym-uncorr-pri::before, .ac-sym-uncorr-pri::after {
    content: ''; position: absolute; background: #cccc44;
}
.ac-sym-uncorr-pri::before { width: 12px; height: 2px; top: 5px; left: 0; }
.ac-sym-uncorr-pri::after { width: 2px; height: 12px; top: 0; left: 5px; }

/* ── Track position symbols (Table 2 — coasting/no target) ── */
/* Flight Plan Aided (Flat) Track: hollow diamond — centered at (0,0) target position */
.ac-sym-flat-track {
    position: absolute;
    box-sizing: border-box;
    width: 8px; height: 8px;
    left: -4px; top: -4px;
    border: 1.5px solid #cccc44; background: transparent;
    transform: rotate(45deg);
    transform-origin: center;
    pointer-events: auto; cursor: inherit;
    z-index: 1;
}
.ac-sym-flat-track.emrg { border-color: #ff4444; }

/* Coast Track: # hash */
.ac-sym-coast {
    position: absolute;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 14px; font-weight: bold;
    color: #cccc44;
    transform: translate(-5px, -7px);
    pointer-events: auto; cursor: inherit;
}

/* Handoff flash — handled by JS content changes in formatLine3() */

/* ── Leader line ── */
.ac-leader { position: absolute; top: 0; left: 0; pointer-events: none; }

/* ── Data block ── */
.ac-db {
    position: absolute; white-space: pre; pointer-events: auto; cursor: inherit;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 10px; line-height: 12.5px; letter-spacing: 0.5px;
    padding: 1px 2px; color: #cccc44;
    text-shadow: 0 0 3px rgba(0,0,0,0.9), 1px 1px 2px rgba(0,0,0,0.8);
}
.ac-db.emrg { color: #ff4444; }
.dwell-border { position: absolute; pointer-events: none; border: 1px solid #cccc44; }
.emrg .dwell-border { border-color: #ff4444; }
.ac-db.ldb.dwell { outline: 1px solid #cccc44; outline-offset: 1px; }
.ac-db.ldb.dwell.emrg { outline-color: #ff4444; }
/* .ac-db.ho — handoff flash now driven by JS */

/* ── Column 0 (R / VCI) — inline prefix on each data block line ── */
.ac-col0 { color: #cccc44; }
.ac-vci { color: #44cc44; }
/* ── Point-out P/A indicator (line 0) ── */
.ac-po-pending { color: #cccc44; }
.ac-po-accepted { color: #ffffff; }

/* ── Line 0 (P/A pointout) — above data block ── */
.ac-line0 {
    position: absolute; white-space: pre; pointer-events: none;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 10px; line-height: 12.5px; letter-spacing: 0.5px;
    text-shadow: 0 0 3px rgba(0,0,0,0.9), 1px 1px 2px rgba(0,0,0,0.8);
}
.ac-line0.po-initiated { color: #cccc44; }
.ac-line0.po-acknowledged { color: #ffffff; }

/* ── Flight detail (sidebar panel) ── */
#flight-detail-section { display: none; }
#flight-detail-section .fd-title { color: #cccc44; font-size: 12px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; }
#flight-detail-section .fd-row { display: flex; gap: 8px; margin-bottom: 2px; font-size: 11px; }
#flight-detail-section .fd-label { color: #666; min-width: 60px; flex-shrink: 0; }
#flight-detail-section .fd-val { color: #cccc44; word-break: break-all; }
#flight-detail-section .fd-close { cursor: pointer; color: #666; font-size: 14px; }
#flight-detail-section .fd-close:hover { color: #ff4444; }

/* ── Target symbols are drawn as inline geometric divs (no font metrics dependency) ── */

/* ── MCA (Message Composition Area) ── */
#mca {
    position: absolute; z-index: 1000;
    bottom: 170px; right: 30px;
    font-family: 'ERAM', 'Consolas', 'Courier New', monospace;
    user-select: none;
}
#mca.box-dragging { outline: 2px solid #fff; cursor: move; }
#mca-preview {
    background: #000000; border: 1px solid #888; color: #ffffff;
    padding: 3px 6px; min-width: 400px;
    font-size: 14px; font-weight: normal; line-height: 18px; white-space: pre; min-height: 28px;
    display: flex; align-items: center;
}
#mca-feedback {
    background: #000000; border: 1px solid #888; border-top: none; color: #ffffff;
    padding: 3px 6px; min-width: 400px;
    font-size: 14px; font-weight: normal; line-height: 18px; white-space: pre; min-height: 68px;
}
#mca-kb-btn {
    position: absolute; top: 0; right: -28px;
    width: 24px; height: 24px; padding: 0;
    background: rgba(50,50,50,0.6); border: 1px solid #555; border-radius: 3px;
    color: #888; font-size: 16px; line-height: 22px; text-align: center;
    cursor: pointer; opacity: 0.5; transition: opacity 0.2s;
    display: none;
}
#mca-kb-btn:hover, #mca-kb-btn:active { opacity: 1; color: #ccc; }
@media (pointer: coarse) { #mca-kb-btn { display: block; } }
#mca.show-kb #mca-kb-btn { display: block; }
#mca-mobile-input {
    position: absolute; left: -9999px; width: 1px; height: 1px; opacity: 0;
}
.transp-mca #mca-preview,
.transp-mca #mca-feedback { background: transparent; }
.transp-mca #ra-content { background: transparent; }

/* ── RA (Response Area) ── */
#ra {
    position: absolute; z-index: 1000;
    bottom: 30px; right: 30px;
    max-width: calc(100vw - 60px);
    font-family: 'ERAM', 'Consolas', 'Courier New', monospace;
    user-select: none;
}
#ra.box-dragging { outline: 2px solid #fff; cursor: move; }
#ra-content {
    background: #000000; border: 1px solid #888; color: #ffffff;
    padding: 3px 6px; width: 500px; min-height: 100px;
    max-height: 60vh; overflow-y: auto;
    font-size: 14px; line-height: 18px; white-space: pre-wrap; word-break: break-all;
    font-weight: normal;
}
</style>
</head>
<body>
<div id="app">
    <div id="sidebar-wrapper">
    <div id="sidebar">
        <div id="sidebar-header">
            <h2>SFDPS RADAR</h2>
            <div id="connection-status">Connecting...</div>
        </div>

        <div class="panel-section">
            <div class="panel-label">YOUR POSITION</div>
            <div class="ctrl-row">
                <label>Facility</label>
                <select id="sel-facility">
                    <option value="">All</option>
                </select>
            </div>
            <div style="margin-top:4px;">
                <div class="panel-label" style="margin-bottom:4px;">SECTORS</div>
                <div id="sector-checkboxes">
                    <span style="color:#666; font-size:10px;">Select facility first</span>
                </div>
            </div>
            <div class="ctrl-row" style="margin-top:4px;">
                <label><input type="checkbox" id="chk-facility-only"> Facility only</label>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">DISPLAY</div>
            <div class="ctrl-row">
                <label>Vector</label>
                <select id="sel-vector">
                    <option value="0">Off</option>
                    <option value="1" selected>1 min</option>
                    <option value="2">2 min</option>
                    <option value="4">4 min</option>
                    <option value="8">8 min</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>Line 4</label>
                <select id="sel-line4">
                    <option value="DEST" selected>DEST</option>
                    <option value="TYPE">TYPE</option>
                    <option value="OFF">OFF</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>LDB %</label>
                <input type="range" id="rng-ldb-brightness" min="0" max="100" value="70"
                    style="flex:1; accent-color:#cccc44;">
                <span id="lbl-ldb-brightness" style="min-width:28px; text-align:right; font-size:11px;">70</span>
            </div>
            <div class="ctrl-row">
                <label>Hist #</label>
                <select id="sel-histcount">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5" selected>5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>UHI %</label>
                <input type="range" id="rng-bnd-uhi" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-uhi" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>HI %</label>
                <input type="range" id="rng-bnd-hi" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-hi" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>LO %</label>
                <input type="range" id="rng-bnd-lo" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-lo" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>APP %</label>
                <input type="range" id="rng-bnd-app" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-app" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label>HI Awy</label>
                <input type="range" id="rng-jroutes" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-jroutes" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label>LO Awy</label>
                <input type="range" id="rng-vroutes" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-vroutes" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label>VORs</label>
                <input type="range" id="rng-vors" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-vors" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label>PROC</label>
                <input type="range" id="rng-proc" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-proc" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label><input type="checkbox" id="chk-mapbg"> Map Bg</label>
                <label style="margin-left:12px;"><input type="checkbox" id="chk-mca-kb"> KB</label>
            </div>
            <!-- Transp MCA: reserved for future use
            <div class="ctrl-row">
                <label><input type="checkbox" id="chk-transp-mca"> Transp MCA</label>
            </div> -->
            <div class="ctrl-row">
                <button id="btn-fullscreen" style="flex:1; background:#222; color:#cccc44; border:1px solid #444; padding:3px 8px; font-family:inherit; font-size:11px; cursor:pointer;">Fullscreen</button>
            </div>
            <div class="ctrl-row">
                <label>NX LVL</label>
                <select id="sel-nxlvl">
                    <option value="0">OFF</option>
                    <option value="3">3</option>
                    <option value="23">23</option>
                    <option value="123">123</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>NX %</label>
                <input type="range" id="rng-nx" min="0" max="100" value="50" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-nx" style="min-width:28px; text-align:right; font-size:11px;">50</span>
            </div>
            <div class="ctrl-row">
                <label>Font</label>
                <select id="sel-fontsize">
                    <option value="8">8 px</option>
                    <option value="9">9 px</option>
                    <option value="10" selected>10 px</option>
                    <option value="11">11 px</option>
                    <option value="12">12 px</option>
                    <option value="14">14 px</option>
                </select>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">ALTITUDE FILTER</div>
            <div class="ctrl-row">
                <label>Low FL</label>
                <input type="number" id="inp-alt-low" value="0" min="0" max="999" step="10"
                    style="flex:1; background:#1a1a1a; color:#cccc44; border:1px solid #333; padding:3px 6px; font-family:inherit; font-size:11px; outline:none; width:60px;">
            </div>
            <div class="ctrl-row">
                <label>High FL</label>
                <input type="number" id="inp-alt-high" value="999" min="0" max="999" step="10"
                    style="flex:1; background:#1a1a1a; color:#cccc44; border:1px solid #333; padding:3px 6px; font-family:inherit; font-size:11px; outline:none; width:60px;">
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">TRAFFIC</div>
            <div id="traffic-counts">
                <div class="traffic-row own">Own <span id="cnt-own">0</span></div>
                <div class="traffic-row ho">Handoff <span id="cnt-ho">0</span></div>
                <div class="traffic-row other">Other <span id="cnt-other">0</span></div>
                <div class="traffic-row total">Total <span id="cnt-total">0</span></div>
            </div>
        </div>

        <div class="panel-section" id="flight-detail-section">
            <div class="fd-title">
                <span id="fd-title"></span>
                <span class="fd-close" onclick="closeFd()">&times;</span>
            </div>
            <div id="fd-body"></div>
        </div>

        <div id="sidebar-footer">
            <span id="stat-rate">0</span> msg/s &middot;
            <span id="stat-flights">0</span> flights &middot;
            <span id="stat-uptime">00:00:00</span>
            <br><span id="stat-fp" style="color:#888;font-size:0.85em;"></span>
        </div>
    </div>
    <button id="sidebar-toggle" title="Toggle sidebar">&#9664;</button>
    </div>

    <div id="map-container">
        <div id="map"></div>
        <div id="mca">
            <div id="mca-preview"><span class="mca-cursor">_</span></div>
            <div id="mca-feedback"></div>
            <button id="mca-kb-btn" title="Open keyboard" aria-label="Open keyboard">&#9000;&#xFE0E;</button>
            <input id="mca-mobile-input" autocapitalize="characters" autocomplete="off" autocorrect="off" spellcheck="false">
        </div>
        <div id="ra">
            <div id="ra-content"></div>
        </div>
    </div>
</div>

<script>
// ════════════════════════════════════════════════════════════════════════════
// State
// ════════════════════════════════════════════════════════════════════════════
const flights = new Map();          // current displayed state — datablock fields updated instantly
const pendingPositions = new Map(); // buffered lat/lon awaiting next scan cycle
const flightHistory = new Map();
let MAX_HISTORY = 5;
const TRACK_COLOR = '#cccc44';
const EMRG_COLOR = '#ff4444';
const MAP_COLOR = '#555555';
const RENDER_INTERVAL = 2000;  // render repaint interval (ms)
const SCAN_INTERVAL = 12000;   // fixed 12s radar scan cycle
let lastScanTime = performance.now();

let myFacility = '';
let mySectors = new Set();
let facilityOnly = false;   // when true + facility selected, hide all non-facility aircraft
let showFdb = true;
let showHistory = true;
let vectorMinutes = 1;
// showBoundaries removed — boundaries always on, controlled by brightness sliders
let selectedGufi = null;
let wsConnected = false;
let msgRate = 0;
let altFilterLow = 0;      // FL (hundreds of feet), 0 = no filter
let altFilterHigh = 999;    // FL (hundreds of feet), 999 = no filter
let fontSize = 10;          // data block font size in px
let ldbBrightness = 70;     // 0-100, opacity for LDB data blocks (0=hidden, 100=same as FDB)
let showMapBg = false;      // tile layer hidden by default
let line4Mode = 'DEST';     // 'DEST' | 'TYPE' | 'OFF' — what FDB line 4 shows
const quickLookSectors = new Set(); // QL sectors — force FDB on tracks in these sectors without claiming ownership
const fdbOverrides = new Map(); // gufi → true/false — user toggle for FDB/LDB per track
const wasOwnOrHo = new Set();  // tracks that were own/ho — keeps FDB sticky when they become other
const lastVisibleAt = new Map(); // gufi → performance.now() — grace period prevents flicker on facility field changes

const knownFacilities = new Map();
const hoCompletedInfo = new Map(); // gufi → { time, receiving, transferring } — track completed handoffs for 60s O display
const dbPositions = new Map(); // gufi → position number 1-9 (data block placement)
const ldrLenOverrides = new Map(); // gufi → leader length level (0-3), default 1
const driActive = new Map();       // gufi → 'J' (standard 5nm) or 'T' (reduced 3nm)
const dwellLocked = new Set();     // GUFIs with persistent dwell emphasis (toggled via Field A click)
const vciActive = new Set();       // GUFIs with VCI (Visual Communications Indicator) toggled on

// Controller-entered altitude overrides (QZ/QQ/QR commands)
// SWIM data has higher priority — when SWIM provides the same field, the local override is cleared
const localAssignedAlt = new Map();  // gufi → { feet, display } — QZ assigned altitude (display = 'VFR', 'OTP', '350', '180B240')
const localInterimAlt = new Map();   // gufi → { feet, type } — QQ interim (type: 'I'=interim, 'P'=procedure, 'L'=local)
const localReportedAlt = new Map();  // gufi → feet — QR controller-entered reported altitude

// HSF (Heading/Speed/Free text) data — QS command (local overrides)
const hsfData = new Map();     // gufi → { heading, speed, freeText } — local QS overrides
const hsfShowMap = new Set();  // GUFIs currently displaying HSF on line 4 (toggled by ↴ click or QS <FLID>)

// Effective HSF: merges server clearance data with local QS overrides (local wins per-field)
// Server clearanceSpeed may be bare number — normalize: 2-digit → M prefix, 3-digit → S prefix
function normalizeSpeed(s) {
    if (!s) return s;
    if (/^\d{2}[+-]?$/.test(s)) return 'M' + s;  // e.g. 75 → M75, 78+ → M78+
    if (/^\d{3}$/.test(s)) return 'S' + s;        // e.g. 250 → S250
    return s;  // 280+, 250-, M79, S270 etc. pass through
}
function getEffectiveHsf(f) {
    const local = hsfData.get(f.gufi);
    const heading = local?.heading ?? f.clearanceHeading ?? null;
    const speed = local?.speed ?? normalizeSpeed(f.clearanceSpeed) ?? null;
    const freeText = local?.freeText ?? f.clearanceText ?? null;
    if (!heading && !speed && !freeText) return null;
    return { heading, speed, freeText };
}

// Point-out state
const pointoutAcked = new Set();  // GUFIs with acknowledged point-outs (P→A)

// .FIND overlay state
let findMarker = null;   // { ident, lat, lon, time } — active find highlight
let findTimer = null;    // auto-clear timeout
let findBlinkRaf = null; // setTimeout ID for blink redraw

function setFindMarker(ident, lat, lon) {
    clearFindMarker();
    findMarker = { ident, lat, lon, time: performance.now() };
    // Auto-clear after 30 seconds
    findTimer = setTimeout(clearFindMarker, 30000);
    // Start blink redraw — every 500ms to match blink rate
    (function blinkLoop() {
        if (!findMarker) return;
        drawOverlay();
        findBlinkRaf = setTimeout(blinkLoop, 500);
    })();
}

function clearFindMarker() {
    findMarker = null;
    if (findTimer) { clearTimeout(findTimer); findTimer = null; }
    if (findBlinkRaf) { clearTimeout(findBlinkRaf); findBlinkRaf = null; }
    drawOverlay();
}

// Global flash reference — updated once per 500ms tick so ALL tracks see the same phase
let flashTime = performance.now();

// Dedup: when a facility is selected, only show one GUFI per callsign (prefer our facility)
const bestGufiByCallsign = new Map();  // callsign → gufi — rebuilt each render cycle
function isDedupHidden(gufi, f) {
    return myFacility && f.callsign && bestGufiByCallsign.get(f.callsign) !== gufi;
}

// Facility handoff codes — loaded from handoff-codes.json
// Structure: { default: { FAC: code }, ZDC: { PCT: code }, ... }
let handoffCodesConfig = { default: {} };

async function loadHandoffCodes() {
    try {
        const resp = await fetch('/handoff-codes.json');
        if (!resp.ok) return;
        handoffCodesConfig = await resp.json();
        console.log('[HO-Codes] Loaded', Object.keys(handoffCodesConfig.default).length, 'default codes');
    } catch (e) { console.warn('[HO-Codes]', e); }
}
loadHandoffCodes();

// Look up handoff code for a facility, respecting per-scope overrides
function getHandoffCode(facility) {
    // Per-scope override first (e.g. ZDC scope sees PCT as "E")
    if (myFacility && handoffCodesConfig[myFacility]) {
        const code = handoffCodesConfig[myFacility][facility];
        if (code) return code;
    }
    // Default codes
    const code = handoffCodesConfig.default?.[facility];
    if (code) return code;
    // Fallback: first character of facility ID
    return facility.charAt(0);
}

// Destination airport single-letter codes — loaded from destination-codes.json
// Structure: { ZDC: { A: ["ATL"], B: ["BWI"], ... }, ... }
// Reverse lookup: destCodeLookup[facility][airport] = letter
let destCodesConfig = {};
const destCodeLookup = {};  // facility → { airport → letter }

async function loadDestinationCodes() {
    try {
        const resp = await fetch('/destination-codes.json');
        if (!resp.ok) return;
        destCodesConfig = await resp.json();
        // Build reverse lookup: airport → letter for each facility
        for (const [fac, letters] of Object.entries(destCodesConfig)) {
            destCodeLookup[fac] = {};
            for (const [letter, airports] of Object.entries(letters)) {
                for (const apt of airports) {
                    destCodeLookup[fac][apt] = letter;
                }
            }
        }
        const facCount = Object.keys(destCodesConfig).length;
        console.log('[DestCodes] Loaded destination codes for', facCount, 'facilities');
    } catch (e) { console.warn('[DestCodes]', e); }
}
loadDestinationCodes();

// Look up single-letter destination code for an airport, using selected facility's config
function getDestinationLetter(dest) {
    if (!dest || !myFacility) return '';
    const lookup = destCodeLookup[myFacility];
    if (!lookup) return '';
    // Try as-is (FAA LID), then with K prefix stripped (ICAO→LID)
    return lookup[dest] || lookup[dest.replace(/^K/, '')] || '';
}

// ════════════════════════════════════════════════════════════════════════════
// Map setup
// ════════════════════════════════════════════════════════════════════════════
const map = L.map('map', {
    center: [39.0, -98.0],
    zoom: 6,
    dragging: false,       // disable left-click drag — we use right-click pan
    doubleClickZoom: false, // disable double-click zoom
    zoomControl: false,
    keyboard: false,       // disable numpad/+/- zoom — conflicts with MCA input
    attributionControl: false,
    zoomSnap: 0.1,        // granular zoom (0.1 steps)
    zoomDelta: 0.1,       // each scroll/click zooms by 0.1
    wheelPxPerZoomLevel: 200,  // smooth scroll zoom
});

const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
    subdomains: 'abcd', maxZoom: 19, opacity: 0.4
});

map.createPane('nexrad');
map.getPane('nexrad').style.zIndex = 250;
map.getPane('nexrad').style.pointerEvents = 'none';

map.createPane('routes');
map.getPane('routes').style.zIndex = 420;

map.createPane('targets');
map.getPane('targets').style.zIndex = 450;

const markers = new Map();

// QU route display: gufi → { polyline, destMarker, time, minutes }
// polyline = Leaflet L.polyline, destMarker = L.marker for destination X
// time = performance.now() when added (auto-remove after 30s for QU commands, null = persistent)
// minutes = display length in minutes (null = full route)
const activeRoutes = new Map();

// ════════════════════════════════════════════════════════════════════════════
// Canvas overlay for history dots + velocity vectors
// ════════════════════════════════════════════════════════════════════════════
const overlayCanvas = document.createElement('canvas');
overlayCanvas.style.position = 'absolute';
overlayCanvas.style.pointerEvents = 'none';
overlayCanvas.style.zIndex = '440';
map.getPane('overlayPane').appendChild(overlayCanvas);

// Draw a symbol as canvas geometry at (cx, cy) — same shapes as the HTML target symbols
const SYM_LINE_LEN = 14;   // length of \ and / lines (px)
const SYM_LINE_W = 2;      // stroke width
const SYM_DOT_R = 2.5;     // dot radius for • symbol
function drawSymbolGeometry(ctx, sym, cx, cy, color) {
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = SYM_LINE_W;
    const half = SYM_LINE_LEN / 2;
    if (sym === '\\') {
        // Backslash: top-left to bottom-right
        ctx.beginPath();
        ctx.moveTo(cx - half * 0.707, cy - half * 0.707);
        ctx.lineTo(cx + half * 0.707, cy + half * 0.707);
        ctx.stroke();
    } else if (sym === '/') {
        // Forward slash: bottom-left to top-right
        ctx.beginPath();
        ctx.moveTo(cx - half * 0.707, cy + half * 0.707);
        ctx.lineTo(cx + half * 0.707, cy - half * 0.707);
        ctx.stroke();
    } else if (sym === '\u2022') {
        // Dot: filled circle
        ctx.beginPath();
        ctx.arc(cx, cy, SYM_DOT_R, 0, 2 * Math.PI);
        ctx.fill();
    }
    // ◇ (diamond): history doesn't draw diamond overlay, only the current position marker does
}

function drawOverlay() {
    const size = map.getSize();
    if (size.x === 0 || size.y === 0) return;
    const bounds = map.getBounds();
    const topLeft = map.containerPointToLayerPoint([0, 0]);
    overlayCanvas.width = size.x;
    overlayCanvas.height = size.y;
    L.DomUtil.setPosition(overlayCanvas, topLeft);

    const ctx = overlayCanvas.getContext('2d');

    // ── History symbols (dimmer target symbols — drawn as geometry, not font) ──
    if (showHistory) {
        for (const [gufi, hist] of flightHistory) {
            if (hist.length === 0) continue;
            const f = flights.get(gufi);
            if (!f || f.latitude == null) continue;
            if (!isVisible(f)) continue;
            if (isDedupHidden(gufi, f)) continue;

            const color = isEmergency(f) ? EMRG_COLOR : TRACK_COLOR;
            const isFdb = shouldShowFdb(gufi, classifyTrack(f));
            const histAlpha = isFdb ? 0.30 : (ldbBrightness / 100) * 0.30;
            if (histAlpha <= 0) continue;

            for (let i = 0; i < hist.length; i++) {
                if (!bounds.contains([hist[i].lat, hist[i].lon])) continue;
                const pt = map.latLngToLayerPoint([hist[i].lat, hist[i].lon]);
                const x = pt.x - topLeft.x;
                const y = pt.y - topLeft.y;
                ctx.globalAlpha = histAlpha;
                drawSymbolGeometry(ctx, hist[i].sym || '\\', x, y, color);
            }
        }
    }

    // ── Velocity vectors ──
    if (vectorMinutes > 0) {
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 1.0;
        for (const [gufi, f] of flights) {
            if (f.latitude == null || f.longitude == null) continue;
            if (f.trackVelocityX == null || f.trackVelocityY == null) continue;
            if (!isVisible(f)) continue;
            if (isDedupHidden(gufi, f)) continue;
            if (!showFdb || !shouldShowFdb(gufi, classifyTrack(f))) continue;
            if (!bounds.contains([f.latitude, f.longitude])) continue;

            const color = isEmergency(f) ? EMRG_COLOR : TRACK_COLOR;

            const dLat = f.trackVelocityY * vectorMinutes / 3600;
            const dLon = f.trackVelocityX * vectorMinutes / (3600 * Math.cos(f.latitude * Math.PI / 180));

            const startPt = map.latLngToLayerPoint([f.latitude, f.longitude]);
            const endPt = map.latLngToLayerPoint([f.latitude + dLat, f.longitude + dLon]);

            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(startPt.x - topLeft.x, startPt.y - topLeft.y);
            ctx.lineTo(endPt.x - topLeft.x, endPt.y - topLeft.y);
            ctx.stroke();
        }
    }

    // ── DRI halos (QP command — 5nm standard or 3nm reduced) ──
    if (driActive.size > 0) {
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 1.0;
        for (const [gufi, driType] of driActive) {
            const f = flights.get(gufi);
            if (!f || f.latitude == null || f.longitude == null) continue;
            if (!isVisible(f)) continue;
            if (isDedupHidden(gufi, f)) continue;
            if (!bounds.contains([f.latitude, f.longitude])) continue;

            const radiusNm = driType === 'T' ? 3 : 5;
            const radiusDeg = radiusNm / 60; // 1 NM = 1/60 degree latitude
            const centerPt = map.latLngToLayerPoint([f.latitude, f.longitude]);
            const edgePt = map.latLngToLayerPoint([f.latitude + radiusDeg, f.longitude]);
            const radiusPx = Math.abs(centerPt.y - edgePt.y);
            const cx = centerPt.x - topLeft.x;
            const cy = centerPt.y - topLeft.y;
            const color = isEmergency(f) ? EMRG_COLOR : TRACK_COLOR;
            ctx.strokeStyle = color;

            if (driType === 'T') {
                // Reduced DRI: circle with 4 gaps (at N, E, S, W)
                const gapAngle = Math.PI / 12; // 15° gap at each cardinal
                for (let q = 0; q < 4; q++) {
                    const cardinal = -Math.PI / 2 + q * Math.PI / 2; // N, E, S, W
                    ctx.beginPath();
                    ctx.arc(cx, cy, radiusPx, cardinal + gapAngle, cardinal + Math.PI / 2 - gapAngle);
                    ctx.stroke();
                }
            } else {
                // Standard DRI: full circle
                ctx.beginPath();
                ctx.arc(cx, cy, radiusPx, 0, 2 * Math.PI);
                ctx.stroke();
            }
        }
    }

    // ── .FIND highlight — blinking yellow square (full ↔ half bright) ──
    if (findMarker && bounds.contains([findMarker.lat, findMarker.lon])) {
        const blinkPhase = Math.floor(performance.now() / 500) % 2 === 0;
        const pt = map.latLngToLayerPoint([findMarker.lat, findMarker.lon]);
        const x = pt.x - topLeft.x;
        const y = pt.y - topLeft.y;
        const sz = Math.round(fontSize * 0.8);
        ctx.globalAlpha = blinkPhase ? 1.0 : 0.4;
        ctx.strokeStyle = TRACK_COLOR;
        ctx.lineWidth = 1.5;
        ctx.strokeRect(x - sz / 2, y - sz - 2, sz, sz);
        // Label below — always full bright
        ctx.globalAlpha = 0.9;
        ctx.fillStyle = TRACK_COLOR;
        ctx.fillText(findMarker.ident, x, y + LINE_H);
    }

    ctx.globalAlpha = 1;
}

// Clear canvas immediately on zoom start to prevent ghost shadows
map.on('zoomstart', () => {
    const ctx = overlayCanvas.getContext('2d');
    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
});

let _overlayRafPending = false;
map.on('move zoom viewreset resize', () => {
    if (!_overlayRafPending) {
        _overlayRafPending = true;
        requestAnimationFrame(() => {
            _overlayRafPending = false;
            try { drawOverlay(); } catch(e) { console.error('[Overlay]', e); }
        });
    }
});

// ════════════════════════════════════════════════════════════════════════════
// KML sector boundaries (video maps — grey)
// ════════════════════════════════════════════════════════════════════════════
let kmlSectors = [];
const boundaryLayers = {};        // keyed by 'ARTCC:category'
let activeBoundaryArtcc = '';
const BOUNDARY_CATS = ['Ultra High', 'High Altitude', 'Low Altitude', 'Approach Control'];
const BOUNDARY_CAT_LABELS = { 'Ultra High': 'UHI', 'High Altitude': 'HI', 'Low Altitude': 'LO', 'Approach Control': 'APP' };
const BOUNDARY_CAT_SLIDER = { 'Ultra High': 'rng-bnd-uhi', 'High Altitude': 'rng-bnd-hi', 'Low Altitude': 'rng-bnd-lo', 'Approach Control': 'rng-bnd-app' };
const BOUNDARY_CAT_LABEL = { 'Ultra High': 'lbl-bnd-uhi', 'High Altitude': 'lbl-bnd-hi', 'Low Altitude': 'lbl-bnd-lo', 'Approach Control': 'lbl-bnd-app' };
let boundaryBrightness = { 'Ultra High': 60, 'High Altitude': 60, 'Low Altitude': 60, 'Approach Control': 0 };

function bndColor(brightness) {
    const v = Math.round(brightness * 2.55);
    return `rgb(${v},${v},${v})`;
}

async function loadKml() {
    try {
        const resp = await fetch('/api/kml/AllSectors.kml');
        if (!resp.ok) return;
        const text = await resp.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'text/xml');
        const placemarks = xml.querySelectorAll('Placemark');

        for (const pm of placemarks) {
            const name = pm.querySelector('name')?.textContent || '';
            const desc = pm.querySelector('description')?.textContent || '';
            const coordEl = pm.querySelector('coordinates');
            if (!coordEl) continue;

            const descDoc = new DOMParser().parseFromString(desc, 'text/html');
            const tds = descDoc.querySelectorAll('td');
            const data = {};
            for (let i = 0; i < tds.length - 1; i += 2) {
                data[tds[i].textContent.trim()] = tds[i + 1].textContent.trim();
            }

            const folderPath = data['FolderPath'] || '';
            const parts = folderPath.split('/');
            let artcc = parts.length >= 2 ? parts[1] : '';
            let category = '';
            let sectorId = name;

            if (artcc) {
                // Standard format: FolderPath = "xxx/ZDC/High Altitude (17)/sectorId"
                const catRaw = parts.length >= 3 ? parts[2] : '';
                category = catRaw.replace(/\s*\(\d+\)$/, '');
                sectorId = parts.length >= 4 ? parts[3] : name;
            } else {
                // Western ARTCCs: no FolderPath, derive from ancestor Folder names
                // e.g. Folder "ZLA_HIGH_NEW" → artcc=ZLA, category=High Altitude
                let el = pm.parentElement;
                while (el) {
                    const fn = el.tagName === 'Folder' ? (el.querySelector(':scope > name')?.textContent || '') : '';
                    const m = fn.match(/^(Z[A-Z]{2})[_ ]/);
                    if (m) {
                        artcc = m[1];
                        const upper = fn.toUpperCase();
                        if (upper.includes('ULTRA')) category = 'Ultra High';
                        else if (upper.includes('HIGH')) category = 'High Altitude';
                        else if (upper.includes('LOW')) category = 'Low Altitude';
                        else if (upper.includes('APPROACH')) category = 'Approach Control';
                        else category = 'High Altitude';
                        break;
                    }
                    el = el.parentElement;
                }
            }
            if (!artcc) continue;

            const coords = coordEl.textContent.trim().split(/\s+/).map(c => {
                const [lon, lat] = c.split(',');
                return [parseFloat(lat), parseFloat(lon)];
            }).filter(c => !isNaN(c[0]) && !isNaN(c[1]));

            if (coords.length < 2) continue;
            kmlSectors.push({ artcc, name, sectorId, alt: data['ALT'] || '', category, coords });
        }
        const catCounts = {};
        for (const s of kmlSectors) catCounts[s.category] = (catCounts[s.category] || 0) + 1;
        console.log(`[KML] Loaded ${kmlSectors.length} sectors`, catCounts);
        // Clear any boundary layers cached before KML finished (they'd be empty)
        for (const key in boundaryLayers) {
            if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
            delete boundaryLayers[key];
        }
        if (myFacility) showBoundariesForFacility(myFacility);
    } catch (e) { console.warn('[KML]', e); }
}

function showBoundariesForFacility(artcc) {
    // Remove all layers for the previous ARTCC
    if (activeBoundaryArtcc) {
        for (const cat of BOUNDARY_CATS) {
            const key = `${activeBoundaryArtcc}:${cat}`;
            if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
        }
    }
    activeBoundaryArtcc = artcc;
    if (!artcc) return;

    for (const cat of BOUNDARY_CATS) {
        const br = boundaryBrightness[cat];
        if (br <= 0) continue;
        const key = `${artcc}:${cat}`;
        if (!boundaryLayers[key]) {
            const group = L.layerGroup();
            for (const sec of kmlSectors.filter(s => s.artcc === artcc && s.category === cat)) {
                L.polyline(sec.coords, { color: bndColor(br), weight: 1, opacity: 1, interactive: false, className: 'bnd-path' }).addTo(group);
            }
            boundaryLayers[key] = group;
        }
        boundaryLayers[key].addTo(map);
    }
}

function setBoundaryBrightness(cat, brightness) {
    boundaryBrightness[cat] = brightness;
    if (!activeBoundaryArtcc) return;
    const key = `${activeBoundaryArtcc}:${cat}`;
    if (brightness <= 0) {
        if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
        return;
    }
    const col = bndColor(brightness);
    if (!boundaryLayers[key]) {
        const group = L.layerGroup();
        for (const sec of kmlSectors.filter(s => s.artcc === activeBoundaryArtcc && s.category === cat)) {
            L.polyline(sec.coords, { color: col, weight: 1, opacity: 1, interactive: false, className: 'bnd-path' }).addTo(group);
        }
        boundaryLayers[key] = group;
        boundaryLayers[key].addTo(map);
    } else {
        // Update color on existing polylines
        boundaryLayers[key].eachLayer(l => l.setStyle({ color: col }));
        if (!map.hasLayer(boundaryLayers[key])) boundaryLayers[key].addTo(map);
    }
}

function zoomToFacility(artcc) {
    if (!artcc || kmlSectors.length === 0) return;
    const sectors = kmlSectors.filter(s => s.artcc === artcc);
    if (sectors.length === 0) return;
    let minLat = 90, maxLat = -90, minLon = 180, maxLon = -180;
    for (const sec of sectors) {
        for (const [lat, lon] of sec.coords) {
            if (lat < minLat) minLat = lat;
            if (lat > maxLat) maxLat = lat;
            if (lon < minLon) minLon = lon;
            if (lon > maxLon) maxLon = lon;
        }
    }
    map.fitBounds([[minLat, minLon], [maxLat, maxLon]], { padding: [20, 20] });
}

loadKml();

// ════════════════════════════════════════════════════════════════════════════
// NASR overlay layers (airways, VORs, SID/STARs)
// ════════════════════════════════════════════════════════════════════════════
const nasrLayers = {};    // 'jroutes'|'vroutes'|'vors'|'proc:DCA' → L.layerGroup
const nasrCache = {};     // same keys → raw API data (cache across toggles)
const nasrBrightness = { jroutes: 0, vroutes: 0, vors: 0, proc: 0 };

const nasrLoading = {};   // guard against double-click during async fetch
function nasrColor(brightness) { return bndColor(brightness); }  // same grey ramp as boundaries

async function showNasrLayer(layerKey, url, renderer) {
    const br = nasrBrightness[layerKey];
    if (br <= 0) {
        if (nasrLayers[layerKey]) { map.removeLayer(nasrLayers[layerKey]); delete nasrLayers[layerKey]; }
        return;
    }
    // Already showing — just update color
    if (nasrLayers[layerKey]) {
        const col = nasrColor(br);
        nasrLayers[layerKey].eachLayer(l => l.setStyle({ color: col }));
        return;
    }
    if (nasrLoading[layerKey]) return;
    // Fetch data (cached)
    if (!nasrCache[layerKey]) {
        nasrLoading[layerKey] = true;
        try {
            const resp = await fetch(url);
            if (!resp.ok) { console.warn(`[NASR] ${layerKey}: ${resp.status}`); delete nasrLoading[layerKey]; return; }
            nasrCache[layerKey] = await resp.json();
        } catch (e) { console.warn(`[NASR] ${layerKey}:`, e); delete nasrLoading[layerKey]; return; }
        delete nasrLoading[layerKey];
    }
    // Re-check brightness after async fetch (slider may have changed to 0)
    const finalBr = nasrBrightness[layerKey];
    if (finalBr <= 0) return;
    const group = L.layerGroup();
    renderer(nasrCache[layerKey], group, finalBr);
    nasrLayers[layerKey] = group;
    group.addTo(map);
}

function renderAirways(data, group, br) {
    const col = nasrColor(br);
    for (const awy of data) {
        if (awy.points.length < 2) continue;
        L.polyline(awy.points, { color: col, weight: 1, opacity: 1, interactive: false, className: 'bnd-path' }).addTo(group);
    }
}

function renderVors(data, group, br) {
    const col = nasrColor(br);
    for (const vor of data) {
        L.circleMarker([vor.lat, vor.lon], {
            radius: 4, color: col, weight: 1, opacity: 1, fill: false, interactive: false, className: 'bnd-path'
        }).addTo(group);
    }
}

function setupNasrSlider(sliderId, labelId, layerKey, url, renderer) {
    document.getElementById(sliderId).addEventListener('input', function () {
        nasrBrightness[layerKey] = parseInt(this.value);
        document.getElementById(labelId).textContent = nasrBrightness[layerKey];
        showNasrLayer(layerKey, url, renderer);
        saveSettingsToUrl();
    });
}
setupNasrSlider('rng-jroutes', 'lbl-jroutes', 'jroutes', '/api/nasr/airways?type=hi', renderAirways);
setupNasrSlider('rng-vroutes', 'lbl-vroutes', 'vroutes', '/api/nasr/airways?type=lo', renderAirways);
setupNasrSlider('rng-vors', 'lbl-vors', 'vors', '/api/nasr/navaids', renderVors);

// Procedure overlay — managed via .SID/.STAR/.PROC MCA commands
// activeProcedures: Map<string, { layer: L.layerGroup, procs: Array, query: string }>
const activeProcedures = new Map();

function renderProcedureLegs(data, group, br) {
    const col = nasrColor(br);
    for (const proc of data) {
        for (const leg of proc.legs) {
            if (leg.length >= 2) {
                L.polyline(leg, { color: col, weight: 1, opacity: 1, dashArray: '6 4', interactive: false, className: 'bnd-path' }).addTo(group);
            }
        }
    }
}

document.getElementById('rng-proc').addEventListener('input', function () {
    nasrBrightness.proc = parseInt(this.value);
    document.getElementById('lbl-proc').textContent = nasrBrightness.proc;
    const col = nasrColor(nasrBrightness.proc);
    for (const [key, entry] of activeProcedures) {
        if (nasrBrightness.proc <= 0) {
            if (map.hasLayer(entry.layer)) map.removeLayer(entry.layer);
        } else {
            if (!map.hasLayer(entry.layer)) entry.layer.addTo(map);
            entry.layer.eachLayer(l => l.setStyle({ color: col }));
        }
    }
    saveSettingsToUrl();
});

function clearProcOverlay() {
    for (const [key, entry] of activeProcedures) {
        if (map.hasLayer(entry.layer)) map.removeLayer(entry.layer);
    }
    activeProcedures.clear();
}

// ════════════════════════════════════════════════════════════════════════════
// MRMS weather radar overlay — ERAM-style pixel rendering
// Source: NOAA nowCOAST WMS (MRMS base reflectivity composite)
// https://nowcoast.noaa.gov/geoserver/observations/weather_radar/ows
// Updates every ~4 minutes, CORS-enabled, transparent PNG tiles
// NWS standard radar colors → parsed on canvas → remapped to ERAM categories:
//   Moderate (20-40 dBZ, NWS greens/yellows) → solid blue #0044ff
//   Heavy (40-55 dBZ, NWS oranges/reds) → checkered cyan #00ccff / black
//   Extreme (55+ dBZ, NWS dark reds/magentas) → solid cyan #00ccff
// ════════════════════════════════════════════════════════════════════════════
let nexradLayer = null;
let nexradLevel = 0;           // 0=OFF, 1=extreme(3), 2=heavy+extreme(23), 3=all(123)
let nexradBrightness = 50;
const MRMS_WMS_URL = 'https://nowcoast.noaa.gov/geoserver/observations/weather_radar/ows';

// Classify NWS radar pixel to ERAM NEXRAD level (0=none, 1=moderate, 2=heavy, 3=extreme)
// NWS palette: cyan/blue (<20 dBZ) → green (20-35) → yellow (35-45) → orange/red (45+)
// ERAM mapping: green→blue, yellow→checkered, red→cyan
function classifyNwsPixel(r, g, b, a) {
    if (a < 128) return 0;                              // filter anti-aliased edges
    const max = Math.max(r, g, b), min = Math.min(r, g, b);
    if (max < 30) return 0;
    const delta = max - min;
    if (delta < 15) return 0;                            // filter greys/unsaturated
    // Compute hue 0-360
    let h;
    if (max === r) h = 60 * (((g - b) / delta) % 6);
    else if (max === g) h = 60 * ((b - r) / delta + 2);
    else h = 60 * ((r - g) / delta + 4);
    if (h < 0) h += 360;
    // Cyan through blue (190-270): moderate (ERAM blue)
    if (h >= 190 && h <= 270) return 1;
    // Light cyan (150-190): moderate (fill transition between green and blue)
    if (h >= 150 && h < 190) return 1;
    // Green (80-150): split by brightness — bright green = moderate, dark green = heavy
    if (h >= 80 && h < 150) {
        return (max / 255) > 0.85 ? 1 : 2;             // bright green ~20-22 dBZ moderate, dark green ~23-35 dBZ heavy
    }
    // Yellow/gold (75-80): heavy (checkered cyan/black)
    if (h >= 75 && h < 80) return 2;
    // Orange/yellow (15-75) / red / magenta: extreme (solid cyan)
    return 3;
}

const MrmsEramLayer = L.GridLayer.extend({
    createTile: function (coords, done) {
        const tile = document.createElement('canvas');
        tile.width = tile.height = 256;
        const ctx = tile.getContext('2d');
        const level = this.options.nxLevel || 3;
        // Build WMS GetMap URL
        const bounds = this._tileCoordsToBounds(coords);
        const sw = bounds.getSouthWest(), ne = bounds.getNorthEast();
        const bbox = `${sw.lng},${sw.lat},${ne.lng},${ne.lat}`;
        const url = `${MRMS_WMS_URL}?service=WMS&version=1.1.1&request=GetMap` +
            `&layers=conus_base_reflectivity_mosaic&srs=EPSG:4326` +
            `&bbox=${bbox}&width=256&height=256&format=image/png&transparent=true`;
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => {
            ctx.drawImage(img, 0, 0, 256, 256);
            // Remap NWS colors to ERAM categories
            const imageData = ctx.getImageData(0, 0, 256, 256);
            const d = imageData.data;
            for (let i = 0; i < d.length; i += 4) {
                const cat = classifyNwsPixel(d[i], d[i + 1], d[i + 2], d[i + 3]);
                if (cat === 0) { d[i + 3] = 0; continue; }
                // NX LVL filtering: 1=extreme only, 2=heavy+extreme, 3=all
                if (level === 1 && cat < 3) { d[i + 3] = 0; continue; }
                if (level === 2 && cat < 2) { d[i + 3] = 0; continue; }
                const px = i / 4;
                const tx = px % 256, ty = Math.floor(px / 256);
                if (cat === 1) {
                    // Moderate: solid blue (#0044ff)
                    d[i] = 0; d[i + 1] = 68; d[i + 2] = 255;
                } else if (cat === 2) {
                    // Heavy: checkered cyan (#00ccff) and black
                    if ((Math.floor(tx / 4) + Math.floor(ty / 4)) % 2 === 0) {
                        d[i] = 0; d[i + 1] = 204; d[i + 2] = 255;
                    } else {
                        d[i] = 0; d[i + 1] = 0; d[i + 2] = 0;
                    }
                } else {
                    // Extreme: solid cyan (#00ccff)
                    d[i] = 0; d[i + 1] = 204; d[i + 2] = 255;
                }
                d[i + 3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
            done(null, tile);
        };
        img.onerror = () => done(null, tile);  // blank tile on error
        img.src = url;
        return tile;
    }
});

function createNexradLayer() {
    return new MrmsEramLayer({
        pane: 'nexrad',
        opacity: nexradBrightness / 100,
        maxZoom: 16,
        tileSize: 256,
        nxLevel: nexradLevel,
    });
}

function updateNexrad() {
    if (nexradLayer) { map.removeLayer(nexradLayer); nexradLayer = null; }
    if (nexradLevel === 0) return;
    nexradLayer = createNexradLayer();
    nexradLayer.addTo(map);
}

// Auto-refresh every 5 minutes (nowCOAST updates every ~4 min)
if (nexradLevel > 0) updateNexrad();
setInterval(() => {
    if (nexradLayer) { map.removeLayer(nexradLayer); nexradLayer = createNexradLayer(); nexradLayer.addTo(map); }
}, 5 * 60 * 1000);

document.getElementById('sel-nxlvl').addEventListener('change', function () {
    const v = this.value;
    nexradLevel = v === '123' ? 3 : v === '23' ? 2 : v === '3' ? 1 : 0;
    updateNexrad();
    saveSettingsToUrl();
});

document.getElementById('rng-nx').addEventListener('input', function () {
    nexradBrightness = parseInt(this.value);
    document.getElementById('lbl-nx').textContent = nexradBrightness;
    if (nexradLayer) nexradLayer.setOpacity(nexradBrightness / 100);
    saveSettingsToUrl();
});

// ════════════════════════════════════════════════════════════════════════════
// Visibility & classification
// ════════════════════════════════════════════════════════════════════════════
function isEmergency(f) {
    return f.squawk === '7700' || f.squawk === '7600' || f.squawk === '7500';
}

function isVisible(f) {
    if (f.latitude == null || f.longitude == null) return false;
    // Allow DROPPED flights if they're the best GUFI for their callsign (handoff transition:
    // old center dropped the track but new center hasn't sent position yet)
    if (f.flightStatus === 'CANCELLED') return false;
    if (f.flightStatus && f.flightStatus !== 'ACTIVE' && f.flightStatus !== 'DROPPED') return false;

    // Altitude filter (reported altitude in feet → FL in hundreds)
    // FDB tracks are exempt — own, handoff, emergency, user-forced, and quick look tracks always show
    if (altFilterLow > 0 || altFilterHigh < 999) {
        const cls = classifyTrack(f);
        if (!shouldShowFdb(f.gufi, cls)) {
            const alt = f.reportedAltitude;
            if (alt != null) {
                const fl = Math.round(alt / 100);
                if (fl < altFilterLow || fl > altFilterHigh) return false;
            }
        }
    }

    // No facility selected → show all
    if (!myFacility) return true;
    // Show if controlling/reporting facility matches
    // In facilityOnly mode, only controllingFacility counts — reportingFacility alternates
    // between centers on each SFDPS update, causing flicker if used for strict filtering
    const fac = f.controllingFacility || '';
    const rptFac = f.reportingFacility || '';
    if (fac === myFacility || (!facilityOnly && rptFac === myFacility)) return true;
    // Show if handoff involves our facility
    if (f.handoffReceiving && extractFac(f.handoffReceiving) === myFacility) return true;
    if (f.handoffTransferring && extractFac(f.handoffTransferring) === myFacility) return true;
    // "Facility only" — strict mode: only show aircraft reported by our facility (above checks)
    if (facilityOnly) return false;
    // Keep flights visible that were previously own/ho (prevents disappearing during handoff transitions)
    if (wasOwnOrHo.has(f.gufi)) return true;
    // Keep flights visible that have a recent completed handoff involving us
    if (hoCompletedInfo.has(f.gufi)) return true;
    // Grace period: keep recently-visible flights for 120s to prevent flicker on facility field changes
    const lastVis = lastVisibleAt.get(f.gufi);
    if (lastVis && performance.now() - lastVis < 120000) return true;
    return false;
}

function classifyTrack(f) {
    if (isEmergency(f)) return 'emrg';
    if (!myFacility) return 'other';
    // Sectors must be selected to have own/ho tracks — prevents entire ARTCC from being FDB
    if (mySectors.size === 0) return 'other';

    const fac = f.controllingFacility || f.reportingFacility || '';
    const sec = f.controllingSector || '';
    const hoEvt = hoEventType(f.handoffEvent);

    // Active handoff involving our sector(s)
    if (hoEvt) {
        const recvFac = extractFac(f.handoffReceiving);
        const xferFac = extractFac(f.handoffTransferring);
        const recvSec = extractSec(f.handoffReceiving);
        const xferSec = extractSec(f.handoffTransferring);
        const recvIsMe = recvFac === myFacility && mySectors.has(recvSec);
        const xferIsMe = xferFac === myFacility && mySectors.has(xferSec);
        if (recvIsMe || xferIsMe) return 'ho';
    }

    if (fac === myFacility && mySectors.has(sec)) return 'own';
    return 'other';
}

function extractFac(unitStr) { return unitStr ? unitStr.split('/')[0] : ''; }
function extractSec(unitStr) { if (!unitStr) return ''; const p = unitStr.split('/'); return p.length > 1 ? p[1] : ''; }

// Get CID for the observed facility (each ARTCC assigns its own CID to a flight)
function getCid(f) {
    if (myFacility) return (f.computerIds && f.computerIds[myFacility]) || '';
    return f.computerId || '';
}

// Handoff event classification — SFDPS sends INITIATION/ACCEPTANCE/UPDATE/EXECUTION
function hoEventType(evt) {
    if (!evt) return '';
    const e = evt.toUpperCase();
    if (e === 'INITIATION' || e.startsWith('PROPOS')) return 'PROPOSED';
    if (e === 'ACCEPTANCE' || e.startsWith('ACCEPT')) return 'ACCEPTED';
    if (e === 'UPDATE') return 'PROPOSED';  // UPDATE during active handoff — treat as proposed
    if (e.startsWith('EXECUT')) return 'EXECUTING';
    return '';  // CANCELLATION, COMPLETED, etc. — not active
}

// ════════════════════════════════════════════════════════════════════════════
// ERAM Full Data Block formatting
// ════════════════════════════════════════════════════════════════════════════
//
// Line 0: P/A (point out) — above data block
// Column 0: R (not your control) — left of data block, bulges out
// Line 1: Field A (callsign) + SatComm (*)
// Line 2: Field B (assigned alt) + status char + Field C (reported alt)
// Line 3: Field D (CID) + Field E (GS/Hxxx/Oxxx/EMRG)
// Line 4: Field F (destination ICAO)
//
// Status chars: C=conforming(hide Field C), T=interim, L=local interim,
//   P=procedure, ↑=climbing, ↓=descending, +=above, -=below,
//   X=no Mode C, N=no target, B=block alt, /=VFR

const LDR_DX = 20;
const LDR_DY = 0;   // flat horizontal leader line (ERAM default position 5 = right)
const LDR_LEN = 40; // leader line length
let CHAR_W = fontSize * 0.625;  // approx char width in ERAM font
let LINE_H = fontSize * 1.25;   // line-height

// Data block position offsets (numpad layout):
//   7=NW  8=N   9=NE
//   4=W   5=def 6=E
//   1=SW  2=S   3=SE
function getLeaderOffset(gufi) {
    const pos = dbPositions.get(gufi);
    const level = ldrLenOverrides.get(gufi) ?? 1;
    const len = level * LDR_LEN;
    if (len === 0) return { dx: 0, dy: 0 };
    const D = len * 0.707; // diagonal distance
    if (!pos || pos === 9) return { dx: D, dy: -D };             // NE (default)
    switch (pos) {
        case 1: return { dx: -D, dy: D };      // SW
        case 2: return { dx: 0, dy: len };      // S
        case 3: return { dx: D, dy: D };        // SE
        case 4: return { dx: -len, dy: 0 };     // W
        case 5:
        case 6: return { dx: len, dy: 0 };      // E
        case 7: return { dx: -D, dy: -D };      // NW
        case 8: return { dx: 0, dy: -len };     // N
        case 9: return { dx: D, dy: -D };       // NE
        default: return { dx: D, dy: -D };     // NE (default)
    }
}

// Position data block so the leader line endpoint aligns with the correct edge/line.
// FDB anchor varies by direction:
//   N:  left edge, between lines 3-4    NE: left edge, between lines 2-3
//   E:  left edge, between lines 2-3    SE: left edge, between lines 1-2
//   S:  left edge, between lines 1-2    SW: right edge, between lines 1-2
//   W:  right edge, between lines 2-3   NW: right edge, between lines 2-3
// xShift: 0 = left-aligned (text extends right), -1 = right-aligned (text extends left)
function getDbAnchor(gufi, numLines) {
    const pos = dbPositions.get(gufi) || 9;
    const isLeft = (pos === 1 || pos === 4 || pos === 7);

    if (numLines === 2) {
        // LDB: anchor between lines 1-2 for all directions
        return { xShift: isLeft ? -1 : 0, yShift: -LINE_H };
    }

    // FDB (4 lines): direction-specific anchor
    switch (pos) {
        case 8: return { xShift: 0,  yShift: -3 * LINE_H };  // N:  left edge, between 3-4
        case 9: return { xShift: 0,  yShift: -2 * LINE_H };  // NE: left edge, between 2-3
        case 5:
        case 6: return { xShift: 0,  yShift: -2 * LINE_H };  // E:  left edge, between 2-3
        case 3: return { xShift: 0,  yShift: -LINE_H };       // SE: left edge, between 1-2
        case 2: return { xShift: 0,  yShift: -LINE_H };       // S:  left edge, between 1-2
        case 1: return { xShift: -1, yShift: -LINE_H };       // SW: right edge, between 1-2
        case 4: return { xShift: -1, yShift: -2 * LINE_H };   // W:  right edge, between 2-3
        case 7: return { xShift: -1, yShift: -2 * LINE_H };   // NW: right edge, between 2-3
        default: return { xShift: 0, yShift: -2 * LINE_H };
    }
}

// Check if flight is in reduced separation area (at or below FL230)
function isReducedSep(f) {
    const alt = f.reportedAltitude ?? f.assignedAltitude;
    return alt != null && alt <= 23000;
}

function getSymbolClass(f) {
    // Reduced separation: at or below FL230 → dot
    if (f.callsign && isReducedSep(f)) return 'ac-sym-reduced-sep';
    // SFDPS en route flights are virtually all transponder-equipped correlated targets.
    if (f.callsign) return 'ac-sym-corr-bcn';      // \ Correlated Beacon (most common)
    if (f.squawk) return 'ac-sym-uncorr-bcn';       // / Uncorrelated Beacon
    return 'ac-sym-flat-track';                      // ◇ Unknown/no identification
}

// History symbol character per target type (drawn on canvas)
function getSymbolChar(f) {
    // Reduced separation: at or below FL230 → dot
    if (f.callsign && isReducedSep(f)) return '\u2022';  // • dot
    if (f.callsign) return '\\';   // Correlated Beacon (most common)
    if (f.squawk) return '/';      // Uncorrelated Beacon
    return '\u25C7';               // ◇ Unknown
}

// Should column 0 "R" indicator show? (track not under our control)
// R = position does not own the track:
//   - Outgoing ACCEPTED/completed: we gave it away → R
//   - Incoming PROPOSED: offered to us but not yet accepted → R
//   - Incoming ACCEPTED/completed: we accepted, we own it → no R
//   - Outgoing PROPOSED: we initiated but still own it → no R
//   - Other tracks not ours at all → R
function shouldShowR(f, cls) {
    if (!myFacility || mySectors.size === 0) return false;
    if (cls === 'emrg') return false;

    // Controlling sector is authoritative — trust what SFDPS says
    if (cls === 'own') return false;
    const ctrlFac = f.controllingFacility || '';
    const ctrlSec = f.controllingSector || '';
    if (ctrlFac === myFacility && mySectors.has(ctrlSec)) return false;

    // Active handoff involving our sector(s)
    const hoEvt = hoEventType(f.handoffEvent);
    if (hoEvt && f.handoffReceiving) {
        const recvFac = extractFac(f.handoffReceiving);
        const recvSec = extractSec(f.handoffReceiving);
        const xferFac = extractFac(f.handoffTransferring);
        const xferSec = extractSec(f.handoffTransferring);
        const recvIsMe = recvFac === myFacility && mySectors.has(recvSec);
        const xferIsMe = xferFac === myFacility && mySectors.has(xferSec);

        if (xferIsMe && hoEvt === 'PROPOSED') return false;  // We initiated, still own it
        if (xferIsMe && hoEvt === 'ACCEPTED') return true;   // We gave it away
        if (recvIsMe && hoEvt === 'PROPOSED') return true;    // Incoming, not yet accepted
        if (recvIsMe && hoEvt === 'ACCEPTED') return false;   // We accepted, we own it
    }

    // Completed handoff — informational (O display), R follows controlling sector above
    const completed = hoCompletedInfo.get(f.gufi);
    if (completed) {
        const recvIsMe = extractFac(completed.receiving) === myFacility && mySectors.has(extractSec(completed.receiving));
        if (recvIsMe) return false;  // Incoming completed — we now own it, no R
        const xferIsMe = extractFac(completed.transferring) === myFacility && mySectors.has(extractSec(completed.transferring));
        if (xferIsMe) return true;   // Outgoing completed — show R
    }

    // Default: R for any track we don't own
    return true;
}

// Determine if a track should show FDB (full data block) or LDB (limited)
function shouldShowFdb(gufi, cls) {
    // User override takes priority
    if (fdbOverrides.has(gufi)) return fdbOverrides.get(gufi);
    // Quick Look sectors: force FDB on tracks in QL'd sectors
    if (quickLookSectors.size > 0) {
        const f = flights.get(gufi);
        if (f) {
            const sec = f.controllingSector || '';
            if (quickLookSectors.has(sec)) return true;
        }
    }
    // Point-out tracks force FDB
    {
        const f = flights.get(gufi);
        if (f && getPointoutIndicator(f)) return true;
    }
    // Default: own and handoff tracks get FDB, others get LDB
    return cls === 'own' || cls === 'ho' || cls === 'emrg';
}

// Dwell emphasis helpers — apply/remove box + LDB brightness boost
function applyDwell(el, gufi) {
    const dbEl = el.querySelector('.ac-db');
    if (!dbEl) return;
    dbEl.classList.add('dwell');
    // FDB: add a real border element sized from actual DOM measurements
    if (dbEl.classList.contains('fdb') && !dbEl.querySelector('.dwell-border')) {
        const b = document.createElement('div');
        b.className = 'dwell-border';
        const w = dbEl.offsetWidth;
        const h = dbEl.offsetHeight;
        const chOff = Math.round(CHAR_W * 2.2); // past column 0 + VCI, scales with font size
        b.style.cssText = `left:${chOff}px;top:-1px;width:${w - chOff + 2}px;height:${h + 2}px;`;
        dbEl.appendChild(b);
    }
    const f = flights.get(gufi);
    if (f && !shouldShowFdb(gufi, classifyTrack(f))) dbEl.style.opacity = '1';
}
function removeDwell(el, gufi) {
    const dbEl = el.querySelector('.ac-db');
    if (!dbEl) return;
    dbEl.classList.remove('dwell');
    const b = dbEl.querySelector('.dwell-border');
    if (b) b.remove();
    const f = flights.get(gufi);
    if (f && !shouldShowFdb(gufi, classifyTrack(f))) dbEl.style.opacity = String(ldbBrightness / 100);
}

// Build target symbol as pure CSS geometry — no font metrics, pixel-perfect centering at (0,0)
function buildTargetSym(symChar, isEmrg, extraStyle) {
    const c = isEmrg ? '#ff4444' : '#cccc44';
    const st = extraStyle ? extraStyle + ';' : '';
    // Invisible 16×16 hit area centered at (0,0) so thin symbols are easy to click
    const hit = `<div style="position:absolute;width:16px;height:16px;left:-8px;top:-8px;pointer-events:auto;cursor:inherit;z-index:2;"></div>`;
    if (symChar === '\\') {
        // Correlated beacon: 2px × 14px line, rotate(-45deg) = backslash \
        return hit + `<div style="position:absolute;width:2px;height:14px;left:-1px;top:-7px;background:${c};transform:rotate(-45deg);pointer-events:none;z-index:2;${st}"></div>`;
    }
    if (symChar === '/') {
        // Uncorrelated beacon: 2px × 14px line, rotate(45deg) = forward slash /
        return hit + `<div style="position:absolute;width:2px;height:14px;left:-1px;top:-7px;background:${c};transform:rotate(45deg);pointer-events:none;z-index:2;${st}"></div>`;
    }
    if (symChar === '\u2022') {
        // Reduced separation: 5px filled circle centered at (0,0)
        return hit + `<div style="position:absolute;width:5px;height:5px;left:-2.5px;top:-2.5px;border-radius:50%;background:${c};pointer-events:none;z-index:2;${st}"></div>`;
    }
    // Diamond (◇): FDB draws via ac-sym-flat-track; LDB still needs a hit area
    return hit;
}

function buildMarkerHtml(f, cls) {
    const isEmrg = cls === 'emrg';
    const emrgCls = isEmrg ? ' emrg' : '';

    const symChar = getSymbolChar(f);

    if (!showFdb) {
        // Data blocks off — just target symbol + diamond
        let html = buildTargetSym(symChar, isEmrg);
        html += `<div class="ac-sym-flat-track${emrgCls}"></div>`;
        return html;
    }

    const useFdb = shouldShowFdb(f.gufi, cls);

    // FDB: diamond + symbol; LDB: just the symbol character (no diamond)
    let html;
    if (useFdb) {
        html = buildTargetSym(symChar, isEmrg);
        html += `<div class="ac-sym-flat-track${emrgCls}"></div>`;
    } else {
        const ldbOp = ldbBrightness / 100;
        html = buildTargetSym(symChar, isEmrg, `opacity:${ldbOp}`);
    }

    const color = isEmrg ? EMRG_COLOR : TRACK_COLOR;
    const ldr = getLeaderOffset(f.gufi);
    const numLines = useFdb ? 4 : 2;
    const anchor = getDbAnchor(f.gufi, numLines);
    const isLeftPos = anchor.xShift === -1;
    const pos = dbPositions.get(f.gufi) || 9;
    const isVertical = (pos === 2 || pos === 8);

    // Gap from leader endpoint to data block (Column 0 is inline, provides visual separation)
    const dbGap = Math.ceil(CHAR_W * 0.5);

    // Compute data block CSS position
    let leftStyle;
    if (isLeftPos) leftStyle = `right:${-ldr.dx + dbGap}px`;
    else if (isVertical) leftStyle = `left:${ldr.dx - Math.round(CHAR_W * 1.5) - 2}px`;  // N/S: col0 sits left of leader endpoint
    else leftStyle = `left:${ldr.dx + dbGap}px`;

    // Left-positioned blocks: fixed min-width to prevent jitter during flash
    const leftExtra = isLeftPos ? ` min-width:${Math.ceil(CHAR_W * 9.5)}px;` : '';

    if (useFdb) {
        // Full Data Block (lines 1-4) — with leader line
        const showR = shouldShowR(f, cls);
        const showVci = vciActive.has(f.gufi);
        // Leader extends into col0 area for right-side positions (E/NE/SE)
        let ldrX2 = ldr.dx, ldrY2 = ldr.dy;
        if (!isLeftPos && !isVertical && ldr.dx !== 0) {
            if (showR || showVci) {
                // R/VCI present: end just before the character (left edge of col0)
                ldrX2 += dbGap;
            } else {
                // No R/VCI: extend through empty col0 to reach text
                ldrX2 += dbGap + Math.round(CHAR_W * 1.5);
            }
        }
        html += `<svg class="ac-leader" width="1" height="1" overflow="visible"><line x1="0" y1="0" x2="${ldrX2}" y2="${ldrY2}" stroke="${color}" stroke-width="1"/></svg>`;

        const db = formatFdbHtml(f, cls);
        const dbCls = isEmrg ? ' emrg' : '';

        html += `<div class="ac-db fdb${dbCls}" style="${leftStyle}; top:${ldr.dy + anchor.yShift}px;${leftExtra}">${db}</div>`;
    } else if (ldbBrightness > 0) {
        // VCI clears when track goes to LDB
        vciActive.delete(f.gufi);
        // Limited Data Block (2 lines) — no leader line, right next to target
        const ldbOp = ldbBrightness / 100;
        const l1 = f.callsign || '???';
        const alt = f.reportedAltitude ?? f.assignedAltitude;
        const l2 = alt != null ? String(Math.round(alt / 100)).padStart(3, '0') : '';
        const dbCls = isEmrg ? ' emrg' : '';
        html += `<div class="ac-db ldb${dbCls}" style="left:${Math.ceil(CHAR_W)}px; top:${-LINE_H}px; opacity:${ldbOp};">${l1}\n${l2}</div>`;
    }
    // ldbBrightness === 0 for LDB → no data block at all

    return html;
}

function formatDatablock(f, cls) {
    // Line 1: Field A (callsign)
    const l1 = f.callsign || '???';

    // Line 2: Field B + status + Field C (per ERAM spec)
    const l2 = formatAltLine(f);

    // Line 3: Field D (CID) + Field E
    const l3 = formatLine3(f, cls);

    // Line 4: Field F (full ICAO destination)
    const l4 = f.destination || '';

    return l4 ? `${l1}\n${l2}\n${l3}\n${l4}` : `${l1}\n${l2}\n${l3}`;
}

// Format FDB with Column 0 inline (VCI, R) — returns HTML
const VCI_SVG = '<svg viewBox="0 0 16 16" width="1.2em" height="1.2em" style="vertical-align:-0.2em;"><path d="M3,5 L3,13 L11,13" fill="none" stroke="currentColor" stroke-width="1.5"/><path d="M5,8 A3,3 0 0,1 8,11" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/><path d="M5,5.5 A5.5,5.5 0 0,1 10.5,11" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/></svg>';

function formatLine4(f, hsfCol) {
    const hsf = getEffectiveHsf(f);
    const hasServerClr = f.clearanceHeading || f.clearanceSpeed || f.clearanceText;
    const showHsf = hasServerClr || hsfShowMap.has(f.gufi);

    // HSF mode: show heading/speed/free text
    // Speed positioned so last digit sits under ↴ (at hsfCol), +/- extends one past
    if (showHsf && hsf) {
        if (hsf.freeText) return esc(hsf.freeText);
        const h = hsf.heading || '';
        const s = hsf.speed || '';
        if (s) {
            const hasModifier = /[+-]$/.test(s);
            // ↴ is at hsfCol; last digit under it, +/- one past
            const sEnd = hasModifier ? hsfCol + 2 : hsfCol + 1;
            const sStart = sEnd - s.length;
            if (h) {
                const pad = Math.max(1, sStart - h.length);
                return esc(h + '\u00a0'.repeat(pad) + s);
            }
            const pad = Math.max(0, sStart);
            return esc('\u00a0'.repeat(pad) + s);
        }
        return esc(h);
    }

    // Normal mode: based on line4Mode setting
    if (line4Mode === 'DEST') return f.destination ? esc(f.destination) : '';
    if (line4Mode === 'TYPE') {
        const t = f.aircraftType || '';
        const eq = f.equipmentQualifier ? '/' + f.equipmentQualifier : '';
        return t ? esc(t + eq) : '';
    }
    return ''; // OFF
}

function formatFdbHtml(f, cls) {
    const showVci = vciActive.has(f.gufi);
    const showR = shouldShowR(f, cls);
    const hsf = getEffectiveHsf(f);

    const l1 = esc(f.callsign || '???');
    const l2 = esc(formatAltLine(f));
    const l3text = formatLine3(f, cls);
    const l3esc = esc(l3text);
    const l4 = formatLine4(f, l3text.length);

    // ↴ indicator appended directly at end of line 3 (no gap)
    const hasServerClr = f.clearanceHeading || f.clearanceSpeed || f.clearanceText;
    let l3;
    if (hsf && (hasServerClr || hsf.heading || hsf.speed || hsf.freeText)) {
        const hsfInd = '<span class="ac-hsf-ind" style="pointer-events:auto;cursor:inherit;">\u21b4</span>';
        l3 = l3esc + hsfInd;
    } else {
        l3 = l3esc;
    }

    // Column 0: inline spans — VCI hit area on lines 1-2, R on line 3
    const col0Hit = '<span class="ac-vci-hit" style="display:inline-block;width:1.5ch;pointer-events:auto;cursor:inherit;">\u00a0</span>';
    const col0Vci = `<span class="ac-vci-hit ac-vci" style="display:inline-block;width:1.5ch;text-align:center;pointer-events:auto;cursor:inherit;">${VCI_SVG}</span>`;
    const col0R   = '<span class="ac-col0 ac-r" style="display:inline-block;width:1.5ch;text-align:center;">R</span>';
    const col0Sp  = '<span style="display:inline-block;width:1.5ch;">\u00a0</span>';

    // Line 0: Point-out P/A indicator (between 2nd and 3rd char position)
    const poInfo = getPointoutIndicator(f);
    let html = '';
    if (poInfo) {
        html += `${col0Sp}\u00a0<span class="ac-po-${poInfo.cls}">${poInfo.ch}</span>\n`;
    }
    html += `${col0Hit}${l1}\n`;
    html += `${showVci ? col0Vci : col0Hit}${l2}\n`;
    html += `${showR ? col0R : col0Sp}${l3}`;
    if (l4) html += `\n${col0Sp}${l4}`;
    return html;
}

// Determine point-out indicator for a flight.
// Returns {ch, cls} where ch is 'P' or 'A' and cls is 'pending' or 'accepted', or null.
function getPointoutIndicator(f) {
    if (!f.pointoutOriginatingUnit && !f.pointoutReceivingUnit) return null;
    const selFac = document.getElementById('facility')?.value;
    if (!selFac) return null;

    const origFac = (f.pointoutOriginatingUnit || '').split('/')[0];
    const recvFac = (f.pointoutReceivingUnit || '').split('/')[0];

    // Show P if the selected facility is involved in the point-out
    if (selFac === origFac || selFac === recvFac) {
        // Check if acknowledged (client-side tracking)
        if (pointoutAcked.has(f.gufi)) return { ch: 'A', cls: 'accepted' };
        return { ch: 'P', cls: 'pending' };
    }
    return null;
}

function formatAltLine(f) {
    const localA = localAssignedAlt.get(f.gufi);
    const localI = localInterimAlt.get(f.gufi);
    const localR = localReportedAlt.get(f.gufi);

    // SWIM fields take priority; local overrides fill gaps
    const assigned = f.assignedAltitude ?? (localA ? localA.feet : null);
    const reported = f.reportedAltitude ?? (localR != null ? localR : null);
    const interim = f.interimAltitude ?? (localI ? localI.feet : null);

    const afl = assigned != null ? String(Math.round(assigned / 100)).padStart(3, '0') : '';
    const rfl = reported != null ? String(Math.round(reported / 100)).padStart(3, '0') : '';

    // VFR/OTP display — server assignedVfr or local QZ override
    const isVfr = f.assignedVfr || (!f.assignedAltitude && localA && (localA.rules === 'VFR' || localA.rules === 'OTP'));
    if (isVfr) {
        const localRules = localA ? localA.rules : null;
        const prefix = localRules === 'OTP' ? 'OTP' : 'VFR';
        // VFR with altitude (vfrPlus) → VFR/055; VFR without → just VFR
        if (afl) return rfl ? `${prefix}/${rfl}` : `${prefix}/${afl}`;
        return rfl ? `${prefix}/${rfl}` : prefix;
    }

    // Block altitude — server blockFloor/blockCeiling or local QZ override
    if (f.blockFloor != null && f.blockCeiling != null) {
        const floor = String(Math.round(f.blockFloor / 100)).padStart(3, '0');
        const ceil = String(Math.round(f.blockCeiling / 100)).padStart(3, '0');
        const blockDisp = `${floor}B${ceil}`;
        return rfl ? `${blockDisp}${rfl}` : blockDisp;
    }
    if (localA && !f.assignedAltitude && localA.block) {
        return rfl ? `${localA.block}${rfl}` : localA.block;
    }

    // Interim/procedure/local altitude → T, P, or L indicator
    if (interim != null) {
        const ifl = String(Math.round(interim / 100)).padStart(3, '0');
        const localType = !f.interimAltitude && localI ? localI.type : null;
        const indicator = localType === 'P' ? 'P' : localType === 'L' ? 'L' : 'T';
        return rfl ? `${ifl}${indicator}${rfl}` : `${ifl}${indicator}`;
    }

    if (assigned == null && reported == null) return '';
    if (assigned == null) return rfl;

    // No Mode C reported → X indicator: {assigned}XXXX
    if (reported == null) return `${afl}XXXX`;

    const aAlt = Math.round(assigned / 100);
    const rAlt = Math.round(reported / 100);
    const diff = rAlt - aAlt;

    // Conforming (at altitude, within ±2 FL / 200ft) → C, hide Field C
    if (Math.abs(diff) <= 2) return `${afl}C`;

    // Non-conforming: climbing or descending indicators
    if (diff < 0) {
        // Reported below assigned → climbing to assigned
        return `${afl}\u2191${rfl}`;  // ↑
    } else {
        // Reported above assigned → descending to assigned
        return `${afl}\u2193${rfl}`;  // ↓
    }
}

function formatLine3(f, cls) {
    const cidVal = getCid(f);
    const cid = cidVal ? String(cidVal).padStart(3, ' ') : '   ';
    const gs = f.groundSpeed != null ? String(Math.round(f.groundSpeed)).padStart(3, '0') : '';
    const destLetter = getDestinationLetter(f.destination);
    // Normal Field E: single-letter destination + 3-digit groundspeed, or just groundspeed
    const gsStr = destLetter && gs ? `${cid}${destLetter}${gs}` : gs ? `${cid} ${gs}` : cid;

    // ── ERAM Field E priority (per specification) ──

    // 1. Special squawk codes (highest priority, static display)
    if (f.squawk === '7500') return `${cid} HIJK`;
    if (f.squawk === '7600') return `${cid} RDOF`;
    if (f.squawk === '7700') return `${cid} EMRG`;
    if (f.squawk === '1276') return `${cid} ADIZ`;
    if (f.squawk === '7400') return `${cid} LLNK`;
    if (f.squawk === '7777') return `${cid} AFIO`;

    // 2. Active handoff — flash in Field E (uses global flashTime so ALL tracks sync)
    //    H = proposed, O = accepted/executing, K = forced acceptance (/OK)
    //    HUNK/OUNK/KUNK = unknown sector variant
    const hoEvt = hoEventType(f.handoffEvent);
    if (hoEvt && f.handoffReceiving) {
        const recvSec = extractSec(f.handoffReceiving);
        const isUnknown = !recvSec;
        let hoLetter;
        if (f.handoffForced) hoLetter = 'K';
        else if (hoEvt === 'PROPOSED') hoLetter = 'H';
        else hoLetter = 'O';

        const hoStr = isUnknown
            ? `${cid} ${hoLetter === 'H' ? 'HUNK' : hoLetter === 'K' ? 'KUNK' : 'OUNK'}`
            : `${cid}${hoLetter}${handoffSuffix(f.handoffReceiving, f.handoffTransferring)}`;
        const padLen = Math.max(hoStr.length, gsStr.length);
        if (hoEvt === 'PROPOSED' && !f.handoffForced) {
            // Fast blink: 0.5s on/off, alternate H-xx / GS every 6s
            const tick = Math.floor(flashTime / 500) % 24;
            const phase = tick < 12 ? 0 : 1;
            const visible = tick % 2 === 0;
            if (!visible) return cid.padEnd(padLen);
            if (phase === 0) return hoStr.padEnd(padLen);
            return gsStr.padEnd(padLen);
        } else {
            // Slow 6-second cycle: 3s indicator, 3s GS (O/K — no rapid on/off)
            const phase = Math.floor(flashTime / 3000) % 2;
            if (phase === 0) return hoStr.padEnd(padLen);
            return gsStr.padEnd(padLen);
        }
    }

    // 3. Completed handoff — rotate indicator / groundspeed for 60 seconds (5 cycles of 12s)
    //    Uses K for forced (/OK) completions, O for normal
    const completed = hoCompletedInfo.get(f.gufi);
    if (completed && flashTime - completed.time < 60000) {
        const recvSec = extractSec(completed.receiving);
        const isUnknown = !recvSec;
        const letter = completed.forced ? 'K' : 'O';
        const hoStr = isUnknown
            ? `${cid} ${letter === 'K' ? 'KUNK' : 'OUNK'}`
            : `${cid}${letter}${handoffSuffix(completed.receiving, completed.transferring)}`;
        const padLen = Math.max(hoStr.length, gsStr.length);
        // 12s per cycle: 6s indicator, 6s groundspeed
        const phase = Math.floor((flashTime - completed.time) / 6000) % 2;
        if (phase === 0) return hoStr.padEnd(padLen);
        return gsStr.padEnd(padLen);
    }

    // 4. Normal: destination letter + groundspeed
    return gsStr;
}

// Build handoff suffix: intra-facility = -xx, inter-facility = Nxx (handoff code)
function handoffSuffix(receiving, transferring) {
    const recvFac = extractFac(receiving);
    const recvSec = extractSec(receiving);
    const xferFac = transferring ? extractFac(transferring) : '';
    if (!recvFac || !recvSec) return `-${(recvSec || '??').padStart(2, '0')}`;
    // Inter-facility: use handoff code of receiving facility
    if (xferFac && xferFac !== recvFac) {
        const code = getHandoffCode(recvFac);
        return `${code}${recvSec.padStart(2, '0')}`;
    }
    // Intra-facility: use dash
    return `-${recvSec.padStart(2, '0')}`;
}

// ════════════════════════════════════════════════════════════════════════════
// History tracking
// ════════════════════════════════════════════════════════════════════════════
function addHistoryPoint(gufi, lat, lon, sym) {
    if (!flightHistory.has(gufi)) flightHistory.set(gufi, []);
    const hist = flightHistory.get(gufi);
    hist.push({ lat, lon, sym: sym || '\\' });
    if (hist.length > MAX_HISTORY) hist.shift();
}

// ════════════════════════════════════════════════════════════════════════════
// WebSocket
// ════════════════════════════════════════════════════════════════════════════
function connectWs() {
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${proto}//${location.host}/ws`);

    ws.onopen = () => {
        wsConnected = true;
        document.getElementById('connection-status').textContent = 'Connected';
        document.getElementById('connection-status').style.color = '#cccc44';
    };

    ws.onclose = () => {
        wsConnected = false;
        document.getElementById('connection-status').textContent = 'Disconnected \u2014 reconnecting...';
        document.getElementById('connection-status').style.color = '#cc4444';
        setTimeout(connectWs, 3000);
    };

    ws.onmessage = (evt) => {
        const msg = JSON.parse(evt.data);

        if (msg.type === 'snapshot') {
            // Fresh start — seed history from server (survives refresh)
            for (const [, m] of markers) map.removeLayer(m);
            markers.clear();
            flights.clear();
            pendingPositions.clear();
            flightHistory.clear();
            for (const f of msg.data) {
                flights.set(f.gufi, f);
                trackFacility(f);
                if (f.history && f.history.length > 0) {
                    const hist = f.history.map(h => ({ lat: h.lat, lon: h.lon, sym: h.sym || '\\' }));
                    while (hist.length > MAX_HISTORY) hist.shift();
                    flightHistory.set(f.gufi, hist);
                }
                // Auto-show HSF for flights with server clearance data
                if (f.clearanceHeading || f.clearanceSpeed || f.clearanceText) {
                    hsfShowMap.add(f.gufi);
                }
            }
            lastScanTime = performance.now(); // reset scan clock
        } else if (msg.type === 'update') {
            const f = msg.data;
            trackFacility(f);

            // Apply datablock fields IMMEDIATELY (handoffs, altitude, callsign, etc.)
            // Only buffer position (lat/lon) for the 12-second scan cycle
            const existing = flights.get(f.gufi);
            if (existing) {
                // Capture old state BEFORE overwriting
                const oldHoEvt = hoEventType(existing.handoffEvent);
                const oldHoRecv = existing.handoffReceiving;
                const oldHoXfer = existing.handoffTransferring;
                const oldHoForced = existing.handoffForced;
                const oldCuFac = existing.controllingFacility;
                const oldCuSec = existing.controllingSector;
                const hadClr = existing.clearanceHeading || existing.clearanceSpeed || existing.clearanceText;

                // Buffer new position for scan cycle; record history from the position we're replacing
                if (f.latitude != null && f.longitude != null) {
                    const prev = pendingPositions.get(f.gufi);
                    const oldLat = prev ? prev.lat : existing.latitude;
                    const oldLon = prev ? prev.lon : existing.longitude;
                    if (oldLat != null && oldLon != null) {
                        const dlat = Math.abs(oldLat - f.latitude);
                        const dlon = Math.abs(oldLon - f.longitude);
                        if (dlat > 0.0001 || dlon > 0.0001) {
                            addHistoryPoint(f.gufi, oldLat, oldLon, getSymbolChar(existing));
                        }
                    }
                    pendingPositions.set(f.gufi, { lat: f.latitude, lon: f.longitude });
                }
                // Apply all non-position fields instantly
                for (const key in f) {
                    if (key === 'latitude' || key === 'longitude') continue;
                    existing[key] = f[key];
                }

                // SWIM data overrides local controller entries
                if (f.assignedAltitude != null) localAssignedAlt.delete(f.gufi);
                if (f.interimAltitude != null) localInterimAlt.delete(f.gufi);
                if (f.reportedAltitude != null) localReportedAlt.delete(f.gufi);

                // Auto-show HSF when server clearance data first arrives (don't re-show if user manually hid)
                // hadClr was captured before the copy loop above
                const hasClr = existing.clearanceHeading || existing.clearanceSpeed || existing.clearanceText;
                if (hasClr && !hadClr) {
                    hsfShowMap.add(f.gufi);
                }

                // Detect handoff completion via two paths:
                // 1) HO event cleared by server (HO-DONE) + CU matches recv
                // 2) CU changed to match recv (covers missed initiation, e.g. server restart)
                const newHoEvt = hoEventType(existing.handoffEvent);
                const cuChanged = existing.controllingFacility !== oldCuFac || existing.controllingSector !== oldCuSec;
                const recv = oldHoRecv || existing.handoffReceiving;
                if (recv && !hoCompletedInfo.has(f.gufi)) {
                    const recvFac = extractFac(recv);
                    const recvSec = extractSec(recv);
                    const cuMatchesRecv = existing.controllingFacility === recvFac && existing.controllingSector === recvSec;
                    // Path 1: server cleared handoff fields (event went active→inactive)
                    // Path 2: CU just changed to match recv
                    if (cuMatchesRecv && ((!newHoEvt && oldHoEvt) || cuChanged)) {
                        hoCompletedInfo.set(f.gufi, {
                            time: performance.now(),
                            receiving: recv,
                            transferring: oldHoXfer || existing.handoffTransferring || '',
                            forced: oldHoForced || existing.handoffForced || false
                        });
                    }
                }
            } else {
                // New flight — add fully (including position)
                flights.set(f.gufi, f);
            }

            // Handoff targeting our sector → immediately set FDB + rebuild marker
            if (hoEventType(f.handoffEvent)) {
                const cur = flights.get(f.gufi);
                if (cur) {
                    const cls = classifyTrack(cur);
                    if (cls === 'ho' && !fdbOverrides.has(f.gufi)) {
                        fdbOverrides.set(f.gufi, true);
                        // Immediately invalidate marker for instant LDB→FDB transition
                        const marker = markers.get(f.gufi);
                        if (marker) {
                            const el = marker.getElement();
                            if (el) el._lastHash = '';
                        }
                        lastRenderTime = 0;
                    }
                }
            }

            // Auto-switch QP T → QP J when aircraft climbs above FL230
            if (driActive.get(f.gufi) === 'T') {
                const alt = f.reportedAltitude ?? f.assignedAltitude;
                if (alt != null && alt > 23000) {
                    driActive.set(f.gufi, 'J');
                    lastRenderTime = 0;
                }
            }
        } else if (msg.type === 'remove') {
            pendingPositions.delete(msg.data.gufi);
            flights.delete(msg.data.gufi);
            flightHistory.delete(msg.data.gufi);
            fdbOverrides.delete(msg.data.gufi);
            wasOwnOrHo.delete(msg.data.gufi);
            hoCompletedInfo.delete(msg.data.gufi);
            lastVisibleAt.delete(msg.data.gufi);
            driActive.delete(msg.data.gufi);
            const m = markers.get(msg.data.gufi);
            if (m) { map.removeLayer(m); markers.delete(msg.data.gufi); }
            removeRoute(msg.data.gufi);
        } else if (msg.type === 'stats') {
            msgRate = msg.data.rate;
        }
    };
}
connectWs();

// ════════════════════════════════════════════════════════════════════════════
// Facility/sector tracking
// ════════════════════════════════════════════════════════════════════════════
function trackFacility(f) {
    const fac = f.controllingFacility || f.reportingFacility || '';
    if (!fac) return;
    const sec = f.controllingSector || '';
    if (!knownFacilities.has(fac)) knownFacilities.set(fac, new Set());
    if (sec) knownFacilities.get(fac).add(sec);
}

let _lastFacilityInDropdown = false;
function rebuildFacilityDropdown() {
    const sel = document.getElementById('sel-facility');
    const facs = [...knownFacilities.keys()].filter(f => f.startsWith('Z')).sort();
    let html = '<option value="">All</option>';
    for (const fac of facs) html += `<option value="${esc(fac)}">${esc(fac)}</option>`;
    sel.innerHTML = html;
    // Restore selection (myFacility may have been set from URL before facilities were known)
    sel.value = myFacility || '';
    // First time our facility appears in the dropdown — trigger boundary display
    if (myFacility && !_lastFacilityInDropdown && facs.includes(myFacility)) {
        _lastFacilityInDropdown = true;
        showBoundariesForFacility(myFacility);
        rebuildSectorCheckboxes();
    }
}

function rebuildSectorCheckboxes() {
    const container = document.getElementById('sector-checkboxes');
    if (!myFacility) {
        container.innerHTML = '<span style="color:#666; font-size:10px;">Select facility first</span>';
        return;
    }
    const secs = knownFacilities.has(myFacility) ? [...knownFacilities.get(myFacility)].sort() : [];
    if (secs.length === 0) {
        container.innerHTML = '<span style="color:#666; font-size:10px;">No sectors found yet</span>';
        return;
    }
    let html = '';
    for (const sec of secs) {
        const checked = mySectors.has(sec) ? ' checked' : '';
        html += `<label style="display:block; padding:1px 0; cursor:pointer; color:#aaa;">` +
            `<input type="checkbox" class="sec-chk" value="${esc(sec)}"${checked} style="accent-color:#cccc44;"> ${esc(sec)}` +
            `</label>`;
    }
    container.innerHTML = html;
    container.querySelectorAll('.sec-chk').forEach(chk => {
        chk.addEventListener('change', function () {
            if (this.checked) {
                mySectors.add(this.value);
            } else {
                mySectors.delete(this.value);
                // Deactivating a sector: revert all flights associated with that sector to LDB
                demoteSectorFlights(this.value);
            }
            invalidateAllMarkers(); // immediately update R indicators and FDB/LDB
            saveSettingsToUrl();
        });
    });
}

// When a sector is deactivated, revert all flights that were own/ho for that sector back to LDB
function demoteSectorFlights(sector) {
    for (const [gufi, f] of flights) {
        const fac = f.controllingFacility || f.reportingFacility || '';
        const sec = f.controllingSector || '';
        const hoRecvSec = extractSec(f.handoffReceiving);
        const hoXferSec = extractSec(f.handoffTransferring);
        // Flight belongs to the deactivated sector if it's controlled by it or in handoff with it
        if (fac === myFacility && sec === sector ||
            extractFac(f.handoffReceiving) === myFacility && hoRecvSec === sector ||
            extractFac(f.handoffTransferring) === myFacility && hoXferSec === sector) {
            fdbOverrides.delete(gufi);
            wasOwnOrHo.delete(gufi);
        }
    }
}

function esc(s) {
    return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ════════════════════════════════════════════════════════════════════════════
// Change detection — lightweight hash to avoid rebuilding marker HTML
// ════════════════════════════════════════════════════════════════════════════
function flightHash(f, cls) {
    const useFdb = shouldShowFdb(f.gufi, cls);
    // Flash animation is handled by the 500ms flash timer (data block text only),
    // so flashKey is NOT in the hash — prevents full marker rebuild every tick.
    // Include hoCompleted + R state so marker rebuilds when handoff completes
    const hoc = hoCompletedInfo.has(f.gufi) ? 1 : 0;
    const rInd = shouldShowR(f, cls) ? 1 : 0;
    const dbPos = dbPositions.get(f.gufi) || 0;
    const ldrLen = ldrLenOverrides.get(f.gufi) ?? 1;
    const vci = vciActive.has(f.gufi) ? 1 : 0;
    const la = localAssignedAlt.get(f.gufi);
    const li = localInterimAlt.get(f.gufi);
    const lr = localReportedAlt.get(f.gufi);
    const laH = la ? `${la.feet}${la.rules||''}${la.block||''}` : '';
    const liH = li ? `${li.feet}${li.type}` : '';
    const lrH = lr != null ? lr : '';
    const hsf = getEffectiveHsf(f);
    const hsfH = hsf ? `${hsf.heading||''}${hsf.speed||''}${hsf.freeText||''}` : '';
    const hsfS = hsfShowMap.has(f.gufi) ? 1 : 0;
    return `${f.latitude}|${f.longitude}|${f.callsign}|${f.reportedAltitude}|${f.assignedAltitude}|${f.interimAltitude}|${f.assignedVfr||0}|${f.blockFloor||''}|${f.blockCeiling||''}|${f.squawk}|${f.handoffEvent}|${f.handoffReceiving}|${f.controllingFacility}|${f.controllingSector}|${f.groundSpeed}|${f.destination}|${getCid(f)}|${cls}|${useFdb}|${useFdb ? 0 : ldbBrightness}|${hoc}|${rInd}|${dbPos}|${ldrLen}|${vci}|${laH}|${liH}|${lrH}|${line4Mode}|${f.aircraftType||''}|${hsfH}|${hsfS}|${f.clearanceHeading||''}|${f.clearanceSpeed||''}|${f.clearanceText||''}`;
}

// ════════════════════════════════════════════════════════════════════════════
// Render loop — guaranteed to never stop via requestAnimationFrame-first
// ════════════════════════════════════════════════════════════════════════════
let lastRenderTime = 0;

// Force all markers to rebuild on next render (invalidate hashes)
function invalidateAllMarkers() {
    for (const [, m] of markers) {
        const el = m.getElement();
        if (el) el._lastHash = '';
    }
    lastRenderTime = 0; // trigger immediate render on next frame
}

function render() {
    requestAnimationFrame(render);  // ALWAYS schedule next — loop never dies

    const now = performance.now();
    if (now - lastRenderTime < RENDER_INTERVAL) return;
    lastRenderTime = now;

    try {
        doRender();
    } catch (e) {
        console.error('[Render]', e);
    }
}

function applyScanCycle() {
    // Apply buffered positions (lat/lon only) — history was already recorded at WS message time
    for (const [gufi, pos] of pendingPositions) {
        const f = flights.get(gufi);
        if (!f) continue;
        f.latitude = pos.lat;
        f.longitude = pos.lon;
    }
    pendingPositions.clear();
}

function doRender() {
    // Apply scan cycle if enough time has elapsed (same 12s cadence as setInterval,
    // but checked here too so positions apply even if setInterval timing drifts)
    const now = performance.now();
    if (pendingPositions.size > 0 && now - lastScanTime >= SCAN_INTERVAL) {
        applyScanCycle();
        lastScanTime = now;
    }
    // Update QU route lines to follow aircraft positions
    if (activeRoutes.size > 0) updateActiveRoutes();

    const mapBounds = map.getBounds();
    const onScreenGufis = new Set();
    const counts = { own: 0, ho: 0, other: 0, emrg: 0 };

    // Deduplicate: same callsign reported by multiple ARTCCs → keep only the best GUFI.
    // Priority: (1) has position, (2) facility matches, (3) ACTIVE over DROPPED, (4) first seen.
    // During handoff the old GUFI may be DROPPED with position while the new GUFI is ACTIVE
    // but has no position yet — we prefer the one with position so the target doesn't vanish.
    bestGufiByCallsign.clear();
    if (myFacility) {
        for (const [gufi, f] of flights) {
            if (!f.callsign) continue;
            if (f.flightStatus === 'CANCELLED') continue;  // skip cancelled
            const cs = f.callsign;
            const prev = bestGufiByCallsign.get(cs);
            if (!prev) { bestGufiByCallsign.set(cs, gufi); continue; }
            const prevF = flights.get(prev);
            const prevHasPos = prevF.latitude != null && prevF.longitude != null;
            const curHasPos = f.latitude != null && f.longitude != null;
            // Strong preference: has position beats no position
            if (curHasPos && !prevHasPos) { bestGufiByCallsign.set(cs, gufi); continue; }
            if (!curHasPos && prevHasPos) continue;
            // Both have position (or neither): prefer our facility
            const prevFac = prevF.controllingFacility || prevF.reportingFacility || '';
            const curFac = f.controllingFacility || f.reportingFacility || '';
            if (curFac === myFacility && prevFac !== myFacility) {
                bestGufiByCallsign.set(cs, gufi);
            }
        }
    }

    for (const [gufi, f] of flights) {
        if (!isVisible(f)) continue;
        // Skip duplicate callsigns — only show the best GUFI per callsign
        if (isDedupHidden(gufi, f)) continue;
        lastVisibleAt.set(gufi, now);  // stamp for grace period

        const cls = classifyTrack(f);
        counts[cls]++;

        // Sticky FDB: when a track transitions from own/ho to other, keep FDB
        if (cls === 'own' || cls === 'ho') {
            wasOwnOrHo.add(gufi);
        } else if (cls === 'other' && wasOwnOrHo.has(gufi) && !fdbOverrides.has(gufi)) {
            fdbOverrides.set(gufi, true);
        }

        // Viewport culling — count all visible flights but only render on-screen ones
        if (!mapBounds.contains([f.latitude, f.longitude])) continue;

        onScreenGufis.add(gufi);
        const ll = [f.latitude, f.longitude];
        const hash = flightHash(f, cls);

        const existing = markers.get(gufi);
        if (existing) {
            existing.setLatLng(ll);
            const el = existing.getElement();
            if (el) {
                // Unhide if previously hidden (flight became visible again)
                if (el.style.display === 'none') el.style.display = '';
                // Only rebuild HTML when flight data actually changes
                if (el._lastHash !== hash) {
                    el.innerHTML = buildMarkerHtml(f, cls);
                    el._lastHash = hash;
                    // Re-apply dwell emphasis after rebuild
                    if (dwellLocked.has(gufi) || el._isHovering) applyDwell(el, gufi);
                }
            }
        } else {
            const html = buildMarkerHtml(f, cls);
            const icon = L.divIcon({ className: 'ac-group', html, iconSize: [0, 0], iconAnchor: [0, 0] });
            const m = L.marker(ll, { icon, pane: 'targets', interactive: false });
            m.addTo(map);
            const el = m.getElement();
            if (el) {
                el._lastHash = hash;
                el.style.pointerEvents = 'auto';
                el.style.cursor = 'inherit';
                el._isHovering = false;
                el._gufi = gufi;
                // Dwell emphasis — hover
                el.addEventListener('mouseenter', () => {
                    el._isHovering = true;
                    applyDwell(el, gufi);
                });
                el.addEventListener('mouseleave', () => {
                    el._isHovering = false;
                    if (!dwellLocked.has(gufi)) removeDwell(el, gufi);
                });
                // Click: VCI hit area → toggle VCI; Field A → dwell lock; MCA has text → insert target ▽; else → toggle
                el.addEventListener('click', (e) => {
                    // Target symbol priority: if click is on another target's symbol, redirect
                    const redirectGufi = findTargetUnderClick(e, gufi);
                    if (redirectGufi) {
                        if (mca.text.trim().length > 0) {
                            e.stopPropagation();
                            const rf = flights.get(redirectGufi);
                            const rflid = getFlid(rf);
                            if (rflid) mcaInsertTarget(rflid);
                        } else {
                            toggleTrackSelect(redirectGufi);
                        }
                        return;
                    }
                    // VCI toggle: click on Column 0 hit area
                    if (e.target.closest('.ac-vci-hit')) {
                        if (vciActive.has(gufi)) vciActive.delete(gufi);
                        else vciActive.add(gufi);
                        el._lastHash = '';
                        lastRenderTime = 0;
                        return;
                    }
                    // HSF indicator toggle: click ↴ to switch line 4 between DEST/TYPE and HSF
                    if (e.target.closest('.ac-hsf-ind')) {
                        if (hsfShowMap.has(gufi)) hsfShowMap.delete(gufi);
                        else hsfShowMap.add(gufi);
                        el._lastHash = '';
                        lastRenderTime = 0;
                        return;
                    }
                    const dbEl = el.querySelector('.ac-db');
                    if (dbEl) {
                        const rect = dbEl.getBoundingClientRect();
                        if (e.clientX >= rect.left && e.clientX <= rect.right &&
                            e.clientY >= rect.top && e.clientY <= rect.top + LINE_H) {
                            // Click on Field A → toggle dwell lock
                            if (dwellLocked.has(gufi)) {
                                dwellLocked.delete(gufi);
                                if (!el._isHovering) removeDwell(el, gufi);
                            } else {
                                dwellLocked.add(gufi);
                                applyDwell(el, gufi);
                            }
                            return;
                        }
                    }
                    // If MCA has content, left-click inserts a ▽ target placeholder
                    if (mca.text.trim().length > 0) {
                        e.stopPropagation(); // prevent map click from also firing
                        const f = flights.get(gufi);
                        const flid = getFlid(f);
                        if (flid) mcaInsertTarget(flid);
                        return;
                    }
                    // Left-click does NOT toggle FDB/LDB — use middle-click on target symbol
                });
                // Middle-click: target symbol → toggle FDB/LDB; Field A → QF; VCI → toggle; MCA content → CID Enter
                el.addEventListener('auxclick', (e) => {
                    if (e.button !== 1) return;
                    e.preventDefault();
                    // Target symbol priority: if click is on another target's symbol, redirect
                    const redirectGufi = findTargetUnderClick(e, gufi);
                    if (redirectGufi) {
                        if (mca.text.trim().length > 0) {
                            const rf = flights.get(redirectGufi);
                            const rflid = getFlid(rf);
                            if (rflid) {
                                if (mca.text[mca.text.length - 1] !== ' ') mca.text += ' ';
                                mca.text += rflid;
                                mca.cursor = mca.text.length;
                                mcaExecute();
                            }
                        } else {
                            toggleTrackSelect(redirectGufi);
                        }
                        return;
                    }
                    // Check if click is on the target symbol (within 8px of marker center)
                    const markerPos = map.latLngToContainerPoint(m.getLatLng());
                    const onTarget = Math.abs(e.clientX - markerPos.x - mapEl.getBoundingClientRect().left) <= 8
                                  && Math.abs(e.clientY - markerPos.y - mapEl.getBoundingClientRect().top) <= 8;
                    if (onTarget) {
                        toggleTrackSelect(gufi);
                        return;
                    }
                    // VCI hit area: toggle VCI
                    if (e.target.closest('.ac-vci-hit')) {
                        if (vciActive.has(gufi)) vciActive.delete(gufi);
                        else vciActive.add(gufi);
                        el._lastHash = '';
                        lastRenderTime = 0;
                        return;
                    }
                    // HSF indicator: toggle HSF display on line 4
                    if (e.target.closest('.ac-hsf-ind')) {
                        if (hsfShowMap.has(gufi)) hsfShowMap.delete(gufi);
                        else hsfShowMap.add(gufi);
                        el._lastHash = '';
                        lastRenderTime = 0;
                        return;
                    }
                    const f = flights.get(gufi);
                    if (!f) return;
                    const flid = getFlid(f);
                    // Field A (line 1): middle-click → execute QF
                    const dbEl = el.querySelector('.ac-db');
                    if (dbEl) {
                        const rect = dbEl.getBoundingClientRect();
                        if (e.clientX >= rect.left && e.clientX <= rect.right &&
                            e.clientY >= rect.top && e.clientY <= rect.top + LINE_H) {
                            showFlightInRA(f);
                            return;
                        }
                    }
                    // Middle-click on data block area:
                    //   MCA has content → append FLID + execute (CID Enter)
                    if (mca.text.trim().length > 0 && flid) {
                        if (mca.text.length > 0 && mca.text[mca.text.length - 1] !== ' ') {
                            mca.text += ' ';
                        }
                        mca.text += flid;
                        mca.cursor = mca.text.length;
                        mcaExecute();
                    }
                });
            }
            markers.set(gufi, m);
        }
    }

    // Persistent markers: only REMOVE markers for flights that no longer exist (server removed).
    // All other off-screen/invisible flights just get hidden — no DOM destroy/recreate flicker.
    for (const [gufi, m] of markers) {
        if (!flights.has(gufi)) {
            map.removeLayer(m);
            markers.delete(gufi);
        } else if (!onScreenGufis.has(gufi)) {
            const el = m.getElement();
            if (el && el.style.display !== 'none') el.style.display = 'none';
        }
    }

    // Redraw canvas overlay
    drawOverlay();

    // Update counters
    document.getElementById('cnt-own').textContent = counts.own;
    document.getElementById('cnt-ho').textContent = counts.ho;
    document.getElementById('cnt-other').textContent = counts.other;
    document.getElementById('cnt-total').textContent = counts.own + counts.ho + counts.other + counts.emrg;
}

requestAnimationFrame(render);

// ── Scan cycle — runs on setInterval so it fires even when tab is backgrounded ──
setInterval(() => {
    applyScanCycle();
    lastScanTime = performance.now();
}, SCAN_INTERVAL);

// ── Handoff flash timer (500ms) ─────────────────────────────────────────────
// Updates DATA BLOCK TEXT for tracks in active handoff OR completed handoff (O display).
// Does NOT rebuild the entire marker — symbol and leader line stay intact.
setInterval(() => {
    // Update global flash reference — ALL tracks see the same phase
    flashTime = performance.now();

    // Cleanup expired hoCompletedInfo entries
    for (const [gufi, info] of hoCompletedInfo) {
        if (flashTime - info.time >= 60000) hoCompletedInfo.delete(gufi);
    }

    for (const [gufi, m] of markers) {
        const f = flights.get(gufi);
        if (!f) continue;

        const hasActiveHo = hoEventType(f.handoffEvent) && f.handoffReceiving;
        const hasCompletedHo = hoCompletedInfo.has(gufi);
        if (!hasActiveHo && !hasCompletedHo) continue;

        const el = m.getElement();
        if (!el) continue;
        const dbEl = el.querySelector('.ac-db');
        if (!dbEl) continue;
        const cls = classifyTrack(f);
        if (shouldShowFdb(gufi, cls)) {
            // Column 0 is inline — just regenerate full HTML (includes R, VCI)
            dbEl.innerHTML = formatFdbHtml(f, cls);
        }
    }
}, 500);

// ════════════════════════════════════════════════════════════════════════════
// Sidebar controls
// ════════════════════════════════════════════════════════════════════════════
document.getElementById('sidebar-toggle').addEventListener('click', function () {
    const sidebar = document.getElementById('sidebar');
    sidebar.classList.toggle('collapsed');
    this.innerHTML = sidebar.classList.contains('collapsed') ? '&#9654;' : '&#9664;';
});

document.getElementById('sel-facility').addEventListener('change', function () {
    myFacility = this.value;
    mySectors.clear();
    // Changing facility: revert all tracks to default LDB
    fdbOverrides.clear();
    quickLookSectors.clear();
    wasOwnOrHo.clear();
    invalidateAllMarkers();
    rebuildSectorCheckboxes();
    showBoundariesForFacility(myFacility);
    zoomToFacility(myFacility);
    saveSettingsToUrl();
});

document.getElementById('chk-facility-only').addEventListener('change', function () {
    facilityOnly = this.checked;
    invalidateAllMarkers();
    saveSettingsToUrl();
});

document.getElementById('sel-histcount').addEventListener('change', function () {
    MAX_HISTORY = parseInt(this.value);
    for (const [, hist] of flightHistory) {
        while (hist.length > MAX_HISTORY) hist.shift();
    }
    invalidateAllMarkers();
    saveSettingsToUrl();
});

document.getElementById('rng-ldb-brightness').addEventListener('input', function () {
    ldbBrightness = parseInt(this.value);
    document.getElementById('lbl-ldb-brightness').textContent = ldbBrightness;
    saveSettingsToUrl();
});

document.getElementById('sel-vector').addEventListener('change', function () {
    vectorMinutes = parseInt(this.value);
    invalidateAllMarkers();
    saveSettingsToUrl();
});

document.getElementById('sel-line4').addEventListener('change', function () {
    line4Mode = this.value;
    invalidateAllMarkers();
    saveSettingsToUrl();
});

for (const [cat, id] of Object.entries(BOUNDARY_CAT_SLIDER)) {
    const lblId = BOUNDARY_CAT_LABEL[cat];
    document.getElementById(id).addEventListener('input', function () {
        setBoundaryBrightness(cat, parseInt(this.value));
        document.getElementById(lblId).textContent = this.value;
    });
    document.getElementById(id).addEventListener('change', function () {
        setBoundaryBrightness(cat, parseInt(this.value));
        document.getElementById(lblId).textContent = this.value;
        saveSettingsToUrl();
    });
}

document.getElementById('chk-mapbg').addEventListener('change', function () {
    showMapBg = this.checked;
    if (showMapBg) tileLayer.addTo(map);
    else map.removeLayer(tileLayer);
    saveSettingsToUrl();
});

document.getElementById('chk-mca-kb').addEventListener('change', function () {
    document.getElementById('mca').classList.toggle('show-kb', this.checked);
    saveSettingsToUrl();
});

// Transp MCA: reserved for future use
// document.getElementById('chk-transp-mca').addEventListener('change', function () {
//     document.getElementById('map-container').classList.toggle('transp-mca', this.checked);
//     saveSettingsToUrl();
// });

document.getElementById('btn-fullscreen').addEventListener('click', function () {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => {});
    } else {
        document.exitFullscreen();
    }
});

document.getElementById('sel-fontsize').addEventListener('change', function () {
    fontSize = parseInt(this.value);
    updateFontSize();
    saveSettingsToUrl();
});

document.getElementById('inp-alt-low').addEventListener('change', function () {
    altFilterLow = parseInt(this.value) || 0;
    saveSettingsToUrl();
});

document.getElementById('inp-alt-high').addEventListener('change', function () {
    altFilterHigh = parseInt(this.value) || 999;
    saveSettingsToUrl();
});

function updateFontSize() {
    CHAR_W = fontSize * 0.625;
    LINE_H = fontSize * 1.25;
    // Update data block and symbol CSS dynamically
    let styleEl = document.getElementById('dynamic-fontsize');
    if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = 'dynamic-fontsize';
        document.head.appendChild(styleEl);
    }
    styleEl.textContent = `
        .ac-db, .ac-line0 {
            font-size: ${fontSize}px !important;
            line-height: ${LINE_H}px !important;
        }
    `;
}

setInterval(() => {
    rebuildFacilityDropdown();
    rebuildSectorCheckboxes();
    document.getElementById('stat-flights').textContent = flights.size;
    document.getElementById('stat-rate').textContent = msgRate;
    // Debug metrics: flight plan coverage
    let nRoute = 0, nCallsign = 0, nType = 0, nAlt = 0, nPos = 0;
    for (const [, f] of flights) {
        if (f.route) nRoute++;
        if (f.callsign) nCallsign++;
        if (f.aircraftType) nType++;
        if (f.assignedAltitude) nAlt++;
        if (f.latitude != null && f.longitude != null) nPos++;
    }
    const t = flights.size || 1;
    document.getElementById('stat-fp').textContent =
        `FP: ${nRoute}/${t} rte ${nCallsign}/${t} cs ${nType}/${t} typ ${nAlt}/${t} alt ${nPos}/${t} pos`;
}, 5000);

// ════════════════════════════════════════════════════════════════════════════
// Click target priority: symbols win over overlapping data blocks
// ════════════════════════════════════════════════════════════════════════════
// When a click lands on a data block that overlaps another target's position symbol,
// redirect the click to the underlying target. Returns the target gufi, or null.
function findTargetUnderClick(e, currentGufi) {
    const m = markers.get(currentGufi);
    if (!m) return null;
    const mapRect = map.getContainer().getBoundingClientRect();
    const cx = e.clientX - mapRect.left;
    const cy = e.clientY - mapRect.top;
    // If click is near our own symbol center, no redirect needed
    const myPt = map.latLngToContainerPoint(m.getLatLng());
    if (Math.hypot(cx - myPt.x, cy - myPt.y) <= 10) return null;
    // Check if another target's symbol is at the click point
    for (const [gufi, om] of markers) {
        if (gufi === currentGufi || !om._icon) continue;
        const pt = map.latLngToContainerPoint(om.getLatLng());
        if (Math.abs(cx - pt.x) <= 10 && Math.abs(cy - pt.y) <= 10) return gufi;
    }
    return null;
}

// ════════════════════════════════════════════════════════════════════════════
// Flight detail panel
// ════════════════════════════════════════════════════════════════════════════
function toggleTrackSelect(gufi) {
    const f = flights.get(gufi);
    if (!f) return;
    const cls = classifyTrack(f);

    // Own/handoff/emergency tracks: default FDB, clicking does NOT toggle to LDB
    if (cls === 'own' || cls === 'ho' || cls === 'emrg') {
        mca.feedback = [
            { type: 'err', text: 'USER ACTION NOT ALLOWED ON A\nCONTROLLED FLIGHT' },
            { type: 'info', text: `FORCED DATA BLK ${f.callsign || '???'}` }
        ];
        mcaRender();
        showFlightDetail(gufi);
        return;
    }

    // Other tracks: toggle between default LDB and FDB (quick look)
    if (fdbOverrides.has(gufi)) {
        fdbOverrides.delete(gufi);  // back to default LDB
    } else {
        fdbOverrides.set(gufi, true);  // promote to FDB
    }

    // Immediately rebuild the marker so the change is instant (don't wait for render cycle)
    const m = markers.get(gufi);
    if (m) {
        const el = m.getElement();
        if (el) {
            const newHash = flightHash(f, cls);
            el.innerHTML = buildMarkerHtml(f, cls);
            el._lastHash = newHash;
            if (dwellLocked.has(gufi) || el._isHovering) applyDwell(el, gufi);
        }
    }

    showFlightDetail(gufi);
}

function showFlightDetail(gufi) {
    selectedGufi = gufi;
    const f = flights.get(gufi);
    if (!f) return;

    document.getElementById('fd-title').textContent =
        `${f.callsign || '???'}  ${f.aircraftType || ''}`;

    const cls = classifyTrack(f);
    const heading = (f.trackVelocityX != null && f.trackVelocityY != null)
        ? `${Math.round((Math.atan2(f.trackVelocityX, f.trackVelocityY) * 180 / Math.PI + 360) % 360)}\u00b0` : '';
    const tvSpd = (f.trackVelocityX != null && f.trackVelocityY != null)
        ? `${Math.round(Math.sqrt(f.trackVelocityX ** 2 + f.trackVelocityY ** 2))} kt` : '';

    const rows = [
        ['ODP', `${f.origin || ''}\u2192${f.destination || ''}`],
        ['Track', cls === 'own' ? 'OWN' : cls === 'ho' ? 'HANDOFF' : cls === 'emrg' ? 'EMERGENCY' : 'OTHER'],
        ['Facility', `${f.controllingFacility || f.reportingFacility || ''}`],
        ['Sector', f.controllingSector || ''],
        ['Squawk', f.squawk],
        ['Assigned', f.blockFloor != null && f.blockCeiling != null
            ? `FL${Math.round(f.blockFloor / 100)}B${Math.round(f.blockCeiling / 100)}`
            : f.assignedVfr
                ? (f.assignedAltitude != null ? `VFR/FL${Math.round(f.assignedAltitude / 100)}` : 'VFR')
                : f.assignedAltitude != null ? `FL${Math.round(f.assignedAltitude / 100)}` : ''],
        ['Reported', f.reportedAltitude != null ? `FL${Math.round(f.reportedAltitude / 100)}` : ''],
        ['Interim', f.interimAltitude != null ? `FL${Math.round(f.interimAltitude / 100)}` : ''],
        ['GS', f.groundSpeed != null ? `${Math.round(f.groundSpeed)} kt` : ''],
        ['Heading', heading],
        ['T/V Speed', tvSpd],
        ['Route', f.route || ''],
        ['Rules', f.flightRules || ''],
        ['STAR', f.star || ''],
        ['Coord Fix', f.coordinationFix || ''],
        ['Coord Time', f.coordinationTime || ''],
        ['ETD', f.actualDepartureTime || ''],
        ['ETA', f.eta || ''],
        ['Handoff', f.handoffEvent ? `${f.handoffEvent} ${f.handoffReceiving || ''} \u2190 ${f.handoffTransferring || ''}` : ''],
        ['HO Debug', (() => {
            const parts = [];
            const hoEvt = hoEventType(f.handoffEvent);
            if (hoEvt) parts.push(`active=${hoEvt}`);
            if (f.handoffReceiving) parts.push(`recv=${f.handoffReceiving}`);
            if (f.handoffTransferring) parts.push(`xfer=${f.handoffTransferring}`);
            if (f.handoffAccepting) parts.push(`accept=${f.handoffAccepting}`);
            const comp = hoCompletedInfo.get(f.gufi);
            if (comp) {
                const secsAgo = Math.round((performance.now() - comp.time) / 1000);
                parts.push(`completed=${secsAgo}s ago recv=${comp.receiving}`);
            }
            return parts.join(' | ');
        })()],
        ['CID', getCid(f) || (myFacility ? '' : f.computerId)],
        ['Operator', f.operator],
        ['A/C Type', f.aircraftType || ''],
        ['Reg', f.registration || ''],
        ['Wake', f.wakeCategory],
        ['Equip', f.equipmentQualifier || ''],
        ['Datalink', f.dataLinkCode],
        ['Remarks', f.remarks || ''],
        ['Last msg', f.lastMsgSource],
        ['Last seen', f.lastSeen],
    ];

    let html = '';
    for (const [label, val] of rows) {
        if (!val) continue;
        html += `<div class="fd-row"><span class="fd-label">${label}</span><span class="fd-val">${esc(String(val))}</span></div>`;
    }
    document.getElementById('fd-body').innerHTML = html;
    document.getElementById('flight-detail-section').style.display = 'block';
}

function closeFd() {
    selectedGufi = null;
    document.getElementById('flight-detail-section').style.display = 'none';
}

// ── Route line display ──
// ── QU route display system ──────────────────────────────────────────────
// Great-circle distance in nautical miles between two lat/lon points
function gcDistNm(lat1, lon1, lat2, lon2) {
    const toRad = Math.PI / 180;
    const dLat = (lat2 - lat1) * toRad;
    const dLon = (lon2 - lon1) * toRad;
    const a = Math.sin(dLat / 2) ** 2 +
        Math.cos(lat1 * toRad) * Math.cos(lat2 * toRad) * Math.sin(dLon / 2) ** 2;
    return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)) * 3440.065;  // Earth radius in nm
}

// Find closest segment on route to aircraft position, return { index, frac }
// index = segment start index, frac = 0-1 fraction along that segment
function findRouteProgress(waypoints, lat, lon, vx, vy) {
    // vx/vy = trackVelocityX/Y (knots, X=east, Y=north) — used for direction tiebreaking
    let bestDist = Infinity, bestIdx = 0, bestFrac = 0;
    const hasVel = vx != null && vy != null && (vx !== 0 || vy !== 0);

    for (let i = 0; i < waypoints.length - 1; i++) {
        const [aLat, aLon] = waypoints[i];
        const [bLat, bLon] = waypoints[i + 1];
        // Project point onto segment (flat approximation for nearby points)
        const dx = bLon - aLon, dy = bLat - aLat;
        const lenSq = dx * dx + dy * dy;
        let t = lenSq > 0 ? ((lon - aLon) * dx + (lat - aLat) * dy) / lenSq : 0;
        t = Math.max(0, Math.min(1, t));
        const pLat = aLat + t * dy, pLon = aLon + t * dx;
        let d = gcDistNm(lat, lon, pLat, pLon);
        // Direction penalty: if aircraft velocity opposes this segment direction, add penalty
        if (hasVel && lenSq > 0) {
            // Segment direction (in lon/lat space, similar to vx/vy east/north)
            const segLen = Math.sqrt(lenSq);
            const segDx = dx / segLen, segDy = dy / segLen;
            const velLen = Math.sqrt(vx * vx + vy * vy);
            const velDx = vx / velLen, velDy = vy / velLen;
            const dot = segDx * velDx + segDy * velDy;  // -1 to 1
            if (dot < 0) d += 50;  // 50nm penalty for backwards-facing segments
        }
        if (d < bestDist) { bestDist = d; bestIdx = i; bestFrac = t; }
    }
    // Also check if aircraft is closest to a waypoint directly (within forward direction)
    for (let i = 0; i < waypoints.length; i++) {
        let d = gcDistNm(lat, lon, waypoints[i][0], waypoints[i][1]);
        // For waypoint-only check, penalize waypoints that are behind the aircraft
        if (hasVel && i < waypoints.length - 1) {
            const toBearing = Math.atan2(waypoints[i][1] - lon, waypoints[i][0] - lat);
            const velBearing = Math.atan2(vx, vy);
            const angleDiff = Math.abs(((toBearing - velBearing + Math.PI * 3) % (Math.PI * 2)) - Math.PI);
            if (angleDiff > Math.PI / 2) d += 50;  // behind the aircraft
        }
        if (d < bestDist) { bestDist = d; bestIdx = Math.max(0, i - 1); bestFrac = i === 0 ? 0 : 1; }
    }
    return { index: bestIdx, frac: bestFrac };
}

// Trim route from aircraft position forward by maxNm nautical miles
// Returns { latlngs, reachedDest } — latlngs is array of [lat,lon], reachedDest is bool
function trimRouteForward(waypoints, startIdx, startFrac, maxNm) {
    if (waypoints.length < 2) return { latlngs: [], reachedDest: false };
    const result = [];
    // Interpolated start point
    const [aLat, aLon] = waypoints[startIdx];
    const [bLat, bLon] = waypoints[Math.min(startIdx + 1, waypoints.length - 1)];
    const sLat = aLat + startFrac * (bLat - aLat);
    const sLon = aLon + startFrac * (bLon - aLon);
    result.push([sLat, sLon]);

    if (maxNm === null) {
        // Full route — add all remaining waypoints
        for (let i = startIdx + 1; i < waypoints.length; i++) {
            result.push(waypoints[i]);
        }
        return { latlngs: result, reachedDest: true };
    }

    let remaining = maxNm;
    // Distance from start point to end of current segment
    const segRemain = gcDistNm(sLat, sLon, bLat, bLon);
    if (segRemain >= remaining) {
        // Trim within this segment
        const f = remaining / Math.max(segRemain, 0.001);
        result.push([sLat + f * (bLat - sLat), sLon + f * (bLon - sLon)]);
        return { latlngs: result, reachedDest: false };
    }
    remaining -= segRemain;
    result.push([bLat, bLon]);

    for (let i = startIdx + 2; i < waypoints.length; i++) {
        const segDist = gcDistNm(waypoints[i - 1][0], waypoints[i - 1][1],
            waypoints[i][0], waypoints[i][1]);
        if (segDist >= remaining) {
            const f = remaining / Math.max(segDist, 0.001);
            const pLat = waypoints[i - 1][0] + f * (waypoints[i][0] - waypoints[i - 1][0]);
            const pLon = waypoints[i - 1][1] + f * (waypoints[i][1] - waypoints[i - 1][1]);
            result.push([pLat, pLon]);
            return { latlngs: result, reachedDest: false };
        }
        remaining -= segDist;
        result.push(waypoints[i]);
    }
    return { latlngs: result, reachedDest: true };
}

// Remove a single route display by gufi
function removeRoute(gufi) {
    const r = activeRoutes.get(gufi);
    if (!r) return;
    if (r.polyline) map.removeLayer(r.polyline);
    if (r.destMarker) map.removeLayer(r.destMarker);
    activeRoutes.delete(gufi);
}

// Clear all route displays
function clearAllRoutes() {
    for (const [gufi] of activeRoutes) removeRoute(gufi);
}

// Show route line for a flight — called by QU command and dwell/detail
// minutes: number of minutes to show, null = full route, 0 = max
// persistent: if true, no 30s auto-remove (used by dwell lock / flight detail)
async function showRouteForFlight(gufi, minutes = null, persistent = false) {
    const f = flights.get(gufi);
    if (!f || !f.route) return 'NO ROUTE';

    // Fetch full route waypoints from server
    let waypoints;
    try {
        const resp = await fetch(`/api/route/${encodeURIComponent(gufi)}`);
        if (!resp.ok) return 'ROUTE RESOLVE FAILED';
        const data = await resp.json();
        waypoints = data.waypoints;
        if (!waypoints || waypoints.length < 2) return 'ROUTE NOT RESOLVED';
    } catch (e) { return 'ROUTE FETCH ERROR'; }

    // Remove existing route for this flight
    removeRoute(gufi);

    // Calculate route from aircraft's current position
    let latlngs, reachedDest;
    if (f.latitude != null && f.longitude != null && minutes !== null) {
        // Use filed speed (requestedSpeed / nasAirspeed), fall back to groundSpeed
        const speed = f.requestedSpeed || f.groundSpeed || 250;
        const mins = minutes === 0 ? 9999 : (minutes || 20);  // 0 = /M (max), default 20
        const maxNm = speed * mins / 60;
        const prog = findRouteProgress(waypoints, f.latitude, f.longitude,
            f.trackVelocityX, f.trackVelocityY);
        ({ latlngs, reachedDest } = trimRouteForward(waypoints, prog.index, prog.frac, maxNm));
        // Always start the route line from the aircraft's actual position
        if (latlngs.length > 0) {
            latlngs[0] = [f.latitude, f.longitude];
        }
    } else {
        // No position or full route requested — show entire route
        latlngs = waypoints;
        reachedDest = true;
    }

    if (latlngs.length < 2) return 'ROUTE TOO SHORT';

    const polyline = L.polyline(latlngs, {
        pane: 'routes',
        color: '#cccc44',
        weight: 2,
        opacity: 0.8,
        interactive: false
    }).addTo(map);

    // Endpoint marker: X at destination, or small solid square at truncated endpoint
    let destMarker = null;
    if (latlngs.length >= 2) {
        const last = latlngs[latlngs.length - 1];
        if (reachedDest) {
            destMarker = L.marker(last, {
                pane: 'routes',
                interactive: false,
                icon: L.divIcon({
                    className: '',
                    html: `<div style="color:#cccc44;font-family:ERAM,Consolas,monospace;font-size:${fontSize}px;text-decoration:underline;width:${fontSize}px;height:${fontSize}px;line-height:${fontSize}px;text-align:center;">X</div>`,
                    iconSize: [fontSize, fontSize],
                    iconAnchor: [fontSize / 2, fontSize / 2]
                })
            }).addTo(map);
        } else {
            const sz = Math.max(4, Math.round(fontSize * 0.4));
            destMarker = L.marker(last, {
                pane: 'routes',
                interactive: false,
                icon: L.divIcon({
                    className: '',
                    html: `<div style="width:${sz}px;height:${sz}px;background:#cccc44;"></div>`,
                    iconSize: [sz, sz],
                    iconAnchor: [sz / 2, sz / 2]
                })
            }).addTo(map);
        }
    }

    activeRoutes.set(gufi, {
        polyline,
        destMarker,
        time: persistent ? null : performance.now(),
        minutes,
        waypoints  // cached for dynamic updates
    });

    return null;  // success
}

// Update active QU routes to follow aircraft position
function updateActiveRoutes() {
    for (const [gufi, r] of activeRoutes) {
        if (!r.waypoints || r.minutes === null) continue; // full route, no trimming
        const f = flights.get(gufi);
        if (!f || f.latitude == null || f.longitude == null) continue;

        const speed = f.requestedSpeed || f.groundSpeed || 250;
        const mins = r.minutes === 0 ? 9999 : (r.minutes || 20);
        const maxNm = speed * mins / 60;
        const prog = findRouteProgress(r.waypoints, f.latitude, f.longitude,
            f.trackVelocityX, f.trackVelocityY);
        const { latlngs, reachedDest } = trimRouteForward(r.waypoints, prog.index, prog.frac, maxNm);
        if (latlngs.length > 0) latlngs[0] = [f.latitude, f.longitude];
        if (latlngs.length < 2) continue;

        r.polyline.setLatLngs(latlngs);
        // Update endpoint marker position
        if (r.destMarker) {
            r.destMarker.setLatLng(latlngs[latlngs.length - 1]);
        }
    }
}

// Auto-remove expired QU route displays (30s timeout)
setInterval(() => {
    const now = performance.now();
    for (const [gufi, r] of activeRoutes) {
        if (r.time !== null && now - r.time >= 30000) {
            removeRoute(gufi);
        }
    }
}, 1000);

setInterval(() => { if (selectedGufi) showFlightDetail(selectedGufi); }, 5000);

// ════════════════════════════════════════════════════════════════════════════
// URL-based settings persistence
// ════════════════════════════════════════════════════════════════════════════
function loadSettingsFromUrl() {
    const params = new URLSearchParams(window.location.hash.slice(1));
    myFacility = params.get('facility') || '';
    const sectors = params.get('sectors');
    mySectors = sectors ? new Set(sectors.split(',').filter(s => s)) : new Set();
    if (params.has('fdb')) showFdb = params.get('fdb') !== '0';
    if (params.has('history')) showHistory = params.get('history') !== '0';
    if (params.has('histcount')) MAX_HISTORY = parseInt(params.get('histcount')) || 5;
    if (params.has('vector')) vectorMinutes = parseInt(params.get('vector'));
    if (params.has('bndbr')) {
        const vals = params.get('bndbr').split(',').map(Number);
        BOUNDARY_CATS.forEach((cat, i) => { if (!isNaN(vals[i])) boundaryBrightness[cat] = vals[i]; });
    }
    if (params.has('fontsize')) fontSize = parseInt(params.get('fontsize')) || 10;
    if (params.has('altlow')) altFilterLow = parseInt(params.get('altlow')) || 0;
    if (params.has('althigh')) altFilterHigh = parseInt(params.get('althigh')) || 999;
    if (params.has('ldb')) ldbBrightness = parseInt(params.get('ldb'));
    if (params.has('faconly')) facilityOnly = params.get('faconly') === '1';
    if (params.has('mapbg')) showMapBg = params.get('mapbg') === '1';
    if (params.has('kb')) {
        document.getElementById('chk-mca-kb').checked = true;
        document.getElementById('mca').classList.add('show-kb');
    }
    // Transp MCA: reserved for future use
    // if (params.has('tmca')) {
    //     document.getElementById('map-container').classList.toggle('transp-mca', true);
    //     document.getElementById('chk-transp-mca').checked = true;
    // }
    if (params.has('nasrbr')) {
        const vals = params.get('nasrbr').split(',').map(Number);
        if (!isNaN(vals[0])) nasrBrightness.jroutes = vals[0];
        if (!isNaN(vals[1])) nasrBrightness.vroutes = vals[1];
        if (!isNaN(vals[2])) nasrBrightness.vors = vals[2];
        if (!isNaN(vals[3])) nasrBrightness.proc = vals[3];
    }
    if (params.has('line4')) line4Mode = params.get('line4') || 'DEST';
    if (params.has('nxlvl')) {
        const v = params.get('nxlvl');
        nexradLevel = v === '123' ? 3 : v === '23' ? 2 : v === '3' ? 1 : 0;
    }
    if (params.has('nxbr')) nexradBrightness = parseInt(params.get('nxbr'));

    // Restore map position/zoom
    if (params.has('lat') && params.has('lng') && params.has('z')) {
        const lat = parseFloat(params.get('lat'));
        const lng = parseFloat(params.get('lng'));
        const z = parseInt(params.get('z'));
        if (!isNaN(lat) && !isNaN(lng) && !isNaN(z)) map.setView([lat, lng], z);
    }

    // Apply to UI controls
    document.getElementById('sel-facility').value = myFacility;
    document.getElementById('sel-histcount').value = MAX_HISTORY;
    document.getElementById('sel-vector').value = vectorMinutes;
    for (const [cat, id] of Object.entries(BOUNDARY_CAT_SLIDER)) {
        document.getElementById(id).value = boundaryBrightness[cat];
        document.getElementById(BOUNDARY_CAT_LABEL[cat]).textContent = boundaryBrightness[cat];
    }
    document.getElementById('chk-facility-only').checked = facilityOnly;
    document.getElementById('chk-mapbg').checked = showMapBg;
    document.getElementById('sel-line4').value = line4Mode;
    document.getElementById('sel-fontsize').value = fontSize;
    document.getElementById('inp-alt-low').value = altFilterLow;
    document.getElementById('inp-alt-high').value = altFilterHigh;
    document.getElementById('rng-ldb-brightness').value = ldbBrightness;
    document.getElementById('lbl-ldb-brightness').textContent = ldbBrightness;
    document.getElementById('rng-jroutes').value = nasrBrightness.jroutes;
    document.getElementById('lbl-jroutes').textContent = nasrBrightness.jroutes;
    document.getElementById('rng-vroutes').value = nasrBrightness.vroutes;
    document.getElementById('lbl-vroutes').textContent = nasrBrightness.vroutes;
    document.getElementById('rng-vors').value = nasrBrightness.vors;
    document.getElementById('lbl-vors').textContent = nasrBrightness.vors;
    document.getElementById('rng-proc').value = nasrBrightness.proc;
    document.getElementById('lbl-proc').textContent = nasrBrightness.proc;
    document.getElementById('sel-nxlvl').value = nexradLevel === 3 ? '123' : nexradLevel === 2 ? '23' : nexradLevel === 1 ? '3' : '0';
    document.getElementById('rng-nx').value = nexradBrightness;
    document.getElementById('lbl-nx').textContent = nexradBrightness;
    updateFontSize();
    if (showMapBg) tileLayer.addTo(map);
    if (nexradLevel > 0) updateNexrad();
    // Restore NASR overlays if brightness > 0
    if (nasrBrightness.jroutes > 0) showNasrLayer('jroutes', '/api/nasr/airways?type=hi', renderAirways);
    if (nasrBrightness.vroutes > 0) showNasrLayer('vroutes', '/api/nasr/airways?type=lo', renderAirways);
    if (nasrBrightness.vors > 0) showNasrLayer('vors', '/api/nasr/navaids', renderVors);
    showBoundariesForFacility(myFacility);
}

function saveSettingsToUrl() {
    const params = new URLSearchParams();
    if (myFacility) params.set('facility', myFacility);
    if (mySectors.size) params.set('sectors', [...mySectors].join(','));
    if (!showFdb) params.set('fdb', '0');
    if (!showHistory) params.set('history', '0');
    if (MAX_HISTORY !== 5) params.set('histcount', MAX_HISTORY);
    if (vectorMinutes !== 1) params.set('vector', vectorMinutes);
    const brVals = BOUNDARY_CATS.map(c => boundaryBrightness[c]);
    const defaultBr = [60, 60, 60, 0];
    if (brVals.join(',') !== defaultBr.join(',')) params.set('bndbr', brVals.join(','));
    if (line4Mode !== 'DEST') params.set('line4', line4Mode);
    if (showMapBg) params.set('mapbg', '1');
    // if (document.getElementById('chk-transp-mca').checked) params.set('tmca', '1');
    if (fontSize !== 10) params.set('fontsize', fontSize);
    if (altFilterLow !== 0) params.set('altlow', altFilterLow);
    if (altFilterHigh !== 999) params.set('althigh', altFilterHigh);
    if (ldbBrightness !== 70) params.set('ldb', ldbBrightness);
    if (facilityOnly) params.set('faconly', '1');
    if (document.getElementById('chk-mca-kb').checked) params.set('kb', '1');
    const nasrVals = [nasrBrightness.jroutes, nasrBrightness.vroutes, nasrBrightness.vors, nasrBrightness.proc];
    const nasrDefaults = [0, 0, 0, 0];
    if (nasrVals.join(',') !== nasrDefaults.join(',')) params.set('nasrbr', nasrVals.join(','));
    if (nexradLevel > 0) params.set('nxlvl', nexradLevel === 3 ? '123' : nexradLevel === 2 ? '23' : '3');
    if (nexradBrightness !== 50) params.set('nxbr', nexradBrightness);
    // Map position/zoom
    const center = map.getCenter();
    params.set('lat', center.lat.toFixed(4));
    params.set('lng', center.lng.toFixed(4));
    params.set('z', map.getZoom());
    const hash = params.toString();
    history.replaceState(null, '', hash ? '#' + hash : window.location.pathname);
}

// ════════════════════════════════════════════════════════════════════════════
// Right-click pan (replaces default left-click drag)
// ════════════════════════════════════════════════════════════════════════════
const mapEl = document.getElementById('map');
mapEl.addEventListener('contextmenu', e => e.preventDefault());
// Prevent middle-click auto-scroll icon on the map
mapEl.addEventListener('mousedown', e => { if (e.button === 1) e.preventDefault(); });

let _rightDragging = false;
let _rightDragStart = null;

mapEl.addEventListener('mousedown', e => {
    if (e.button === 2) {
        _rightDragging = true;
        _rightDragStart = { x: e.clientX, y: e.clientY };
        mapEl.style.cursor = 'grabbing';
        e.preventDefault();
    }
});

document.addEventListener('mousemove', e => {
    if (!_rightDragging) return;
    const dx = e.clientX - _rightDragStart.x;
    const dy = e.clientY - _rightDragStart.y;
    map.panBy([-dx, -dy], { animate: false });
    _rightDragStart = { x: e.clientX, y: e.clientY };
});

document.addEventListener('mouseup', e => {
    if (e.button === 2 && _rightDragging) {
        _rightDragging = false;
        mapEl.style.cursor = '';
    }
});

// Map click: when MCA has content, left-clicking empty map inserts a ▽ location placeholder
map.on('click', (e) => {
    if (mca.text.trim().length > 0) {
        // Format lat/lon as DDMMN/DDDMMW for ERAM-style location entry
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        const latDir = lat >= 0 ? 'N' : 'S';
        const lonDir = lon >= 0 ? 'E' : 'W';
        const absLat = Math.abs(lat);
        const absLon = Math.abs(lon);
        const latDeg = Math.floor(absLat).toString().padStart(2, '0');
        const latMin = Math.round((absLat % 1) * 60).toString().padStart(2, '0');
        const lonDeg = Math.floor(absLon).toString().padStart(3, '0');
        const lonMin = Math.round((absLon % 1) * 60).toString().padStart(2, '0');
        const locStr = `${latDeg}${latMin}${latDir}/${lonDeg}${lonMin}${lonDir}`;
        mcaInsertTarget(locStr);
    }
});

// ════════════════════════════════════════════════════════════════════════════
// MCA (Message Composition Area)
// ════════════════════════════════════════════════════════════════════════════
const mca = {
    text: '',
    cursor: 0,
    overstrike: true,   // true = overstrike (_), false = insert (|)
    feedback: [],       // array of { type: 'ok'|'err'|'info', text: string }
    lastCommand: '',
    maxChars: 120,      // max total characters in preview area
    targetFlids: [],    // FLIDs/locations for ▽ characters in preview, in insertion order
};

// Get the best FLID for a flight: CID (if facility selected) or callsign
function getFlid(f) {
    if (!f) return '';
    const cid = getCid(f);
    if (cid) return cid;
    return f.callsign || '';
}

function mcaInsertChar(ch) {
    if (mca.text.length >= mca.maxChars && !mca.overstrike) {
        mca.feedback = [{ type: 'err', text: 'MESSAGE TOO LONG' }];
        mcaRender();
        return;
    }
    if (mca.overstrike && mca.cursor < mca.text.length) {
        mca.text = mca.text.substring(0, mca.cursor) + ch + mca.text.substring(mca.cursor + 1);
    } else {
        if (mca.text.length >= mca.maxChars) {
            mca.feedback = [{ type: 'err', text: 'MESSAGE TOO LONG' }];
            mcaRender();
            return;
        }
        mca.text = mca.text.substring(0, mca.cursor) + ch + mca.text.substring(mca.cursor);
    }
    mca.cursor++;
    mcaRender();
}

// Insert a target/location ▽ into MCA, storing the FLID or location string
function mcaInsertTarget(flid) {
    // Add space separator if needed (not at start, and last char isn't space)
    if (mca.text.length > 0 && mca.cursor > 0 && mca.text[mca.cursor - 1] !== ' ') {
        mca.text = mca.text.substring(0, mca.cursor) + ' ' + mca.text.substring(mca.cursor);
        mca.cursor++;
    }
    mca.text = mca.text.substring(0, mca.cursor) + '\u25bd' + mca.text.substring(mca.cursor);
    mca.targetFlids.push(flid);
    mca.cursor++;
    mcaRender();
}

function mcaBackspace() {
    if (mca.cursor > 0) {
        const ch = mca.text[mca.cursor - 1];
        mca.text = mca.text.substring(0, mca.cursor - 1) + mca.text.substring(mca.cursor);
        mca.cursor--;
        // Remove the corresponding FLID if a ▽ was deleted
        if (ch === '\u25bd') {
            // Count how many ▼ are before (and including) this position to find the right index
            let idx = 0;
            for (let i = 0; i < mca.cursor; i++) {
                if (mca.text[i] === '\u25bd') idx++;
            }
            mca.targetFlids.splice(idx, 1);
        }
        mcaRender();
    }
}

function mcaDelete() {
    if (mca.cursor < mca.text.length) {
        const ch = mca.text[mca.cursor];
        mca.text = mca.text.substring(0, mca.cursor) + mca.text.substring(mca.cursor + 1);
        if (ch === '\u25bd') {
            let idx = 0;
            for (let i = 0; i < mca.cursor; i++) {
                if (mca.text[i] === '\u25bd') idx++;
            }
            mca.targetFlids.splice(idx, 1);
        }
        mcaRender();
    }
}

function mcaExecute() {
    // Resolve ▽ target/location placeholders to actual FLIDs or coordinates
    let resolved = mca.text;
    const flids = [...mca.targetFlids];
    let flidIdx = 0;
    resolved = resolved.replace(/\u25bd/g, () => flids[flidIdx++] || '');
    const cmd = resolved.trim();
    mca.lastCommand = mca.text;
    mca.text = '';
    mca.cursor = 0;
    mca.targetFlids = [];
    if (!cmd) { mcaRender(); return; }
    const result = processCommand(cmd);
    if (result instanceof Promise) {
        // Async command (e.g., QU) — show pending then update when done
        mca.feedback = [{ type: 'info', text: 'PROCESSING...' }];
        mcaRender();
        result.then(r => { mca.feedback = r.feedback || []; mcaRender(); });
    } else {
        mca.feedback = result.feedback || [];
        mcaRender();
    }
}

function mcaClear() {
    mca.text = '';
    mca.cursor = 0;
    mca.feedback = [];
    mca.targetFlids = [];
    mcaRender();
}

function mcaRecall() {
    mca.text = mca.lastCommand;
    mca.cursor = mca.text.length;
    mcaRender();
}

function mcaRender() {
    const previewEl = document.getElementById('mca-preview');
    const feedbackEl = document.getElementById('mca-feedback');

    // Preview: text with blinking cursor (backtick → ⵔ︎ display)
    const mcaDisp = t => esc(t).replace(/`/g, '\u2D54\uFE0E');
    const before = mcaDisp(mca.text.substring(0, mca.cursor));
    if (mca.overstrike) {
        // Overstrike: cursor replaces character at position (or shows _ at end)
        const after = mca.cursor < mca.text.length ? mcaDisp(mca.text.substring(mca.cursor + 1)) : '';
        previewEl.innerHTML = before + '<span class="mca-cursor">_</span>' + after;
    } else {
        // Insert: cursor between characters (thin bar)
        const after = mcaDisp(mca.text.substring(mca.cursor));
        previewEl.innerHTML = before + '<span class="mca-cursor">|</span>' + after;
    }

    // Feedback area
    if (mca.feedback.length === 0) {
        feedbackEl.innerHTML = '';
    } else {
        feedbackEl.innerHTML = mca.feedback.map(f => {
            if (f.type === 'ok') return '<span style="color:#44cc44;">\u2713</span> ' + esc(f.text);
            if (f.type === 'err') return '<span style="color:#cc4444;">\u2717</span> ' + esc(f.text);
            return esc(f.text);
        }).join('\n');
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Command processor
// ════════════════════════════════════════════════════════════════════════════

// Find flight by FLID: CID (facility-specific only), callsign, or squawk
function findFlight(id) {
    const needle = id.toUpperCase();
    // CID match — only for selected facility's CID
    // Priority: 1) ACTIVE + visible + not dedup-hidden, 2) ACTIVE, 3) any
    if (myFacility) {
        let activeFallback = null;
        let anyFallback = null;
        for (const [gufi, f] of flights) {
            const cid = f.computerIds && f.computerIds[myFacility];
            if (cid && cid.toUpperCase() === needle) {
                const active = !f.flightStatus || f.flightStatus === 'ACTIVE';
                if (active && isVisible(f) && !isDedupHidden(gufi, f)) return f;
                if (active && !activeFallback) activeFallback = f;
                if (!anyFallback) anyFallback = f;
            }
        }
        if (activeFallback) return activeFallback;
        if (anyFallback) return anyFallback;
    } else {
        for (const f of flights.values()) {
            if (f.computerId && f.computerId.toUpperCase() === needle) return f;
        }
    }
    // Then callsign match — prefer visible
    let csFallback = null;
    for (const [gufi, f] of flights) {
        if (f.callsign?.toUpperCase() === needle) {
            if (isVisible(f) && !isDedupHidden(gufi, f)) return f;
            if (!csFallback) csFallback = f;
        }
    }
    if (csFallback) return csFallback;
    // Then squawk match
    for (const f of flights.values()) {
        if (f.squawk === needle) return f;
    }
    return null;
}

// Parse altitude string (2-3 digit FL) → feet, returns null if invalid
function parseAltitude(s) {
    if (!s || !/^\d{2,3}$/.test(s)) return null;
    return parseInt(s) * 100;
}

// Resolve multiple FLIDs (split by /) → { found: [flight...], notFound: [string...] }
function resolveFlids(flids) {
    const found = [], notFound = [];
    for (const flid of flids) {
        const f = findFlight(flid);
        if (f) found.push(f);
        else notFound.push(flid);
    }
    return { found, notFound };
}

// Check if a flight is owned by our position (own or handoff to us)
function isOwnTrack(f) {
    const cls = classifyTrack(f);
    return cls === 'own' || cls === 'ho';
}

// Standard rejection for commands requiring track ownership
function rejectNotOwned(cmdName, f) {
    return { feedback: [
        { type: 'err', text: 'REJECT - NOT YOUR TRACK' },
        { type: 'info', text: cmdName },
        { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
    ]};
}

// Invalidate a single marker's hash to force rebuild on next render
function invalidateMarker(gufi) {
    const m = markers.get(gufi);
    if (m) { const el = m.getElement(); if (el) el._lastHash = ''; }
    lastRenderTime = 0;
}

function processCommand(cmd) {
    const parts = cmd.trim().split(/\s+/);
    const verb = parts[0]?.toUpperCase();

    // <1-9> <FLID> — Position data block (numpad layout)
    if (/^[1-9]$/.test(verb) && parts.length >= 2) {
        const pos = parseInt(verb);
        const flid = parts.slice(1).join('').toUpperCase();
        const f = findFlight(flid);
        if (f) {
            dbPositions.set(f.gufi, pos);
            // Invalidate marker hash so it rebuilds immediately
            const m = markers.get(f.gufi);
            if (m) { const el = m.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'OFFSET DATA BLK' },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // //<FLID> or // <FLID> — Toggle VCI (Visual Communications Indicator)
    {
        let vciFlid = null;
        if (verb === '//' && parts.length >= 2) vciFlid = parts.slice(1).join('').toUpperCase();
        else if (verb.startsWith('//') && verb.length > 2) vciFlid = verb.substring(2).toUpperCase();
        if (vciFlid) {
            const f = findFlight(vciFlid);
            if (f) {
                const cls = classifyTrack(f);
                if (!shouldShowFdb(f.gufi, cls)) {
                    return { feedback: [{ type: 'err', text: 'NOT IN FDB' }] };
                }
                if (vciActive.has(f.gufi)) vciActive.delete(f.gufi);
                else vciActive.add(f.gufi);
                const m4 = markers.get(f.gufi);
                if (m4) { const el = m4.getElement(); if (el) el._lastHash = ''; }
                lastRenderTime = 0;
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: 'TOGGLE ON-FREQUENCY' },
                    { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
                ]};
            }
            return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
        }
    }

    // /<0-3> <FLID> — Set individual leader line length
    if (/^\/[0-3]$/.test(verb) && parts.length >= 2) {
        const level = parseInt(verb.charAt(1));
        const flid = parts.slice(1).join('').toUpperCase();
        const f = findFlight(flid);
        if (f) {
            ldrLenOverrides.set(f.gufi, level);
            const m3 = markers.get(f.gufi);
            if (m3) { const el = m3.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: `LDR LEN ${level}` },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // QU [minutes] [FLID...] — Route display
    // QU alone clears all route lines
    // QU <FLID> clears route for that flight
    // QU <minutes> <FLID> shows route for N minutes (default 20, /M = max)
    // Multiple FLIDs: QU 30 JBU123/429/AAL924
    if (verb === 'QU') {
        if (parts.length === 1) {
            // QU alone — clear all QU route displays
            clearAllRoutes();
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'ROUTE DISPLAY' }
            ]};
        }

        // Parse: first non-verb token might be minutes or /M, rest are FLIDs
        // Minutes: 1-99 (1-2 digit number). CID: always 3 alphanumeric chars.
        let minutes = 20;  // default
        let flidStart = 1;
        const arg1 = parts[1].toUpperCase();
        if (arg1 === '/M') {
            minutes = 0;  // 0 = max/full route
            flidStart = 2;
        } else if (/^\d{1,2}$/.test(arg1) && parts.length > 2) {
            // 1-2 digit number with more args — treat as minutes
            minutes = parseInt(arg1);
            flidStart = 2;
        }
        // 3+ char tokens (including 3-digit CIDs) treated as FLIDs

        // Remaining parts are FLIDs — may contain slashes for multiple (QU 30 JBU123/429/AAL924)
        const flidStr = parts.slice(flidStart).join(' ').toUpperCase();
        if (!flidStr) {
            // QU <minutes> with no FLID — error
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        // Split on / to get individual FLIDs
        const flids = flidStr.split('/').map(s => s.trim()).filter(s => s);

        // If single FLID with no minutes specified and arg1 is the FLID itself
        if (flidStart === 1) {
            // QU <FLID> — if flight has active route, clear it; else show default 20 min
            if (flids.length === 1) {
                const f = findFlight(flids[0]);
                if (!f) {
                    return { feedback: [
                        { type: 'err', text: 'REJECT - FLID NOT STORED' },
                        { type: 'info', text: 'REROUTE' },
                        { type: 'info', text: cmd }
                    ]};
                }
                if (activeRoutes.has(f.gufi)) {
                    removeRoute(f.gufi);
                    return { feedback: [
                        { type: 'ok', text: 'ACCEPT' },
                        { type: 'info', text: 'ROUTE DISPLAY' },
                        { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
                    ]};
                }
            }
        }

        // Show route for each FLID
        const found = [];
        const notFound = [];
        for (const flid of flids) {
            const f = findFlight(flid);
            if (f) found.push(f);
            else notFound.push(flid);
        }
        if (found.length === 0) {
            return { feedback: [
                { type: 'err', text: 'REJECT - FLID NOT STORED' },
                { type: 'info', text: 'REROUTE' },
                { type: 'info', text: cmd }
            ]};
        }

        // Async: fetch routes for all found flights
        return (async () => {
            const feedback = [{ type: 'ok', text: 'ACCEPT' }];
            for (const f of found) {
                const err = await showRouteForFlight(f.gufi, minutes, false);
                if (err) {
                    feedback.push({ type: 'err', text: `${f.callsign}: ${err}` });
                } else {
                    feedback.push({ type: 'info', text: 'ROUTE DISPLAY' });
                    feedback.push({ type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` });
                }
            }
            if (notFound.length > 0) {
                for (const nf of notFound) {
                    feedback.push({ type: 'err', text: `REJECT - FLID NOT STORED` });
                    feedback.push({ type: 'info', text: `QU ${nf}` });
                }
            }
            return { feedback };
        })();
    }

    // QF <callsign> — Query Flight plan → show in RA
    if (verb === 'QF' && parts.length >= 2) {
        const cs = parts.slice(1).join('').toUpperCase();
        const f = findFlight(cs);
        if (f) {
            showFlightInRA(f);
            return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // QD — clear Response Area
    if (verb === 'QD') {
        document.getElementById('ra-content').textContent = '';
        return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
    }

    // QL [sector ...] — Quick Look: force FDB on specific sectors; QL alone clears
    if (verb === 'QL') {
        const secs = parts.slice(1).map(s => s.toUpperCase());
        quickLookSectors.clear();
        secs.forEach(s => quickLookSectors.add(s));
        invalidateAllMarkers();
        lastRenderTime = 0;
        const feedback = [
            { type: 'ok', text: 'ACCEPT' },
            { type: 'info', text: 'QUICK LOOK' },
        ];
        if (secs.length > 0) feedback.push({ type: 'info', text: secs.join(' ') });
        return { feedback };
    }

    // QP J <FLID> — toggle standard DRI (5nm halo); QP T <FLID> — toggle reduced DRI (3nm halo)
    if (verb === 'QP') {
        if (parts.length < 3) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }
        const driType = parts[1].toUpperCase();
        if (driType === 'J' || driType === 'T') {
            const flid = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flid);
            if (f) {
                const cid = getCid(f) || '???';
                // Reduced DRI (T): only eligible at or below FL230
                if (driType === 'T') {
                    const alt = f.reportedAltitude ?? f.assignedAltitude;
                    if (alt != null && alt > 23000) {
                        return { feedback: [
                            { type: 'err', text: `REJECT - ${cid} NOT ELIGIBLE` },
                            { type: 'err', text: 'FOR REDUCED SEPARATION' },
                            { type: 'info', text: `REQ/DELETE DRI ${f.callsign}` }
                        ]};
                    }
                }
                const existing = driActive.get(f.gufi);
                if (existing === driType) {
                    driActive.delete(f.gufi);
                } else {
                    driActive.set(f.gufi, driType);
                }
                lastRenderTime = 0;
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: 'REQ/DELETE DRI' },
                    { type: 'info', text: `${f.callsign}/${cid}` }
                ]};
            }
            return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
        }
        return { feedback: [{ type: 'err', text: 'INVALID DRI TYPE' }] };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QZ <altitude> <FLID> — Set assigned (flight plan) altitude
    // QZ VFR <FLID> | QZ VFR/<alt> <FLID> | QZ OTP <FLID>
    // QZ <floor>B<ceiling> <FLID> — Block altitude
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QZ') {
        if (parts.length < 2) {
            return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
        }

        const arg1 = parts[1].toUpperCase();

        // QZ VFR <FLID> or QZ VFR/<alt> <FLID> or QZ OTP <FLID>
        if (arg1 === 'VFR' || arg1.startsWith('VFR/') || arg1 === 'OTP') {
            let rules, altFeet = null;
            if (arg1 === 'OTP') {
                rules = 'OTP';
            } else if (arg1.startsWith('VFR/')) {
                rules = 'VFR';
                const altStr = arg1.substring(4);
                altFeet = parseAltitude(altStr);
                if (altFeet == null) return { feedback: [{ type: 'err', text: 'INVALID ALTITUDE' }] };
            } else {
                rules = 'VFR';
            }
            const flidStr = parts.slice(2).join('').toUpperCase();
            if (!flidStr) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('ASSIGNED ALT', f);
            localAssignedAlt.set(f.gufi, { feet: altFeet, rules, block: null });
            invalidateMarker(f.gufi);
            const altDisp = altFeet != null ? '/' + String(Math.round(altFeet / 100)).padStart(3, '0') : '';
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'ASSIGNED ALT' },
                { type: 'info', text: `${f.callsign || '???'}/${rules}${altDisp}` }
            ]};
        }

        // QZ <floor>B<ceiling> <FLID> — Block altitude
        const blockMatch = arg1.match(/^(\d{2,3})B(\d{2,3})$/);
        if (blockMatch) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            if (!flidStr) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('ASSIGNED ALT', f);
            const floor = parseInt(blockMatch[1]) * 100;
            const ceil = parseInt(blockMatch[2]) * 100;
            const blockDisp = blockMatch[1].padStart(3, '0') + 'B' + blockMatch[2].padStart(3, '0');
            localAssignedAlt.set(f.gufi, { feet: floor, rules: null, block: blockDisp });
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'ASSIGNED ALT' },
                { type: 'info', text: `${f.callsign || '???'}/${blockDisp}` }
            ]};
        }

        // QZ <altitude> <FLID> — Normal assigned altitude
        const altFeet = parseAltitude(arg1);
        if (altFeet != null) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            if (!flidStr) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('ASSIGNED ALT', f);
            localAssignedAlt.set(f.gufi, { feet: altFeet, rules: null, block: null });
            invalidateMarker(f.gufi);
            const altDisp = String(Math.round(altFeet / 100)).padStart(3, '0');
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'ASSIGNED ALT' },
                { type: 'info', text: `${f.callsign || '???'}/${altDisp}` }
            ]};
        }

        // QZ <FLID> with no altitude — error
        return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QQ <altitude> <FLID...> — Set interim altitude
    // QQ R<alt> <FLID> — Set interim + reported altitude
    // QQ L<alt> <FLID> — Set local interim altitude
    // QQ P<alt> <FLID> — Set procedure altitude
    // QQ <FLID> — Clear interim/procedure altitude
    // QQ L <FLID> — Clear local interim altitude
    // Multiple FLIDs: QQ 110 JBU123/429/AAL924
    // Override: QQ /TT P150 JBU123
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QQ') {
        if (parts.length < 2) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        // Check for /TT override prefix (skip logic checks)
        let argStart = 1;
        if (parts[1].toUpperCase() === '/TT' || parts[1] === '///') {
            argStart = 2;
            if (parts.length < 3) return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        const qqArg1 = parts[argStart].toUpperCase();

        // QQ L <FLID> — Clear local interim altitude (L followed by space then FLID)
        if (qqArg1 === 'L' && parts.length > argStart + 1) {
            const qqFlids = parts.slice(argStart + 1).join('').toUpperCase().split('/').filter(s => s);
            const qqRes = resolveFlids(qqFlids);
            if (qqRes.found.length === 0) {
                return { feedback: [
                    { type: 'err', text: 'REJECT - CID NOT STORED' },
                    { type: 'info', text: 'INTERIM ALT' },
                    { type: 'info', text: `QQ ${parts.slice(1).join(' ')}` }
                ]};
            }
            const qqFb = [{ type: 'ok', text: 'ACCEPT' }, { type: 'info', text: 'INTERIM ALT' }];
            for (const f of qqRes.found) {
                const li = localInterimAlt.get(f.gufi);
                if (li && li.type === 'L') {
                    localInterimAlt.delete(f.gufi);
                    invalidateMarker(f.gufi);
                    qqFb.push({ type: 'info', text: `${f.callsign || '???'}/CLR` });
                } else {
                    qqFb.push({ type: 'err', text: 'REJECT - NO INTERIM ALTITUDE' });
                    qqFb.push({ type: 'info', text: `QQ ${getCid(f) || f.callsign || '???'}` });
                }
            }
            return { feedback: qqFb };
        }

        // Parse altitude prefix: R, L, P, or plain
        let qqAltPrefix = '';
        let qqAltArg = qqArg1;
        if (/^[RLP]\d/.test(qqArg1)) {
            qqAltPrefix = qqArg1.charAt(0);
            qqAltArg = qqArg1.substring(1);
        }

        const qqAltFeet = parseAltitude(qqAltArg);
        const qqFlidAfter = parts.slice(argStart + 1).join('').toUpperCase();

        // QQ [R|L|P]<altitude> <FLID...> — Set interim/procedure/local altitude
        if (qqAltFeet != null && qqFlidAfter) {
            const qqFlids = qqFlidAfter.split('/').filter(s => s);
            const qqRes = resolveFlids(qqFlids);
            if (qqRes.found.length === 0) {
                return { feedback: [
                    { type: 'err', text: 'REJECT - CID NOT STORED' },
                    { type: 'info', text: 'INTERIM ALT' },
                    { type: 'info', text: `QQ ${parts.slice(1).join(' ')}` }
                ]};
            }
            const qqAltDisp = String(Math.round(qqAltFeet / 100)).padStart(3, '0');
            const qqFb = [];
            let qqAnyOk = false;
            for (const f of qqRes.found) {
                // Ownership check: QQ L (local interim) exempt; all others require ownership
                if (qqAltPrefix !== 'L' && !isOwnTrack(f)) {
                    qqFb.push({ type: 'err', text: 'REJECT - NOT YOUR TRACK' });
                    qqFb.push({ type: 'info', text: `INTERIM ALT ${f.callsign || '???'}` });
                    continue;
                }
                const itype = qqAltPrefix === 'P' ? 'P' : qqAltPrefix === 'L' ? 'L' : 'I';
                localInterimAlt.set(f.gufi, { feet: qqAltFeet, type: itype });
                if (qqAltPrefix === 'R') localReportedAlt.set(f.gufi, qqAltFeet);
                invalidateMarker(f.gufi);
                qqFb.push({ type: 'info', text: `${f.callsign || '???'}/${qqAltDisp}` });
                qqAnyOk = true;
            }
            if (qqAnyOk) qqFb.unshift({ type: 'ok', text: 'ACCEPT' }, { type: 'info', text: 'INTERIM ALT' });
            for (const nf of qqRes.notFound) {
                qqFb.push({ type: 'err', text: 'REJECT - CID NOT STORED' });
                qqFb.push({ type: 'info', text: `QQ ${nf}` });
            }
            return { feedback: qqFb };
        }

        // QQ P<alt> or QQ R<alt> with no FLID — error (prefixed altitudes require a FLID)
        if (qqAltFeet != null && qqAltPrefix) {
            return { feedback: [
                { type: 'err', text: 'REJECT - CID NOT STORED' },
                { type: 'info', text: 'INTERIM ALT' },
                { type: 'info', text: `QQ ${parts.slice(1).join(' ')}` }
            ]};
        }

        // QQ <FLID> — Clear interim/procedure altitude
        // (includes bare numbers like QQ 046 where 046 is a CID, not an altitude)
        const qqClearStr = parts.slice(argStart).join('').toUpperCase();
        const qqClearFlids = qqClearStr.split('/').filter(s => s);
        const qqClearRes = resolveFlids(qqClearFlids);
        if (qqClearRes.found.length === 0) {
            return { feedback: [
                { type: 'err', text: 'REJECT - CID NOT STORED' },
                { type: 'info', text: 'INTERIM ALT' },
                { type: 'info', text: `QQ ${parts.slice(1).join(' ')}` }
            ]};
        }
        const qqClearFb = [];
        let qqClearAnyOk = false;
        for (const f of qqClearRes.found) {
            if (!isOwnTrack(f)) {
                qqClearFb.push({ type: 'err', text: 'REJECT - NOT YOUR TRACK' });
                qqClearFb.push({ type: 'info', text: `INTERIM ALT ${f.callsign || '???'}` });
                continue;
            }
            const li = localInterimAlt.get(f.gufi);
            const hasSwimInterim = f.interimAltitude != null;
            if (li || hasSwimInterim) {
                localInterimAlt.delete(f.gufi);
                invalidateMarker(f.gufi);
                qqClearFb.push({ type: 'info', text: `${f.callsign || '???'}/CLR` });
                qqClearAnyOk = true;
            } else {
                qqClearFb.push({ type: 'err', text: 'REJECT - NO INTERIM ALTITUDE' });
                qqClearFb.push({ type: 'info', text: 'INTERIM ALT' });
                qqClearFb.push({ type: 'info', text: `QQ ${getCid(f) || f.callsign || '???'}` });
            }
        }
        if (qqClearAnyOk) qqClearFb.unshift({ type: 'ok', text: 'ACCEPT' }, { type: 'info', text: 'INTERIM ALT' });
        return { feedback: qqClearFb };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QR <altitude> <FLID> — Set controller-entered reported altitude (CERA)
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QR') {
        if (parts.length < 3) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }
        const altFeet = parseAltitude(parts[1].toUpperCase());
        if (altFeet == null) {
            return { feedback: [{ type: 'err', text: 'INVALID ALTITUDE' }] };
        }
        const flidStr = parts.slice(2).join('').toUpperCase();
        const f = findFlight(flidStr);
        if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
        if (!isOwnTrack(f)) return rejectNotOwned('REPORTED ALT', f);
        localReportedAlt.set(f.gufi, altFeet);
        invalidateMarker(f.gufi);
        const altDisp = String(Math.round(altFeet / 100)).padStart(3, '0');
        return { feedback: [
            { type: 'ok', text: 'ACCEPT' },
            { type: 'info', text: 'REPORTED ALT' },
            { type: 'info', text: `${f.callsign || '???'}/${altDisp}` }
        ]};
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QS — Heading/Speed/Free text (HSF) data
    // QS `<text> <FLID>   — set free text (backtick = ⵔ clear weather symbol)
    // QS <heading> <FLID>  — set heading (3-digit, 001-360)
    // QS /<speed> <FLID>   — set speed
    // QS */ <FLID>         — delete heading
    // QS /* <FLID>         — delete speed
    // QS * <FLID>          — delete all HSF
    // QS <FLID>            — toggle HSF display on line 4
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QS') {
        if (parts.length < 2) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        const qsArg1 = parts[1];
        const qsArg1Up = qsArg1.toUpperCase();

        // QS * <FLID> — delete all HSF
        if (qsArg1 === '*' && parts.length >= 3) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            hsfData.delete(f.gufi);
            hsfShowMap.delete(f.gufi);
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'CLR ALL HSF' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS */ <FLID> — delete heading
        if (qsArg1 === '*/' && parts.length >= 3) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            const hsf = hsfData.get(f.gufi);
            if (hsf) { hsf.heading = null; if (!hsf.speed && !hsf.freeText) { hsfData.delete(f.gufi); hsfShowMap.delete(f.gufi); } }
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'CLR HEADING' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS /* <FLID> — delete speed
        if (qsArg1 === '/*' && parts.length >= 3) {
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            const hsf = hsfData.get(f.gufi);
            if (hsf) { hsf.speed = null; if (!hsf.heading && !hsf.freeText) { hsfData.delete(f.gufi); hsfShowMap.delete(f.gufi); } }
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'CLR SPEED' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS `<text> <FLID> — set free text (backtick prefix)
        if (qsArg1.startsWith('`') && parts.length >= 3) {
            const text = qsArg1.substring(1) + (parts.length > 3 ? ' ' + parts.slice(2, -1).join(' ') : '');
            const flidStr = parts[parts.length - 1].toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            const hsf = hsfData.get(f.gufi) || {};
            hsf.freeText = text.toUpperCase();
            hsf.heading = null;
            hsf.speed = null;
            hsfData.set(f.gufi, hsf);
            hsfShowMap.add(f.gufi);
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'FDB DATA' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS /<speed> <FLID> — set speed (/ prefix required)
        // Speed formats: /S<knots>, /M<mach>, /M<mach>+, /M<mach>-, /<knots>+, /<knots>-
        if (qsArg1.startsWith('/') && qsArg1.length > 1 && parts.length >= 3) {
            const spdVal = qsArg1.substring(1).toUpperCase();
            let qsSpeed = null;
            // S<knots>
            const sMatch = /^S(\d{1,4})$/i.exec(spdVal);
            if (sMatch) qsSpeed = 'S' + sMatch[1];
            // M<digits>[+/-]
            if (!qsSpeed) {
                const mMatch = /^M(\d{1,3})([+-]?)$/i.exec(spdVal);
                if (mMatch) qsSpeed = 'M' + mMatch[1] + mMatch[2];
            }
            // <digits>+/-
            if (!qsSpeed) {
                const kMatch = /^(\d{1,4})([+-])$/.exec(spdVal);
                if (kMatch) qsSpeed = kMatch[1] + kMatch[2];
            }
            if (!qsSpeed) return { feedback: [{ type: 'err', text: 'INVALID SPEED FORMAT' }] };
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
            const hsf = hsfData.get(f.gufi) || { heading: null, speed: null, freeText: null };
            hsf.speed = qsSpeed;
            hsf.freeText = null;
            hsfData.set(f.gufi, hsf);
            hsfShowMap.add(f.gufi);
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'FDB DATA' },
                { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
            ]};
        }

        // QS <heading> <FLID> — set heading
        // Heading formats: H<degrees 001-360>, <degrees>L, <degrees>R (deviation)
        if (parts.length >= 3) {
            const val = qsArg1Up;
            let qsHeading = null;
            // H<degrees>
            const hMatch = /^H(\d{1,3})$/i.exec(val);
            if (hMatch) {
                const deg = parseInt(hMatch[1]);
                if (deg >= 1 && deg <= 360) qsHeading = 'H' + String(deg).padStart(3, '0');
            }
            // Heading deviation: <digits>L or <digits>R
            if (!qsHeading) {
                const devMatch = /^(\d{1,3})([LR])$/i.exec(val);
                if (devMatch) {
                    const deg = parseInt(devMatch[1]);
                    if (deg >= 1 && deg <= 180) qsHeading = String(deg) + devMatch[2].toUpperCase();
                }
            }
            if (qsHeading) {
                const flidStr = parts.slice(2).join('').toUpperCase();
                const f = findFlight(flidStr);
                if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
                if (!isOwnTrack(f)) return rejectNotOwned('HSF', f);
                const hsf = hsfData.get(f.gufi) || { heading: null, speed: null, freeText: null };
                hsf.heading = qsHeading;
                hsf.freeText = null;
                hsfData.set(f.gufi, hsf);
                hsfShowMap.add(f.gufi);
                invalidateMarker(f.gufi);
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: 'FDB DATA' },
                    { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
                ]};
            }
            // Invalid heading format if it looks like a heading attempt
            if (/^H/i.test(val) || /\d[LR]$/i.test(val)) {
                return { feedback: [{ type: 'err', text: 'INVALID HEADING FORMAT' }] };
            }
        }

        // QS <FLID> — toggle HSF display (single argument, not a heading)
        {
            const flidStr = parts.slice(1).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (f) {
                if (hsfShowMap.has(f.gufi)) hsfShowMap.delete(f.gufi);
                else hsfShowMap.add(f.gufi);
                invalidateMarker(f.gufi);
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: hsfShowMap.has(f.gufi) ? 'SHOW HSF' : 'HIDE HSF' },
                    { type: 'info', text: `${f.callsign || '???'}/${getCid(f) || '???'}` }
                ]};
            }
        }

        return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
    }

    // ═══════════════════════════════════════════════════════════════════════
    // QP A <FLID>          — acknowledge a pending point out (P→A)
    // QP <FLID>            — toggle point-out FDB (clear A indicator)
    // ═══════════════════════════════════════════════════════════════════════
    if (verb === 'QP') {
        if (parts.length < 2) {
            return { feedback: [{ type: 'err', text: 'MESSAGE TOO SHORT' }] };
        }

        // QP A <FLID> — acknowledge point out
        if (parts.length >= 3 && parts[1].toUpperCase() === 'A') {
            const flidStr = parts.slice(2).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            if (!f.pointoutOriginatingUnit && !f.pointoutReceivingUnit) {
                return { feedback: [{ type: 'err', text: 'NO POINT OUT' }] };
            }
            pointoutAcked.add(f.gufi);
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: `PO ACK ${f.callsign || '???'}` }
            ]};
        }

        // QP <FLID> — clear point-out indicator (toggle off)
        {
            const flidStr = parts.slice(1).join('').toUpperCase();
            const f = findFlight(flidStr);
            if (!f) return { feedback: [{ type: 'err', text: 'FLID NOT STORED' }] };
            // Clear point-out state from client side
            pointoutAcked.delete(f.gufi);
            // Clear the server-side point-out fields locally so P disappears
            f.pointoutOriginatingUnit = null;
            f.pointoutReceivingUnit = null;
            invalidateMarker(f.gufi);
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: `PO CLR ${f.callsign || '???'}` }
            ]};
        }
    }

    // .FIND <ident> — highlight a fix/navaid/airport on the scope
    if ((verb === '.FIND' || verb === '.F') && parts.length >= 2) {
        const ident = parts.slice(1).join('').toUpperCase();
        return (async () => {
            try {
                const resp = await fetch(`/api/nasr/find/${encodeURIComponent(ident)}`);
                if (!resp.ok) {
                    return { feedback: [{ type: 'err', text: `${ident} NOT FOUND` }] };
                }
                const data = await resp.json();
                setFindMarker(data.ident, data.lat, data.lon);
                return { feedback: [
                    { type: 'ok', text: 'ACCEPT' },
                    { type: 'info', text: `FIND ${data.ident}` }
                ]};
            } catch {
                return { feedback: [{ type: 'err', text: 'NASR DATA UNAVAILABLE' }] };
            }
        })();
    }

    // .SID/.STAR/.PROC — toggle procedure overlays on the map
    if (verb === '.SID' || verb === '.STAR' || verb === '.PROC') {
        const apiType = verb === '.SID' ? 'DP' : verb === '.STAR' ? 'STAR' : '';
        const displayType = verb === '.SID' ? 'SID' : verb === '.STAR' ? 'STAR' : 'PROC';
        const args = parts.slice(1).map(a => a.toUpperCase());

        // No args: show active procedures in Response Area
        if (args.length === 0) {
            const relevant = [...activeProcedures.entries()]
                .filter(([k]) => displayType === 'PROC' || k.startsWith(displayType + ':'));
            if (relevant.length === 0) return { feedback: [{ type: 'info', text: `NO ACTIVE ${displayType}` }] };
            const ra = document.getElementById('ra-content');
            let text = `ACTIVE ${displayType}\n`;
            for (const [k, v] of relevant) {
                const names = v.procs.map(p => `${p.airport}/${p.id}`).join(' ');
                text += `${k}: ${names}\n`;
            }
            ra.textContent = text.trimEnd();
            return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
        }

        // Ensure PROC slider brightness > 0
        if (nasrBrightness.proc <= 0) {
            nasrBrightness.proc = 60;
            document.getElementById('rng-proc').value = 60;
            document.getElementById('lbl-proc').textContent = 60;
        }

        return (async () => {
            const feedback = [];
            for (const arg of args) {
                const key = `${displayType}:${arg}`;
                // Toggle: if already active, remove
                if (activeProcedures.has(key)) {
                    const entry = activeProcedures.get(key);
                    if (map.hasLayer(entry.layer)) map.removeLayer(entry.layer);
                    activeProcedures.delete(key);
                    feedback.push({ type: 'info', text: `${key} REMOVED` });
                    continue;
                }
                // Fetch from server
                try {
                    const typeParam = apiType ? `&type=${apiType}` : '';
                    const resp = await fetch(`/api/nasr/procgeo?q=${encodeURIComponent(arg)}${typeParam}`);
                    if (!resp.ok) { feedback.push({ type: 'err', text: `${arg} NOT FOUND` }); continue; }
                    const data = await resp.json();
                    if (!data || data.length === 0) { feedback.push({ type: 'err', text: `${arg} NOT FOUND` }); continue; }
                    const group = L.layerGroup();
                    renderProcedureLegs(data, group, nasrBrightness.proc);
                    group.addTo(map);
                    activeProcedures.set(key, { layer: group, procs: data, query: arg });
                    const names = data.map(p => `${p.airport}/${p.id}`).join(' ');
                    feedback.push({ type: 'info', text: `${key}: ${names}` });
                } catch {
                    feedback.push({ type: 'err', text: 'NASR DATA UNAVAILABLE' });
                }
            }
            if (feedback.length === 0) return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
            return { feedback: [{ type: 'ok', text: 'ACCEPT' }, ...feedback] };
        })();
    }

    // .NOPROC — clear all procedure overlays
    if (verb === '.NOPROC') {
        clearProcOverlay();
        return { feedback: [{ type: 'ok', text: 'ACCEPT' }, { type: 'info', text: 'CLEAR PROCEDURES' }] };
    }

    // <FLID> — toggle FDB/LDB (single argument, not a known verb)
    if (parts.length === 1 && verb) {
        const f = findFlight(verb);
        if (f) {
            const cls = classifyTrack(f);
            const currentlyFdb = shouldShowFdb(f.gufi, cls);
            // Controlled flights (own/ho) cannot be toggled to LDB
            if (currentlyFdb && (cls === 'own' || cls === 'ho')) {
                return { feedback: [
                    { type: 'err', text: 'USER ACTION NOT ALLOWED ON A\nCONTROLLED FLIGHT' },
                    { type: 'info', text: `FORCED DATA BLK ${f.callsign}` }
                ]};
            }
            // Point-out tracks cannot be toggled to LDB — use QP <FLID> instead
            if (currentlyFdb && getPointoutIndicator(f)) {
                return { feedback: [
                    { type: 'err', text: 'POINT OUT ACTIVE — USE QP' },
                    { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
                ]};
            }
            fdbOverrides.set(f.gufi, !currentlyFdb);
            // Invalidate marker hash so it rebuilds immediately
            const m2 = markers.get(f.gufi);
            if (m2) { const el = m2.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: currentlyFdb ? 'SUPPRESS DATA BLK' : 'FORCE DATA BLK' },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
    }

    return { feedback: [{ type: 'err', text: 'INVALID ENTRY' }] };
}

function showFlightInRA(f) {
    const ra = document.getElementById('ra-content');
    const now = new Date();
    const zulu = String(now.getUTCHours()).padStart(2, '0') + String(now.getUTCMinutes()).padStart(2, '0');
    const cidVal = getCid(f);
    const cid = cidVal ? String(cidVal).padStart(4, '0') : '????';
    // Sector display: prefix with ARTCC handoff code if different facility
    const ctrlFac = f.controllingFacility || '';
    const ctrlSec = f.controllingSector || '??';
    const sector = (ctrlFac && myFacility && ctrlFac !== myFacility)
        ? getHandoffCode(ctrlFac) + ctrlSec
        : ctrlSec;
    const cs = f.callsign || '???';
    const type = f.aircraftType || '????';
    const equip = f.equipmentQualifier ? '/' + f.equipmentQualifier : '';
    const bcn = f.squawk || '????';
    const spd = f.groundSpeed != null ? String(Math.round(f.groundSpeed)).padStart(4, ' ') : '    ';
    const aalt = f.blockFloor != null && f.blockCeiling != null
        ? `${String(Math.round(f.blockFloor / 100)).padStart(3, '0')}B${String(Math.round(f.blockCeiling / 100)).padStart(3, '0')}`
        : f.assignedVfr
            ? (f.assignedAltitude != null ? `VFR/${String(Math.round(f.assignedAltitude / 100)).padStart(3, '0')}` : 'VFR')
            : f.assignedAltitude != null ? String(Math.round(f.assignedAltitude / 100)).padStart(3, '0') : '???';
    const origin = f.origin || '????';
    const dest = f.destination || '????';
    const route = f.route || '';
    const star = f.star || '';
    const remarks = f.remarks || '';

    let text = `${zulu}\n`;
    text += `${cid} ${cs}(${sector}) ${type}${equip}\n`;
    text += `${bcn} ${spd} ${aalt} ${origin}..\n`;
    text += `${route}${star ? '.' + star + '.' : ''}\n`;
    text += `..${dest}\n`;
    if (remarks) text += `${remarks}`;
    ra.textContent = text;
}

// ════════════════════════════════════════════════════════════════════════════
// Global keyboard capture → MCA
// ════════════════════════════════════════════════════════════════════════════
// ── Mobile keyboard bridge ──
const mcaMobileInput = document.getElementById('mca-mobile-input');
document.getElementById('mca-kb-btn').addEventListener('click', e => {
    e.stopPropagation();
    mcaMobileInput.value = '';
    mcaMobileInput.focus();
});
mcaMobileInput.addEventListener('input', () => {
    const val = mcaMobileInput.value.toUpperCase();
    mcaMobileInput.value = '';
    for (const ch of val) mcaInsertChar(ch);
});

document.addEventListener('keydown', e => {
    // Don't capture when focused on sidebar form elements (but allow our mobile input)
    const ae = document.activeElement;
    const tag = ae?.tagName;
    if ((tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') && ae !== mcaMobileInput) return;

    // Escape → clear MCA
    if (e.key === 'Escape') { clearFindMarker(); mcaClear(); e.preventDefault(); return; }

    // Ctrl+R → recall last command
    if (e.ctrlKey && (e.key === 'r' || e.key === 'R')) { mcaRecall(); e.preventDefault(); return; }

    // Ctrl+Delete → clear RA
    if (e.ctrlKey && e.key === 'Delete') {
        document.getElementById('ra-content').textContent = '';
        e.preventDefault(); return;
    }

    // PageUp / PageDown → cycle vector line minutes (0,1,2,4,8)
    const vectorSteps = [0, 1, 2, 4, 8];
    if (e.key === 'PageUp' && !e.ctrlKey) {
        const idx = vectorSteps.indexOf(vectorMinutes);
        const next = idx < vectorSteps.length - 1 ? vectorSteps[idx + 1] : vectorSteps[vectorSteps.length - 1];
        vectorMinutes = next;
        document.getElementById('sel-vector').value = vectorMinutes;
        saveSettingsToUrl();
        e.preventDefault(); return;
    }
    if (e.key === 'PageDown' && !e.ctrlKey) {
        const idx = vectorSteps.indexOf(vectorMinutes);
        const next = idx > 0 ? vectorSteps[idx - 1] : vectorSteps[0];
        vectorMinutes = next;
        document.getElementById('sel-vector').value = vectorMinutes;
        saveSettingsToUrl();
        e.preventDefault(); return;
    }

    // Enter → execute command
    if (e.key === 'Enter' && !e.ctrlKey) { mcaExecute(); e.preventDefault(); return; }

    // Ctrl+Enter → newline in preview
    if (e.key === 'Enter' && e.ctrlKey) { mcaInsertChar('\n'); e.preventDefault(); return; }

    // Arrow keys
    if (e.key === 'ArrowLeft') {
        if (mca.cursor > 0) mca.cursor--;
        mcaRender(); e.preventDefault(); return;
    }
    if (e.key === 'ArrowRight') {
        if (mca.cursor < mca.text.length) mca.cursor++;
        mcaRender(); e.preventDefault(); return;
    }

    // Home / End / Ctrl+PgUp / Ctrl+PgDn
    if (e.key === 'Home' || (e.ctrlKey && e.key === 'PageUp')) {
        mca.cursor = 0; mcaRender(); e.preventDefault(); return;
    }
    if (e.key === 'End' || (e.ctrlKey && e.key === 'PageDown')) {
        mca.cursor = mca.text.length; mcaRender(); e.preventDefault(); return;
    }

    // Backspace / Delete
    if (e.key === 'Backspace') { mcaBackspace(); e.preventDefault(); return; }
    if (e.key === 'Delete') { mcaDelete(); e.preventDefault(); return; }

    // Insert → toggle overstrike/insert mode
    if (e.key === 'Insert') { mca.overstrike = !mca.overstrike; mcaRender(); e.preventDefault(); return; }

    // Printable characters → type into MCA (uppercase)
    if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
        mcaInsertChar(e.key.toUpperCase());
        e.preventDefault();
        return;
    }
});

// ════════════════════════════════════════════════════════════════════════════
// MCA & RA box drag/drop (click to pick up, click to drop)
// ════════════════════════════════════════════════════════════════════════════
let _boxDragging = null;
let _boxDragOffset = { x: 0, y: 0 };

function clampBox(el) {
    const container = el.parentElement;
    if (!container) return;
    const cRect = container.getBoundingClientRect();
    const eRect = el.getBoundingClientRect();
    let left = eRect.left - cRect.left;
    let top = eRect.top - cRect.top;
    left = Math.max(0, Math.min(left, cRect.width - eRect.width));
    top = Math.max(0, Math.min(top, cRect.height - eRect.height));
    el.style.left = left + 'px';
    el.style.top = top + 'px';
    el.style.bottom = 'auto';
    el.style.right = 'auto';
}

function saveBoxPosition(el) {
    const key = 'boxPos_' + el.id;
    localStorage.setItem(key, JSON.stringify({ left: el.style.left, top: el.style.top }));
}

function restoreBoxPosition(el) {
    const key = 'boxPos_' + el.id;
    const saved = localStorage.getItem(key);
    if (saved) {
        try {
            const pos = JSON.parse(saved);
            if (pos.left) el.style.left = pos.left;
            if (pos.top) { el.style.top = pos.top; el.style.bottom = 'auto'; el.style.right = 'auto'; }
        } catch(e) {}
    }
    // Clamp to viewport on restore (handles window resize since last save)
    requestAnimationFrame(() => clampBox(el));
}

function dropBox() {
    if (!_boxDragging) return;
    clampBox(_boxDragging);
    saveBoxPosition(_boxDragging);
    _boxDragging.classList.remove('box-dragging');
    _boxDragging = null;
}

function setupBoxDrag(el) {
    restoreBoxPosition(el);
    el.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        e.stopPropagation();

        if (_boxDragging === el) {
            // Already dragging this box → drop it
            dropBox();
            return;
        }
        // Drop any currently dragged box
        if (_boxDragging) dropBox();
        // Pick up this box
        _boxDragging = el;
        el.classList.add('box-dragging');
        const rect = el.getBoundingClientRect();
        _boxDragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    });
}

document.addEventListener('mousemove', e => {
    if (!_boxDragging) return;
    const container = _boxDragging.parentElement;
    const cRect = container.getBoundingClientRect();
    const eRect = _boxDragging.getBoundingClientRect();
    let left = e.clientX - cRect.left - _boxDragOffset.x;
    let top = e.clientY - cRect.top - _boxDragOffset.y;
    left = Math.max(0, Math.min(left, cRect.width - eRect.width));
    top = Math.max(0, Math.min(top, cRect.height - eRect.height));
    _boxDragging.style.left = left + 'px';
    _boxDragging.style.top = top + 'px';
    _boxDragging.style.bottom = 'auto';
    _boxDragging.style.right = 'auto';
});

// Click outside the dragged box → drop it
document.addEventListener('mousedown', e => {
    if (_boxDragging && e.button === 0 && !_boxDragging.contains(e.target)) {
        dropBox();
    }
});

// Re-clamp on window resize
window.addEventListener('resize', () => {
    clampBox(document.getElementById('mca'));
    clampBox(document.getElementById('ra'));
});

setupBoxDrag(document.getElementById('mca'));
setupBoxDrag(document.getElementById('ra'));

// ════════════════════════════════════════════════════════════════════════════
// Init
// ════════════════════════════════════════════════════════════════════════════
loadSettingsFromUrl();
rebuildFacilityDropdown();
rebuildSectorCheckboxes();

// Save map position/zoom on pan/zoom (debounced)
let _mapSaveTimer = null;
map.on('moveend', () => {
    clearTimeout(_mapSaveTimer);
    _mapSaveTimer = setTimeout(saveSettingsToUrl, 500);
});
</script>
</body>
</html>
