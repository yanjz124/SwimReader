<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SFDPS Radar Display</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<style>
@font-face { font-family: 'ERAM'; src: url('ERAMv110.ttf') format('truetype'); }
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; color: #cccc44; font-family: 'ERAM', 'Consolas', 'Courier New', monospace; overflow: hidden; height: 100vh; }

/* ── Layout ── */
#app { display: flex; height: 100vh; }
#sidebar-wrapper { display: flex; flex-shrink: 0; position: relative; }
#sidebar { width: 260px; min-width: 260px; background: #111; border-right: 1px solid #333; display: flex; flex-direction: column; overflow-y: auto; overflow-x: hidden; transition: margin-left 0.2s ease; }
#sidebar.collapsed { margin-left: -260px; }
#sidebar-toggle {
    width: 20px; background: #1a1a1a; border: none; border-right: 1px solid #333;
    color: #666; cursor: pointer; display: flex; align-items: center; justify-content: center;
    font-size: 14px; padding: 0; flex-shrink: 0; z-index: 10;
    transition: color 0.15s;
}
#sidebar-toggle:hover { color: #cccc44; background: #222; }
#map-container { flex: 1; position: relative; }
#map { width: 100%; height: 100%; }

/* ── Sidebar ── */
#sidebar-header { padding: 10px 12px; border-bottom: 1px solid #333; }
#sidebar-header h2 { font-size: 13px; color: #aaa; font-weight: normal; letter-spacing: 1px; }
#connection-status { font-size: 11px; margin-top: 4px; }

.panel-section { padding: 10px 12px; border-bottom: 1px solid #222; }
.panel-label { font-size: 10px; color: #666; letter-spacing: 1.5px; margin-bottom: 8px; font-weight: bold; }

.ctrl-row { display: flex; align-items: center; margin-bottom: 6px; font-size: 11px; }
.ctrl-row label { color: #aaa; min-width: 60px; cursor: pointer; display: flex; align-items: center; gap: 6px; }
.ctrl-row select {
    flex: 1; background: #1a1a1a; color: #cccc44; border: 1px solid #333;
    padding: 3px 6px; font-family: inherit; font-size: 11px; outline: none;
}
.ctrl-row select:focus { border-color: #cccc44; }
.ctrl-row input[type="checkbox"] { accent-color: #cccc44; }

#sector-checkboxes {
    max-height: 200px; overflow-y: auto; font-size: 11px; color: #aaa;
    scrollbar-width: thin; scrollbar-color: #444 #1a1a1a;
}
#sector-checkboxes::-webkit-scrollbar { width: 6px; }
#sector-checkboxes::-webkit-scrollbar-track { background: #1a1a1a; }
#sector-checkboxes::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
#sector-checkboxes::-webkit-scrollbar-thumb:hover { background: #666; }

.traffic-row { font-size: 12px; padding: 2px 0; display: flex; justify-content: space-between; }
.traffic-row.own { color: #cccc44; }
.traffic-row.ho { color: #cccc44; }
.traffic-row.other { color: #cccc44; }
.traffic-row.total { color: #aaa; border-top: 1px solid #333; margin-top: 4px; padding-top: 6px; }

#sidebar-footer {
    margin-top: auto; padding: 8px 12px; border-top: 1px solid #333;
    font-size: 11px; color: #666;
}

/* ── Map overrides ── */
.leaflet-container {
    background: #0a0a0a !important;
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='32' height='32'%3E%3Cline x1='16' y1='8' x2='16' y2='12' stroke='white' stroke-width='1'/%3E%3Cline x1='16' y1='20' x2='16' y2='24' stroke='white' stroke-width='1'/%3E%3Cline x1='8' y1='16' x2='12' y2='16' stroke='white' stroke-width='1'/%3E%3Cline x1='20' y1='16' x2='24' y2='16' stroke='white' stroke-width='1'/%3E%3Crect x='12' y='12' width='8' height='8' fill='none' stroke='white' stroke-width='1'/%3E%3C/svg%3E") 16 16, crosshair !important;
}
.leaflet-control-zoom a { background: #222 !important; color: #cccc44 !important; border-color: #444 !important; }
.leaflet-control-attribution { display: none !important; }

/* ── Aircraft target group ── */
.ac-group { position: absolute; pointer-events: none; }

/* ── Target symbols (Table 1 — radar return present) ── */
/* Correlated Beacon: \ backslash — transponder on, correlated to flight plan */
.ac-sym-corr-bcn {
    position: absolute; width: 2px; height: 12px;
    background: #cccc44;
    transform: translate(-1px, -6px) rotate(-45deg);
    pointer-events: auto; cursor: pointer;
}
.ac-sym-corr-bcn.emrg { background: #ff4444; }

/* Reduced Separation: • dot — correlated beacon in reduced separation area (at/below FL230) */
.ac-sym-reduced-sep {
    position: absolute;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 16px; font-weight: bold; line-height: 1;
    color: #cccc44;
    transform: translate(-50%, -50%);
    pointer-events: auto; cursor: pointer;
}
.ac-sym-reduced-sep.emrg { color: #ff4444; }

/* Uncorrelated Beacon: / forward slash — transponder on, no flight plan */
.ac-sym-uncorr-bcn {
    position: absolute; width: 2px; height: 12px;
    background: #cccc44;
    transform: translate(-1px, -6px) rotate(45deg);
    pointer-events: auto; cursor: pointer;
}

/* Uncorrelated Primary: + plus — transponder off/standby */
.ac-sym-uncorr-pri {
    position: absolute; width: 12px; height: 12px;
    transform: translate(-6px, -6px);
    pointer-events: auto; cursor: pointer;
}
.ac-sym-uncorr-pri::before, .ac-sym-uncorr-pri::after {
    content: ''; position: absolute; background: #cccc44;
}
.ac-sym-uncorr-pri::before { width: 12px; height: 2px; top: 5px; left: 0; }
.ac-sym-uncorr-pri::after { width: 2px; height: 12px; top: 0; left: 5px; }

/* ── Track position symbols (Table 2 — coasting/no target) ── */
/* Flight Plan Aided (Flat) Track: hollow diamond — centered at (0,0) target position */
.ac-sym-flat-track {
    position: absolute;
    top: -4px; left: -4px;
    width: 8px; height: 8px;
    border: 1.5px solid #cccc44; background: transparent;
    transform: rotate(45deg);
    transform-origin: center;
    pointer-events: auto; cursor: pointer;
    z-index: 1;
}
.ac-sym-flat-track.emrg { border-color: #ff4444; }

/* Coast Track: # hash */
.ac-sym-coast {
    position: absolute;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 14px; font-weight: bold;
    color: #cccc44;
    transform: translate(-5px, -7px);
    pointer-events: auto; cursor: pointer;
}

/* Handoff flash — handled by JS content changes in formatLine3() */

/* ── Leader line ── */
.ac-leader { position: absolute; top: 0; left: 0; pointer-events: none; }

/* ── Data block ── */
.ac-db {
    position: absolute; white-space: pre; pointer-events: auto; cursor: default;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 10px; line-height: 12.5px; letter-spacing: 0.5px;
    padding: 1px 2px; color: #cccc44;
    text-shadow: 0 0 3px rgba(0,0,0,0.9), 1px 1px 2px rgba(0,0,0,0.8);
}
.ac-db.emrg { color: #ff4444; }
/* .ac-db.ho — handoff flash now driven by JS */

/* ── Column 0 (R / VCI) — left of data block ── */
.ac-col0 {
    position: absolute; white-space: pre; pointer-events: none;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 10px; line-height: 12.5px; letter-spacing: 0.5px;
    color: #cccc44;
    text-shadow: 0 0 3px rgba(0,0,0,0.9), 1px 1px 2px rgba(0,0,0,0.8);
}

/* ── Line 0 (P/A pointout) — above data block ── */
.ac-line0 {
    position: absolute; white-space: pre; pointer-events: none;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 10px; line-height: 12.5px; letter-spacing: 0.5px;
    text-shadow: 0 0 3px rgba(0,0,0,0.9), 1px 1px 2px rgba(0,0,0,0.8);
}
.ac-line0.po-initiated { color: #cccc44; }
.ac-line0.po-acknowledged { color: #ffffff; }

/* ── Flight detail (sidebar panel) ── */
#flight-detail-section { display: none; }
#flight-detail-section .fd-title { color: #cccc44; font-size: 12px; margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center; }
#flight-detail-section .fd-row { display: flex; gap: 8px; margin-bottom: 2px; font-size: 11px; }
#flight-detail-section .fd-label { color: #666; min-width: 60px; flex-shrink: 0; }
#flight-detail-section .fd-val { color: #cccc44; word-break: break-all; }
#flight-detail-section .fd-close { cursor: pointer; color: #666; font-size: 14px; }
#flight-detail-section .fd-close:hover { color: #ff4444; }

/* ── Target symbol at current position (character centered inside diamond) ── */
/* Uses fixed-size box + text-align/line-height to avoid font-metric centering issues */
.ac-sym-target {
    position: absolute;
    top: -10px; left: -7px;
    width: 14px; height: 14px;
    text-align: center; line-height: 14px;
    font-family: 'ERAM', 'Consolas', monospace;
    font-size: 14px; font-weight: bold;
    color: #cccc44;
    pointer-events: none;
    text-shadow: 0 0 3px rgba(0,0,0,0.9);
    z-index: 2;
}
.ac-sym-target.emrg { color: #ff4444; }

/* ── MCA (Message Composition Area) ── */
#mca {
    position: absolute; z-index: 1000;
    top: 30px; left: 30px;
    font-family: 'ERAM', 'Consolas', 'Courier New', monospace;
    user-select: none;
}
#mca.box-dragging { outline: 2px solid #fff; cursor: move; }
#mca-preview {
    background: #0a0a0a; border: 1px solid #888; color: #ffffff;
    padding: 3px 6px; min-width: 400px;
    font-size: 14px; line-height: 18px; white-space: pre; min-height: 28px;
    display: flex; align-items: center;
}
#mca-feedback {
    background: #0a0a0a; border: 1px solid #888; border-top: none; color: #ffffff;
    padding: 3px 6px; min-width: 400px;
    font-size: 14px; line-height: 18px; white-space: pre; min-height: 68px;
}

/* ── RA (Response Area) ── */
#ra {
    position: absolute; z-index: 1000;
    bottom: 30px; left: 30px;
    max-width: calc(100vw - 60px);
    font-family: 'ERAM', 'Consolas', 'Courier New', monospace;
    user-select: none;
}
#ra.box-dragging { outline: 2px solid #fff; cursor: move; }
#ra-content {
    background: #0a0a0a; border: 1px solid #888; color: #ffffff;
    padding: 3px 6px; width: 500px; min-height: 100px;
    max-height: 60vh; overflow-y: auto;
    font-size: 14px; line-height: 18px; white-space: pre-wrap; word-break: break-all;
}
</style>
</head>
<body>
<div id="app">
    <div id="sidebar-wrapper">
    <div id="sidebar">
        <div id="sidebar-header">
            <h2>SFDPS RADAR</h2>
            <div id="connection-status">Connecting...</div>
        </div>

        <div class="panel-section">
            <div class="panel-label">YOUR POSITION</div>
            <div class="ctrl-row">
                <label>Facility</label>
                <select id="sel-facility">
                    <option value="">All</option>
                </select>
            </div>
            <div style="margin-top:4px;">
                <div class="panel-label" style="margin-bottom:4px;">SECTORS</div>
                <div id="sector-checkboxes">
                    <span style="color:#666; font-size:10px;">Select facility first</span>
                </div>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">DISPLAY</div>
            <div class="ctrl-row">
                <label>Vector</label>
                <select id="sel-vector">
                    <option value="0">Off</option>
                    <option value="1" selected>1 min</option>
                    <option value="2">2 min</option>
                    <option value="4">4 min</option>
                    <option value="8">8 min</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label>LDB %</label>
                <input type="range" id="rng-ldb-brightness" min="0" max="100" value="70"
                    style="flex:1; accent-color:#cccc44;">
                <span id="lbl-ldb-brightness" style="min-width:28px; text-align:right; font-size:11px;">70</span>
            </div>
            <div class="ctrl-row">
                <label>Hist #</label>
                <select id="sel-histcount">
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5" selected>5</option>
                    <option value="6">6</option>
                    <option value="7">7</option>
                    <option value="8">8</option>
                    <option value="9">9</option>
                    <option value="10">10</option>
                </select>
            </div>
            <div class="ctrl-row">
                <label><input type="checkbox" id="chk-boundaries" checked> Boundaries</label>
            </div>
            <div class="ctrl-row">
                <label>UHI %</label>
                <input type="range" id="rng-bnd-uhi" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-uhi" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>HI %</label>
                <input type="range" id="rng-bnd-hi" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-hi" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>LO %</label>
                <input type="range" id="rng-bnd-lo" min="0" max="100" value="60" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-lo" style="min-width:28px; text-align:right; font-size:11px;">60</span>
            </div>
            <div class="ctrl-row">
                <label>APP %</label>
                <input type="range" id="rng-bnd-app" min="0" max="100" value="0" style="flex:1; accent-color:#cccc44;">
                <span id="lbl-bnd-app" style="min-width:28px; text-align:right; font-size:11px;">0</span>
            </div>
            <div class="ctrl-row">
                <label><input type="checkbox" id="chk-mapbg" checked> Map Bg</label>
            </div>
            <div class="ctrl-row">
                <label>Font</label>
                <select id="sel-fontsize">
                    <option value="8">8 px</option>
                    <option value="9">9 px</option>
                    <option value="10" selected>10 px</option>
                    <option value="11">11 px</option>
                    <option value="12">12 px</option>
                    <option value="14">14 px</option>
                </select>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">ALTITUDE FILTER</div>
            <div class="ctrl-row">
                <label>Low FL</label>
                <input type="number" id="inp-alt-low" value="0" min="0" max="999" step="10"
                    style="flex:1; background:#1a1a1a; color:#cccc44; border:1px solid #333; padding:3px 6px; font-family:inherit; font-size:11px; outline:none; width:60px;">
            </div>
            <div class="ctrl-row">
                <label>High FL</label>
                <input type="number" id="inp-alt-high" value="999" min="0" max="999" step="10"
                    style="flex:1; background:#1a1a1a; color:#cccc44; border:1px solid #333; padding:3px 6px; font-family:inherit; font-size:11px; outline:none; width:60px;">
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-label">TRAFFIC</div>
            <div id="traffic-counts">
                <div class="traffic-row own">Own <span id="cnt-own">0</span></div>
                <div class="traffic-row ho">Handoff <span id="cnt-ho">0</span></div>
                <div class="traffic-row other">Other <span id="cnt-other">0</span></div>
                <div class="traffic-row total">Total <span id="cnt-total">0</span></div>
            </div>
        </div>

        <div class="panel-section" id="flight-detail-section">
            <div class="fd-title">
                <span id="fd-title"></span>
                <span class="fd-close" onclick="closeFd()">&times;</span>
            </div>
            <div id="fd-body"></div>
        </div>

        <div id="sidebar-footer">
            <span id="stat-rate">0</span> msg/s &middot;
            <span id="stat-flights">0</span> flights &middot;
            <span id="stat-uptime">00:00:00</span>
        </div>
    </div>
    <button id="sidebar-toggle" title="Toggle sidebar">&#9664;</button>
    </div>

    <div id="map-container">
        <div id="map"></div>
        <div id="mca">
            <div id="mca-preview"><span class="mca-cursor">_</span></div>
            <div id="mca-feedback"></div>
        </div>
        <div id="ra">
            <div id="ra-content"></div>
        </div>
    </div>
</div>

<script>
// ════════════════════════════════════════════════════════════════════════════
// State
// ════════════════════════════════════════════════════════════════════════════
const flights = new Map();          // current displayed state — datablock fields updated instantly
const pendingPositions = new Map(); // buffered lat/lon awaiting next scan cycle
const flightHistory = new Map();
let MAX_HISTORY = 5;
const TRACK_COLOR = '#cccc44';
const EMRG_COLOR = '#ff4444';
const MAP_COLOR = '#555555';
const RENDER_INTERVAL = 2000;  // render repaint interval (ms)
const SCAN_INTERVAL = 12000;   // fixed 12s radar scan cycle
let lastScanTime = performance.now();

let myFacility = '';
let mySectors = new Set();
let showFdb = true;
let showHistory = true;
let vectorMinutes = 1;
let showBoundaries = true;
let selectedGufi = null;
let wsConnected = false;
let msgRate = 0;
let altFilterLow = 0;      // FL (hundreds of feet), 0 = no filter
let altFilterHigh = 999;    // FL (hundreds of feet), 999 = no filter
let fontSize = 10;          // data block font size in px
let ldbBrightness = 70;     // 0-100, opacity for LDB data blocks (0=hidden, 100=same as FDB)
let showMapBg = true;       // tile layer visible
const fdbOverrides = new Map(); // gufi → true/false — user toggle for FDB/LDB per track
const wasOwnOrHo = new Set();  // tracks that were own/ho — keeps FDB sticky when they become other
const lastVisibleAt = new Map(); // gufi → performance.now() — grace period prevents flicker on facility field changes

const knownFacilities = new Map();
const hoCompletedInfo = new Map(); // gufi → { time, receiving, transferring } — track completed handoffs for 60s O display
const dbPositions = new Map(); // gufi → position number 1-9 (data block placement)
const ldrLenOverrides = new Map(); // gufi → leader length level (0-3), default 1

// Global flash reference — updated once per 500ms tick so ALL tracks see the same phase
let flashTime = performance.now();

// Facility handoff codes — loaded from handoff-codes.json
// Structure: { default: { FAC: code }, ZDC: { PCT: code }, ... }
let handoffCodesConfig = { default: {} };

async function loadHandoffCodes() {
    try {
        const resp = await fetch('/handoff-codes.json');
        if (!resp.ok) return;
        handoffCodesConfig = await resp.json();
        console.log('[HO-Codes] Loaded', Object.keys(handoffCodesConfig.default).length, 'default codes');
    } catch (e) { console.warn('[HO-Codes]', e); }
}
loadHandoffCodes();

// Look up handoff code for a facility, respecting per-scope overrides
function getHandoffCode(facility) {
    // Per-scope override first (e.g. ZDC scope sees PCT as "E")
    if (myFacility && handoffCodesConfig[myFacility]) {
        const code = handoffCodesConfig[myFacility][facility];
        if (code) return code;
    }
    // Default codes
    const code = handoffCodesConfig.default?.[facility];
    if (code) return code;
    // Fallback: first character of facility ID
    return facility.charAt(0);
}

// ════════════════════════════════════════════════════════════════════════════
// Map setup
// ════════════════════════════════════════════════════════════════════════════
const map = L.map('map', {
    center: [39.0, -98.0],
    zoom: 6,
    dragging: false,       // disable left-click drag — we use right-click pan
    doubleClickZoom: false, // disable double-click zoom
    zoomControl: true,
    attributionControl: false,
    zoomSnap: 0.1,        // granular zoom (0.1 steps)
    zoomDelta: 0.1,       // each scroll/click zooms by 0.1
    wheelPxPerZoomLevel: 200,  // smooth scroll zoom
});

const tileLayer = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
    subdomains: 'abcd', maxZoom: 19, opacity: 0.4
}).addTo(map);

map.createPane('targets');
map.getPane('targets').style.zIndex = 450;

const markers = new Map();

// ════════════════════════════════════════════════════════════════════════════
// Canvas overlay for history dots + velocity vectors
// ════════════════════════════════════════════════════════════════════════════
const overlayCanvas = document.createElement('canvas');
overlayCanvas.style.position = 'absolute';
overlayCanvas.style.pointerEvents = 'none';
overlayCanvas.style.zIndex = '440';
map.getPane('overlayPane').appendChild(overlayCanvas);

function drawOverlay() {
    const size = map.getSize();
    if (size.x === 0 || size.y === 0) return;
    const bounds = map.getBounds();
    const topLeft = map.containerPointToLayerPoint([0, 0]);
    overlayCanvas.width = size.x;
    overlayCanvas.height = size.y;
    L.DomUtil.setPosition(overlayCanvas, topLeft);

    const ctx = overlayCanvas.getContext('2d');

    // ── History symbols (dimmer target symbols) ──
    if (showHistory) {
        const histFontSize = Math.max(fontSize, 8);  // match data block font, no zoom scaling
        ctx.font = `bold ${histFontSize}px ERAM, Consolas, monospace`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';

        for (const [gufi, hist] of flightHistory) {
            if (hist.length === 0) continue;
            const f = flights.get(gufi);
            if (!f || f.latitude == null) continue;
            if (!isVisible(f)) continue;

            const color = isEmergency(f) ? EMRG_COLOR : TRACK_COLOR;

            for (let i = 0; i < hist.length; i++) {
                if (!bounds.contains([hist[i].lat, hist[i].lon])) continue;
                const pt = map.latLngToLayerPoint([hist[i].lat, hist[i].lon]);
                const x = pt.x - topLeft.x;
                const y = pt.y - topLeft.y;
                ctx.globalAlpha = 0.30;  // uniform dim for all history symbols
                ctx.fillStyle = color;
                ctx.fillText(hist[i].sym || '\\', x, y);
            }
        }
    }

    // ── Velocity vectors ──
    if (vectorMinutes > 0) {
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.5;
        for (const [gufi, f] of flights) {
            if (f.latitude == null || f.longitude == null) continue;
            if (f.trackVelocityX == null || f.trackVelocityY == null) continue;
            if (!isVisible(f)) continue;
            if (!bounds.contains([f.latitude, f.longitude])) continue;

            const color = isEmergency(f) ? EMRG_COLOR : TRACK_COLOR;

            const dLat = f.trackVelocityY * vectorMinutes / 3600;
            const dLon = f.trackVelocityX * vectorMinutes / (3600 * Math.cos(f.latitude * Math.PI / 180));

            const startPt = map.latLngToLayerPoint([f.latitude, f.longitude]);
            const endPt = map.latLngToLayerPoint([f.latitude + dLat, f.longitude + dLon]);

            ctx.strokeStyle = color;
            ctx.beginPath();
            ctx.moveTo(startPt.x - topLeft.x, startPt.y - topLeft.y);
            ctx.lineTo(endPt.x - topLeft.x, endPt.y - topLeft.y);
            ctx.stroke();
        }
    }

    ctx.globalAlpha = 1;
}

// Clear canvas immediately on zoom start to prevent ghost shadows
map.on('zoomstart', () => {
    const ctx = overlayCanvas.getContext('2d');
    ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
});

let _overlayRafPending = false;
map.on('move zoom viewreset resize', () => {
    if (!_overlayRafPending) {
        _overlayRafPending = true;
        requestAnimationFrame(() => {
            _overlayRafPending = false;
            try { drawOverlay(); } catch(e) { console.error('[Overlay]', e); }
        });
    }
});

// ════════════════════════════════════════════════════════════════════════════
// KML sector boundaries (video maps — grey)
// ════════════════════════════════════════════════════════════════════════════
let kmlSectors = [];
const boundaryLayers = {};        // keyed by 'ARTCC:category'
let activeBoundaryArtcc = '';
const BOUNDARY_CATS = ['Ultra High', 'High Altitude', 'Low Altitude', 'Approach Control'];
const BOUNDARY_CAT_LABELS = { 'Ultra High': 'UHI', 'High Altitude': 'HI', 'Low Altitude': 'LO', 'Approach Control': 'APP' };
const BOUNDARY_CAT_SLIDER = { 'Ultra High': 'rng-bnd-uhi', 'High Altitude': 'rng-bnd-hi', 'Low Altitude': 'rng-bnd-lo', 'Approach Control': 'rng-bnd-app' };
const BOUNDARY_CAT_LABEL = { 'Ultra High': 'lbl-bnd-uhi', 'High Altitude': 'lbl-bnd-hi', 'Low Altitude': 'lbl-bnd-lo', 'Approach Control': 'lbl-bnd-app' };
let boundaryBrightness = { 'Ultra High': 60, 'High Altitude': 60, 'Low Altitude': 60, 'Approach Control': 0 };

function bndColor(brightness) {
    const v = Math.round(brightness * 2.55);
    return `rgb(${v},${v},${v})`;
}

async function loadKml() {
    try {
        const resp = await fetch('/api/kml/AllSectors.kml');
        if (!resp.ok) return;
        const text = await resp.text();
        const parser = new DOMParser();
        const xml = parser.parseFromString(text, 'text/xml');
        const placemarks = xml.querySelectorAll('Placemark');

        for (const pm of placemarks) {
            const name = pm.querySelector('name')?.textContent || '';
            const desc = pm.querySelector('description')?.textContent || '';
            const coordEl = pm.querySelector('coordinates');
            if (!coordEl) continue;

            const descDoc = new DOMParser().parseFromString(desc, 'text/html');
            const tds = descDoc.querySelectorAll('td');
            const data = {};
            for (let i = 0; i < tds.length - 1; i += 2) {
                data[tds[i].textContent.trim()] = tds[i + 1].textContent.trim();
            }

            const folderPath = data['FolderPath'] || '';
            const parts = folderPath.split('/');
            const artcc = parts.length >= 2 ? parts[1] : '';
            if (!artcc) continue;

            const coords = coordEl.textContent.trim().split(/\s+/).map(c => {
                const [lon, lat] = c.split(',');
                return [parseFloat(lat), parseFloat(lon)];
            }).filter(c => !isNaN(c[0]) && !isNaN(c[1]));

            if (coords.length < 2) continue;
            const catRaw = parts.length >= 3 ? parts[2] : '';
            const category = catRaw.replace(/\s*\(\d+\)$/, '');   // strip " (17)" count
            kmlSectors.push({ artcc, name, sectorId: parts.length >= 4 ? parts[3] : name, alt: data['ALT'] || '', category, coords });
        }
        const catCounts = {};
        for (const s of kmlSectors) catCounts[s.category] = (catCounts[s.category] || 0) + 1;
        console.log(`[KML] Loaded ${kmlSectors.length} sectors`, catCounts);
        // Clear any boundary layers cached before KML finished (they'd be empty)
        for (const key in boundaryLayers) {
            if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
            delete boundaryLayers[key];
        }
        if (myFacility && showBoundaries) showBoundariesForFacility(myFacility);
    } catch (e) { console.warn('[KML]', e); }
}

function showBoundariesForFacility(artcc) {
    // Remove all layers for the previous ARTCC
    if (activeBoundaryArtcc) {
        for (const cat of BOUNDARY_CATS) {
            const key = `${activeBoundaryArtcc}:${cat}`;
            if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
        }
    }
    activeBoundaryArtcc = artcc;
    if (!artcc || !showBoundaries) return;

    for (const cat of BOUNDARY_CATS) {
        const br = boundaryBrightness[cat];
        if (br <= 0) continue;
        const key = `${artcc}:${cat}`;
        if (!boundaryLayers[key]) {
            const group = L.layerGroup();
            for (const sec of kmlSectors.filter(s => s.artcc === artcc && s.category === cat)) {
                L.polyline(sec.coords, { color: bndColor(br), weight: 1, opacity: 1, interactive: false }).addTo(group);
            }
            boundaryLayers[key] = group;
        }
        boundaryLayers[key].addTo(map);
    }
}

function setBoundaryBrightness(cat, brightness) {
    boundaryBrightness[cat] = brightness;
    if (!activeBoundaryArtcc || !showBoundaries) return;
    const key = `${activeBoundaryArtcc}:${cat}`;
    if (brightness <= 0) {
        if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
        return;
    }
    const col = bndColor(brightness);
    if (!boundaryLayers[key]) {
        const group = L.layerGroup();
        for (const sec of kmlSectors.filter(s => s.artcc === activeBoundaryArtcc && s.category === cat)) {
            L.polyline(sec.coords, { color: col, weight: 1, opacity: 1, interactive: false }).addTo(group);
        }
        boundaryLayers[key] = group;
        boundaryLayers[key].addTo(map);
    } else {
        // Update color on existing polylines
        boundaryLayers[key].eachLayer(l => l.setStyle({ color: col }));
        if (!map.hasLayer(boundaryLayers[key])) boundaryLayers[key].addTo(map);
    }
}

loadKml();

// ════════════════════════════════════════════════════════════════════════════
// Visibility & classification
// ════════════════════════════════════════════════════════════════════════════
function isEmergency(f) {
    return f.squawk === '7700' || f.squawk === '7600' || f.squawk === '7500';
}

function isVisible(f) {
    if (f.latitude == null || f.longitude == null) return false;
    if (f.flightStatus && f.flightStatus !== 'ACTIVE') return false;

    // Altitude filter (reported altitude in feet → FL in hundreds)
    if (altFilterLow > 0 || altFilterHigh < 999) {
        const alt = f.reportedAltitude;
        if (alt != null) {
            const fl = Math.round(alt / 100);
            if (fl < altFilterLow || fl > altFilterHigh) return false;
        }
    }

    // No facility selected → show all
    if (!myFacility) return true;
    // Show if controlling/reporting facility matches
    const fac = f.controllingFacility || '';
    const rptFac = f.reportingFacility || '';
    if (fac === myFacility || rptFac === myFacility) return true;
    // Show if handoff involves our facility
    if (f.handoffReceiving && extractFac(f.handoffReceiving) === myFacility) return true;
    if (f.handoffTransferring && extractFac(f.handoffTransferring) === myFacility) return true;
    // Keep flights visible that were previously own/ho (prevents disappearing during handoff transitions)
    if (wasOwnOrHo.has(f.gufi)) return true;
    // Keep flights visible that have a recent completed handoff involving us
    if (hoCompletedInfo.has(f.gufi)) return true;
    // Grace period: keep recently-visible flights for 120s to prevent flicker on facility field changes
    const lastVis = lastVisibleAt.get(f.gufi);
    if (lastVis && performance.now() - lastVis < 120000) return true;
    return false;
}

function classifyTrack(f) {
    if (isEmergency(f)) return 'emrg';
    if (!myFacility) return 'other';
    // Sectors must be selected to have own/ho tracks — prevents entire ARTCC from being FDB
    if (mySectors.size === 0) return 'other';

    const fac = f.controllingFacility || f.reportingFacility || '';
    const sec = f.controllingSector || '';
    const hoEvt = hoEventType(f.handoffEvent);

    // Active handoff involving our sector(s)
    if (hoEvt) {
        const recvFac = extractFac(f.handoffReceiving);
        const xferFac = extractFac(f.handoffTransferring);
        const recvSec = extractSec(f.handoffReceiving);
        const xferSec = extractSec(f.handoffTransferring);
        const recvIsMe = recvFac === myFacility && mySectors.has(recvSec);
        const xferIsMe = xferFac === myFacility && mySectors.has(xferSec);
        if (recvIsMe || xferIsMe) return 'ho';
    }

    if (fac === myFacility && mySectors.has(sec)) return 'own';
    return 'other';
}

function extractFac(unitStr) { return unitStr ? unitStr.split('/')[0] : ''; }
function extractSec(unitStr) { if (!unitStr) return ''; const p = unitStr.split('/'); return p.length > 1 ? p[1] : ''; }

// Get CID for the observed facility (each ARTCC assigns its own CID to a flight)
function getCid(f) {
    if (myFacility && f.computerIds && f.computerIds[myFacility]) return f.computerIds[myFacility];
    return f.computerId || '';
}

// Handoff event classification — SFDPS sends INITIATION/ACCEPTANCE/UPDATE/EXECUTION
function hoEventType(evt) {
    if (!evt) return '';
    const e = evt.toUpperCase();
    if (e === 'INITIATION' || e.startsWith('PROPOS')) return 'PROPOSED';
    if (e === 'ACCEPTANCE' || e.startsWith('ACCEPT')) return 'ACCEPTED';
    if (e === 'UPDATE') return 'PROPOSED';  // UPDATE during active handoff — treat as proposed
    if (e.startsWith('EXECUT')) return 'EXECUTING';
    return '';  // CANCELLATION, COMPLETED, etc. — not active
}

// ════════════════════════════════════════════════════════════════════════════
// ERAM Full Data Block formatting
// ════════════════════════════════════════════════════════════════════════════
//
// Line 0: P/A (point out) — above data block
// Column 0: R (not your control) — left of data block, bulges out
// Line 1: Field A (callsign) + SatComm (*)
// Line 2: Field B (assigned alt) + status char + Field C (reported alt)
// Line 3: Field D (CID) + Field E (GS/Hxxx/Oxxx/EMRG)
// Line 4: Field F (destination ICAO)
//
// Status chars: C=conforming(hide Field C), T=interim, L=local interim,
//   P=procedure, ↑=climbing, ↓=descending, +=above, -=below,
//   X=no Mode C, N=no target, B=block alt, /=VFR

const LDR_DX = 20;
const LDR_DY = 0;   // flat horizontal leader line (ERAM default position 5 = right)
const LDR_LEN = 40; // leader line length
let CHAR_W = fontSize * 0.625;  // approx char width in ERAM font
let LINE_H = fontSize * 1.25;   // line-height

// Data block position offsets (numpad layout):
//   7=NW  8=N   9=NE
//   4=W   5=def 6=E
//   1=SW  2=S   3=SE
function getLeaderOffset(gufi) {
    const pos = dbPositions.get(gufi);
    const level = ldrLenOverrides.get(gufi) ?? 1;
    const len = level * LDR_LEN;
    if (len === 0) return { dx: 0, dy: 0 };
    if (!pos || pos === 6) return { dx: len, dy: 0 };            // E (default)
    const D = len * 0.707; // diagonal distance
    switch (pos) {
        case 1: return { dx: -D, dy: D };      // SW
        case 2: return { dx: 0, dy: len };      // S
        case 3: return { dx: D, dy: D };        // SE
        case 4: return { dx: -len, dy: 0 };     // W
        case 5: return { dx: len, dy: 0 };      // default (E)
        case 7: return { dx: -D, dy: -D };      // NW
        case 8: return { dx: 0, dy: -len };     // N
        case 9: return { dx: D, dy: -D };       // NE
        default: return { dx: len, dy: 0 };
    }
}

// Position data block so the leader line endpoint aligns with the correct edge/line.
// FDB anchor varies by direction:
//   N:  left edge, between lines 3-4    NE: left edge, between lines 2-3
//   E:  left edge, between lines 2-3    SE: left edge, between lines 1-2
//   S:  left edge, between lines 1-2    SW: right edge, between lines 1-2
//   W:  right edge, between lines 2-3   NW: right edge, between lines 2-3
// xShift: 0 = left-aligned (text extends right), -1 = right-aligned (text extends left)
function getDbAnchor(gufi, numLines) {
    const pos = dbPositions.get(gufi) || 6;
    const isLeft = (pos === 1 || pos === 4 || pos === 7);

    if (numLines === 2) {
        // LDB: anchor between lines 1-2 for all directions
        return { xShift: isLeft ? -1 : 0, yShift: -LINE_H };
    }

    // FDB (4 lines): direction-specific anchor
    switch (pos) {
        case 8: return { xShift: 0,  yShift: -3 * LINE_H };  // N:  left edge, between 3-4
        case 9: return { xShift: 0,  yShift: -2 * LINE_H };  // NE: left edge, between 2-3
        case 5:
        case 6: return { xShift: 0,  yShift: -2 * LINE_H };  // E:  left edge, between 2-3
        case 3: return { xShift: 0,  yShift: -LINE_H };       // SE: left edge, between 1-2
        case 2: return { xShift: 0,  yShift: -LINE_H };       // S:  left edge, between 1-2
        case 1: return { xShift: -1, yShift: -LINE_H };       // SW: right edge, between 1-2
        case 4: return { xShift: -1, yShift: -2 * LINE_H };   // W:  right edge, between 2-3
        case 7: return { xShift: -1, yShift: -2 * LINE_H };   // NW: right edge, between 2-3
        default: return { xShift: 0, yShift: -2 * LINE_H };
    }
}

// Check if flight is in reduced separation area (at or below FL230)
function isReducedSep(f) {
    const alt = f.reportedAltitude ?? f.assignedAltitude;
    return alt != null && alt <= 23000;
}

function getSymbolClass(f) {
    // Reduced separation: at or below FL230 → dot
    if (f.callsign && isReducedSep(f)) return 'ac-sym-reduced-sep';
    // SFDPS en route flights are virtually all transponder-equipped correlated targets.
    if (f.callsign) return 'ac-sym-corr-bcn';      // \ Correlated Beacon (most common)
    if (f.squawk) return 'ac-sym-uncorr-bcn';       // / Uncorrelated Beacon
    return 'ac-sym-flat-track';                      // ◇ Unknown/no identification
}

// History symbol character per target type (drawn on canvas)
function getSymbolChar(f) {
    // Reduced separation: at or below FL230 → dot
    if (f.callsign && isReducedSep(f)) return '\u2022';  // • dot
    if (f.callsign) return '\\';   // Correlated Beacon (most common)
    if (f.squawk) return '/';      // Uncorrelated Beacon
    return '\u25C7';               // ◇ Unknown
}

// Should column 0 "R" indicator show? (track not under our control)
// R = position does not own the track:
//   - Outgoing ACCEPTED/completed: we gave it away → R
//   - Incoming PROPOSED: offered to us but not yet accepted → R
//   - Incoming ACCEPTED/completed: we accepted, we own it → no R
//   - Outgoing PROPOSED: we initiated but still own it → no R
//   - Other tracks not ours at all → R
function shouldShowR(f, cls) {
    if (!myFacility || mySectors.size === 0) return false;
    if (cls === 'emrg') return false;

    // Controlling sector is authoritative — trust what SFDPS says
    if (cls === 'own') return false;
    const ctrlFac = f.controllingFacility || '';
    const ctrlSec = f.controllingSector || '';
    if (ctrlFac === myFacility && mySectors.has(ctrlSec)) return false;

    // Active handoff involving our sector(s)
    const hoEvt = hoEventType(f.handoffEvent);
    if (hoEvt && f.handoffReceiving) {
        const recvFac = extractFac(f.handoffReceiving);
        const recvSec = extractSec(f.handoffReceiving);
        const xferFac = extractFac(f.handoffTransferring);
        const xferSec = extractSec(f.handoffTransferring);
        const recvIsMe = recvFac === myFacility && mySectors.has(recvSec);
        const xferIsMe = xferFac === myFacility && mySectors.has(xferSec);

        if (xferIsMe && hoEvt === 'PROPOSED') return false;  // We initiated, still own it
        if (xferIsMe && hoEvt === 'ACCEPTED') return true;   // We gave it away
        if (recvIsMe && hoEvt === 'PROPOSED') return true;    // Incoming, not yet accepted
        if (recvIsMe && hoEvt === 'ACCEPTED') return false;   // We accepted, we own it
    }

    // Completed handoff — informational (O display), R follows controlling sector above
    const completed = hoCompletedInfo.get(f.gufi);
    if (completed) {
        const recvIsMe = extractFac(completed.receiving) === myFacility && mySectors.has(extractSec(completed.receiving));
        if (recvIsMe) return false;  // Incoming completed — we now own it, no R
        const xferIsMe = extractFac(completed.transferring) === myFacility && mySectors.has(extractSec(completed.transferring));
        if (xferIsMe) return true;   // Outgoing completed — show R
    }

    // Default: R for any track we don't own
    return true;
}

// Determine if a track should show FDB (full data block) or LDB (limited)
function shouldShowFdb(gufi, cls) {
    // User override takes priority
    if (fdbOverrides.has(gufi)) return fdbOverrides.get(gufi);
    // Default: own and handoff tracks get FDB, others get LDB
    return cls === 'own' || cls === 'ho' || cls === 'emrg';
}

function buildMarkerHtml(f, cls) {
    const isEmrg = cls === 'emrg';
    const emrgCls = isEmrg ? ' emrg' : '';

    // Current position: target symbol with diamond overlay
    const symClass = getSymbolClass(f);
    const symChar = getSymbolChar(f);
    // All target symbols get the diamond overlay; the character sits inside it
    let html = `<div class="ac-sym-target${emrgCls}">${esc(symChar)}</div>`;
    html += `<div class="ac-sym-flat-track${emrgCls}"></div>`;

    if (!showFdb) return html;

    const color = isEmrg ? EMRG_COLOR : TRACK_COLOR;
    const ldr = getLeaderOffset(f.gufi);
    const useFdb = shouldShowFdb(f.gufi, cls);
    const numLines = useFdb ? 4 : 2;
    const anchor = getDbAnchor(f.gufi, numLines);
    const isLeftPos = anchor.xShift === -1;
    const pos = dbPositions.get(f.gufi) || 6;
    const isVertical = (pos === 2 || pos === 8);

    // Gap from leader endpoint to data block text (R juts left from the block)
    const dbGap = Math.ceil(CHAR_W * 2);

    // Compute data block CSS position
    let leftStyle;
    if (isLeftPos) leftStyle = `right:${-ldr.dx + dbGap}px`;
    else if (isVertical) leftStyle = `left:${ldr.dx}px`;  // N/S: no horizontal gap
    else leftStyle = `left:${ldr.dx + dbGap}px`;

    // Left-positioned blocks: fixed min-width to prevent jitter during flash
    const leftExtra = isLeftPos ? ` min-width:${Math.ceil(CHAR_W * 8)}px;` : '';

    if (useFdb) {
        // Full Data Block (lines 1-4) — with leader line
        html += `<svg class="ac-leader" width="1" height="1" overflow="visible"><line x1="0" y1="0" x2="${ldr.dx}" y2="${ldr.dy}" stroke="${color}" stroke-width="1"/></svg>`;

        const db = formatDatablock(f, cls);
        const dbCls = isEmrg ? ' emrg' : '';

        // R indicator: child of data block, juts left on line 3
        let rHtml = '';
        if (shouldShowR(f, cls)) {
            rHtml = `<div class="ac-col0" style="position:absolute; left:${-Math.ceil(CHAR_W * 1.5)}px; top:${Math.round(LINE_H * 2)}px;">R</div>`;
        }

        html += `<div class="ac-db${dbCls}" style="${leftStyle}; top:${ldr.dy + anchor.yShift}px;${leftExtra}">${rHtml}${db}</div>`;
    } else if (ldbBrightness > 0) {
        // Limited Data Block (2 lines) — no leader line, right next to target
        const ldbOp = ldbBrightness / 100;
        const l1 = f.callsign || '???';
        const alt = f.reportedAltitude ?? f.assignedAltitude;
        const l2 = alt != null ? String(Math.round(alt / 100)).padStart(3, '0') : '';
        const dbCls = isEmrg ? ' emrg' : '';
        html += `<div class="ac-db${dbCls}" style="left:${Math.ceil(CHAR_W)}px; top:${-LINE_H}px; opacity:${ldbOp};">${l1}\n${l2}</div>`;
    }
    // ldbBrightness === 0 for LDB → no data block at all

    return html;
}

function formatDatablock(f, cls) {
    // Line 1: Field A (callsign)
    const l1 = f.callsign || '???';

    // Line 2: Field B + status + Field C (per ERAM spec)
    const l2 = formatAltLine(f);

    // Line 3: Field D (CID) + Field E
    const l3 = formatLine3(f, cls);

    // Line 4: Field F (full ICAO destination)
    const l4 = f.destination || '';

    return l4 ? `${l1}\n${l2}\n${l3}\n${l4}` : `${l1}\n${l2}\n${l3}`;
}

function formatAltLine(f) {
    const assigned = f.assignedAltitude;
    const reported = f.reportedAltitude;
    const interim = f.interimAltitude;

    const afl = assigned != null ? String(Math.round(assigned / 100)).padStart(3, '0') : '';
    const rfl = reported != null ? String(Math.round(reported / 100)).padStart(3, '0') : '';

    // Interim altitude → T indicator: {interim}T{reported}
    if (interim != null) {
        const ifl = String(Math.round(interim / 100)).padStart(3, '0');
        return rfl ? `${ifl}T${rfl}` : `${ifl}T`;
    }

    if (assigned == null && reported == null) return '';
    if (assigned == null) return rfl;

    // No Mode C reported → X indicator (assigned but no Mode C)
    if (reported == null) return `${afl}X`;

    const aAlt = Math.round(assigned / 100);
    const rAlt = Math.round(reported / 100);
    const diff = rAlt - aAlt;

    // Conforming (at altitude) → C, hide Field C: xxxC
    if (Math.abs(diff) <= 1) return `${afl}C`;

    // Non-conforming → procedural altitude indicator: xxxPyyy
    return `${afl}P${rfl}`;
}

function formatLine3(f, cls) {
    const cidVal = getCid(f);
    const cid = cidVal ? String(cidVal).padStart(3, ' ') : '   ';

    // Emergency squawks in Field E
    if (f.squawk === '7700') return `${cid} EMRG`;
    if (f.squawk === '7600') return `${cid} RDOF`;
    if (f.squawk === '7500') return `${cid} HIJK`;
    if (f.squawk === '7400') return `${cid} LLNK`;

    // Active handoff flash in Field E — uses global flashTime so ALL tracks sync
    // H/O occupies the single-letter identifier position directly after CID (no space)
    // All flash phases are padded to consistent width to prevent left-positioned block jitter
    const hoEvt = hoEventType(f.handoffEvent);
    if (hoEvt && f.handoffReceiving) {
        const suffix = handoffSuffix(f.handoffReceiving, f.handoffTransferring);
        const hoStr = `${cid}${hoEvt === 'PROPOSED' ? 'H' : 'O'}${suffix}`;
        const gs = f.groundSpeed != null ? String(Math.round(f.groundSpeed)).padStart(3, '0') : '';
        const gsStr = gs ? `${cid} ${gs}` : cid;
        const padLen = Math.max(hoStr.length, gsStr.length);
        if (hoEvt === 'PROPOSED') {
            // Fast blink: 0.5s on/off, alternate H-xx / GS every 6s
            const tick = Math.floor(flashTime / 500) % 24;
            const phase = tick < 12 ? 0 : 1;
            const visible = tick % 2 === 0;
            if (!visible) return cid.padEnd(padLen);
            if (phase === 0) return hoStr.padEnd(padLen);
            return gsStr.padEnd(padLen);
        } else {
            // Slow 6-second cycle: 3s O-xx, 3s GS (no rapid on/off flashing)
            const phase = Math.floor(flashTime / 3000) % 2;
            if (phase === 0) return hoStr.padEnd(padLen);
            return gsStr.padEnd(padLen);
        }
    }

    // Completed handoff — rotate O indicator / groundspeed for 60 seconds (5 cycles of 12s)
    const completed = hoCompletedInfo.get(f.gufi);
    if (completed && flashTime - completed.time < 60000) {
        const suffix = handoffSuffix(completed.receiving, completed.transferring);
        const hoStr = `${cid}O${suffix}`;
        const gs = f.groundSpeed != null ? String(Math.round(f.groundSpeed)).padStart(3, '0') : '';
        const gsStr = gs ? `${cid} ${gs}` : cid;
        const padLen = Math.max(hoStr.length, gsStr.length);
        // 12s per cycle: 6s O indicator, 6s groundspeed
        const phase = Math.floor((flashTime - completed.time) / 6000) % 2;
        if (phase === 0) return hoStr.padEnd(padLen);
        return gsStr.padEnd(padLen);
    }

    // Normal: CID + groundspeed
    const gs = f.groundSpeed != null ? String(Math.round(f.groundSpeed)).padStart(3, '0') : '';
    return gs ? `${cid} ${gs}` : `${cid}`;
}

// Build handoff suffix: intra-facility = -xx, inter-facility = Nxx (handoff code)
function handoffSuffix(receiving, transferring) {
    const recvFac = extractFac(receiving);
    const recvSec = extractSec(receiving);
    const xferFac = transferring ? extractFac(transferring) : '';
    if (!recvFac || !recvSec) return `-${(recvSec || '??').padStart(2, '0')}`;
    // Inter-facility: use handoff code of receiving facility
    if (xferFac && xferFac !== recvFac) {
        const code = getHandoffCode(recvFac);
        return `${code}${recvSec.padStart(2, '0')}`;
    }
    // Intra-facility: use dash
    return `-${recvSec.padStart(2, '0')}`;
}

// ════════════════════════════════════════════════════════════════════════════
// History tracking
// ════════════════════════════════════════════════════════════════════════════
function addHistoryPoint(gufi, lat, lon, sym) {
    if (!flightHistory.has(gufi)) flightHistory.set(gufi, []);
    const hist = flightHistory.get(gufi);
    hist.push({ lat, lon, sym: sym || '\\' });
    if (hist.length > MAX_HISTORY) hist.shift();
}

// ════════════════════════════════════════════════════════════════════════════
// WebSocket
// ════════════════════════════════════════════════════════════════════════════
function connectWs() {
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    const ws = new WebSocket(`${proto}//${location.host}/ws`);

    ws.onopen = () => {
        wsConnected = true;
        document.getElementById('connection-status').textContent = 'Connected';
        document.getElementById('connection-status').style.color = '#cccc44';
    };

    ws.onclose = () => {
        wsConnected = false;
        document.getElementById('connection-status').textContent = 'Disconnected \u2014 reconnecting...';
        document.getElementById('connection-status').style.color = '#cc4444';
        setTimeout(connectWs, 3000);
    };

    ws.onmessage = (evt) => {
        const msg = JSON.parse(evt.data);

        if (msg.type === 'snapshot') {
            // Fresh start — clear markers but preserve history across reconnects
            for (const [, m] of markers) map.removeLayer(m);
            markers.clear();
            flights.clear();
            pendingPositions.clear();
            for (const f of msg.data) {
                flights.set(f.gufi, f);
                trackFacility(f);
            }
            lastScanTime = performance.now(); // reset scan clock
        } else if (msg.type === 'update') {
            const f = msg.data;
            trackFacility(f);

            // Apply datablock fields IMMEDIATELY (handoffs, altitude, callsign, etc.)
            // Only buffer position (lat/lon) for the 12-second scan cycle
            const existing = flights.get(f.gufi);
            if (existing) {
                // Capture old state BEFORE overwriting
                const oldHoEvt = hoEventType(existing.handoffEvent);
                const oldHoRecv = existing.handoffReceiving;
                const oldHoXfer = existing.handoffTransferring;
                const oldCuFac = existing.controllingFacility;
                const oldCuSec = existing.controllingSector;

                // Buffer new position for scan cycle
                if (f.latitude != null && f.longitude != null) {
                    pendingPositions.set(f.gufi, { lat: f.latitude, lon: f.longitude });
                }
                // Apply all non-position fields instantly
                for (const key in f) {
                    if (key === 'latitude' || key === 'longitude') continue;
                    existing[key] = f[key];
                }

                // Detect handoff completion via two paths:
                // 1) HO event cleared by server (HO-DONE) + CU matches recv
                // 2) CU changed to match recv (covers missed initiation, e.g. server restart)
                const newHoEvt = hoEventType(existing.handoffEvent);
                const cuChanged = existing.controllingFacility !== oldCuFac || existing.controllingSector !== oldCuSec;
                const recv = oldHoRecv || existing.handoffReceiving;
                if (recv && !hoCompletedInfo.has(f.gufi)) {
                    const recvFac = extractFac(recv);
                    const recvSec = extractSec(recv);
                    const cuMatchesRecv = existing.controllingFacility === recvFac && existing.controllingSector === recvSec;
                    // Path 1: server cleared handoff fields (event went active→inactive)
                    // Path 2: CU just changed to match recv
                    if (cuMatchesRecv && ((!newHoEvt && oldHoEvt) || cuChanged)) {
                        hoCompletedInfo.set(f.gufi, {
                            time: performance.now(),
                            receiving: recv,
                            transferring: oldHoXfer || existing.handoffTransferring || ''
                        });
                    }
                }
            } else {
                // New flight — add fully (including position)
                flights.set(f.gufi, f);
            }

            // Handoff targeting our sector → immediately set FDB + rebuild marker
            if (hoEventType(f.handoffEvent)) {
                const cur = flights.get(f.gufi);
                if (cur) {
                    const cls = classifyTrack(cur);
                    if (cls === 'ho' && !fdbOverrides.has(f.gufi)) {
                        fdbOverrides.set(f.gufi, true);
                        // Immediately invalidate marker for instant LDB→FDB transition
                        const marker = markers.get(f.gufi);
                        if (marker) {
                            const el = marker.getElement();
                            if (el) el._lastHash = '';
                        }
                        lastRenderTime = 0;
                    }
                }
            }
        } else if (msg.type === 'remove') {
            pendingPositions.delete(msg.data.gufi);
            flights.delete(msg.data.gufi);
            flightHistory.delete(msg.data.gufi);
            fdbOverrides.delete(msg.data.gufi);
            wasOwnOrHo.delete(msg.data.gufi);
            hoCompletedInfo.delete(msg.data.gufi);
            lastVisibleAt.delete(msg.data.gufi);
            const m = markers.get(msg.data.gufi);
            if (m) { map.removeLayer(m); markers.delete(msg.data.gufi); }
        } else if (msg.type === 'stats') {
            msgRate = msg.data.rate;
        }
    };
}
connectWs();

// ════════════════════════════════════════════════════════════════════════════
// Facility/sector tracking
// ════════════════════════════════════════════════════════════════════════════
function trackFacility(f) {
    const fac = f.controllingFacility || f.reportingFacility || '';
    if (!fac) return;
    const sec = f.controllingSector || '';
    if (!knownFacilities.has(fac)) knownFacilities.set(fac, new Set());
    if (sec) knownFacilities.get(fac).add(sec);
}

let _lastFacilityInDropdown = false;
function rebuildFacilityDropdown() {
    const sel = document.getElementById('sel-facility');
    const facs = [...knownFacilities.keys()].filter(f => f.startsWith('Z')).sort();
    let html = '<option value="">All</option>';
    for (const fac of facs) html += `<option value="${esc(fac)}">${esc(fac)}</option>`;
    sel.innerHTML = html;
    // Restore selection (myFacility may have been set from URL before facilities were known)
    sel.value = myFacility || '';
    // First time our facility appears in the dropdown — trigger boundary display
    if (myFacility && !_lastFacilityInDropdown && facs.includes(myFacility)) {
        _lastFacilityInDropdown = true;
        showBoundariesForFacility(myFacility);
        rebuildSectorCheckboxes();
    }
}

function rebuildSectorCheckboxes() {
    const container = document.getElementById('sector-checkboxes');
    if (!myFacility) {
        container.innerHTML = '<span style="color:#666; font-size:10px;">Select facility first</span>';
        return;
    }
    const secs = knownFacilities.has(myFacility) ? [...knownFacilities.get(myFacility)].sort() : [];
    if (secs.length === 0) {
        container.innerHTML = '<span style="color:#666; font-size:10px;">No sectors found yet</span>';
        return;
    }
    let html = '';
    for (const sec of secs) {
        const checked = mySectors.has(sec) ? ' checked' : '';
        html += `<label style="display:block; padding:1px 0; cursor:pointer; color:#aaa;">` +
            `<input type="checkbox" class="sec-chk" value="${esc(sec)}"${checked} style="accent-color:#cccc44;"> ${esc(sec)}` +
            `</label>`;
    }
    container.innerHTML = html;
    container.querySelectorAll('.sec-chk').forEach(chk => {
        chk.addEventListener('change', function () {
            if (this.checked) {
                mySectors.add(this.value);
            } else {
                mySectors.delete(this.value);
                // Deactivating a sector: revert all flights associated with that sector to LDB
                demoteSectorFlights(this.value);
            }
            invalidateAllMarkers(); // immediately update R indicators and FDB/LDB
            saveSettingsToUrl();
        });
    });
}

// When a sector is deactivated, revert all flights that were own/ho for that sector back to LDB
function demoteSectorFlights(sector) {
    for (const [gufi, f] of flights) {
        const fac = f.controllingFacility || f.reportingFacility || '';
        const sec = f.controllingSector || '';
        const hoRecvSec = extractSec(f.handoffReceiving);
        const hoXferSec = extractSec(f.handoffTransferring);
        // Flight belongs to the deactivated sector if it's controlled by it or in handoff with it
        if (fac === myFacility && sec === sector ||
            extractFac(f.handoffReceiving) === myFacility && hoRecvSec === sector ||
            extractFac(f.handoffTransferring) === myFacility && hoXferSec === sector) {
            fdbOverrides.delete(gufi);
            wasOwnOrHo.delete(gufi);
        }
    }
}

function esc(s) {
    return s.replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ════════════════════════════════════════════════════════════════════════════
// Change detection — lightweight hash to avoid rebuilding marker HTML
// ════════════════════════════════════════════════════════════════════════════
function flightHash(f, cls) {
    const useFdb = shouldShowFdb(f.gufi, cls);
    // Flash animation is handled by the 500ms flash timer (data block text only),
    // so flashKey is NOT in the hash — prevents full marker rebuild every tick.
    // Include hoCompleted + R state so marker rebuilds when handoff completes
    const hoc = hoCompletedInfo.has(f.gufi) ? 1 : 0;
    const rInd = shouldShowR(f, cls) ? 1 : 0;
    const dbPos = dbPositions.get(f.gufi) || 0;
    const ldrLen = ldrLenOverrides.get(f.gufi) ?? 1;
    return `${f.latitude}|${f.longitude}|${f.callsign}|${f.reportedAltitude}|${f.assignedAltitude}|${f.interimAltitude}|${f.squawk}|${f.handoffEvent}|${f.handoffReceiving}|${f.controllingFacility}|${f.controllingSector}|${f.groundSpeed}|${f.destination}|${getCid(f)}|${cls}|${useFdb}|${useFdb ? 0 : ldbBrightness}|${hoc}|${rInd}|${dbPos}|${ldrLen}`;
}

// ════════════════════════════════════════════════════════════════════════════
// Render loop — guaranteed to never stop via requestAnimationFrame-first
// ════════════════════════════════════════════════════════════════════════════
let lastRenderTime = 0;

// Force all markers to rebuild on next render (invalidate hashes)
function invalidateAllMarkers() {
    for (const [, m] of markers) {
        const el = m.getElement();
        if (el) el._lastHash = '';
    }
    lastRenderTime = 0; // trigger immediate render on next frame
}

function render() {
    requestAnimationFrame(render);  // ALWAYS schedule next — loop never dies

    const now = performance.now();
    if (now - lastRenderTime < RENDER_INTERVAL) return;
    lastRenderTime = now;

    try {
        doRender();
    } catch (e) {
        console.error('[Render]', e);
    }
}

function applyScanCycle() {
    // Apply buffered positions (lat/lon only) — datablock fields were already applied instantly
    for (const [gufi, pos] of pendingPositions) {
        const f = flights.get(gufi);
        if (!f) continue;
        // Record history from old position
        if (f.latitude != null) {
            const dlat = Math.abs(f.latitude - pos.lat);
            const dlon = Math.abs(f.longitude - pos.lon);
            if (dlat > 0.0001 || dlon > 0.0001) {
                addHistoryPoint(gufi, f.latitude, f.longitude, getSymbolChar(f));
            }
        }
        f.latitude = pos.lat;
        f.longitude = pos.lon;
    }
    pendingPositions.clear();
}

function doRender() {
    // Check if a scan cycle has elapsed
    const now = performance.now();
    if (now - lastScanTime >= SCAN_INTERVAL) {
        applyScanCycle();
        lastScanTime = now;
    }

    const mapBounds = map.getBounds();
    const onScreenGufis = new Set();
    const counts = { own: 0, ho: 0, other: 0, emrg: 0 };

    for (const [gufi, f] of flights) {
        if (!isVisible(f)) continue;
        lastVisibleAt.set(gufi, now);  // stamp for grace period

        const cls = classifyTrack(f);
        counts[cls]++;

        // Sticky FDB: when a track transitions from own/ho to other, keep FDB
        if (cls === 'own' || cls === 'ho') {
            wasOwnOrHo.add(gufi);
        } else if (cls === 'other' && wasOwnOrHo.has(gufi) && !fdbOverrides.has(gufi)) {
            fdbOverrides.set(gufi, true);
        }

        // Viewport culling — count all visible flights but only render on-screen ones
        if (!mapBounds.contains([f.latitude, f.longitude])) continue;

        onScreenGufis.add(gufi);
        const ll = [f.latitude, f.longitude];
        const hash = flightHash(f, cls);

        const existing = markers.get(gufi);
        if (existing) {
            existing.setLatLng(ll);
            const el = existing.getElement();
            if (el) {
                // Unhide if previously hidden (flight became visible again)
                if (el.style.display === 'none') el.style.display = '';
                // Only rebuild HTML when flight data actually changes
                if (el._lastHash !== hash) {
                    el.innerHTML = buildMarkerHtml(f, cls);
                    el._lastHash = hash;
                }
            }
        } else {
            const html = buildMarkerHtml(f, cls);
            const icon = L.divIcon({ className: 'ac-group', html, iconSize: [0, 0], iconAnchor: [0, 0] });
            const m = L.marker(ll, { icon, pane: 'targets', interactive: false });
            m.addTo(map);
            const el = m.getElement();
            if (el) {
                el._lastHash = hash;
                el.style.pointerEvents = 'auto';
                el.style.cursor = 'pointer';
                el.addEventListener('click', () => toggleTrackSelect(gufi));
            }
            markers.set(gufi, m);
        }
    }

    // Persistent markers: only REMOVE markers for flights that no longer exist (server removed).
    // All other off-screen/invisible flights just get hidden — no DOM destroy/recreate flicker.
    for (const [gufi, m] of markers) {
        if (!flights.has(gufi)) {
            map.removeLayer(m);
            markers.delete(gufi);
        } else if (!onScreenGufis.has(gufi)) {
            const el = m.getElement();
            if (el && el.style.display !== 'none') el.style.display = 'none';
        }
    }

    // Redraw canvas overlay
    drawOverlay();

    // Update counters
    document.getElementById('cnt-own').textContent = counts.own;
    document.getElementById('cnt-ho').textContent = counts.ho;
    document.getElementById('cnt-other').textContent = counts.other;
    document.getElementById('cnt-total').textContent = counts.own + counts.ho + counts.other + counts.emrg;
}

requestAnimationFrame(render);

// ── Handoff flash timer (500ms) ─────────────────────────────────────────────
// Updates DATA BLOCK TEXT for tracks in active handoff OR completed handoff (O display).
// Does NOT rebuild the entire marker — symbol and leader line stay intact.
setInterval(() => {
    // Update global flash reference — ALL tracks see the same phase
    flashTime = performance.now();

    // Cleanup expired hoCompletedInfo entries
    for (const [gufi, info] of hoCompletedInfo) {
        if (flashTime - info.time >= 60000) hoCompletedInfo.delete(gufi);
    }

    for (const [gufi, m] of markers) {
        const f = flights.get(gufi);
        if (!f) continue;

        const hasActiveHo = hoEventType(f.handoffEvent) && f.handoffReceiving;
        const hasCompletedHo = hoCompletedInfo.has(gufi);
        if (!hasActiveHo && !hasCompletedHo) continue;

        const el = m.getElement();
        if (!el) continue;
        const dbEl = el.querySelector('.ac-db');
        if (!dbEl) continue;
        const cls = classifyTrack(f);
        if (shouldShowFdb(gufi, cls)) {
            // Preserve R child element when updating text
            const savedR = dbEl.querySelector('.ac-col0');
            dbEl.textContent = formatDatablock(f, cls);
            if (savedR) dbEl.appendChild(savedR);
        }

        // Sync R indicator with handoff state — R is a child of the data block
        const rNow = shouldShowFdb(gufi, cls) && shouldShowR(f, cls);
        const rEl = dbEl.querySelector('.ac-col0');
        if (rNow && !rEl) {
            const div = document.createElement('div');
            div.className = 'ac-col0';
            div.style.cssText = `position:absolute; left:${-Math.ceil(CHAR_W * 1.5)}px; top:${Math.round(LINE_H * 2)}px;`;
            div.textContent = 'R';
            dbEl.appendChild(div);
        } else if (!rNow && rEl) {
            rEl.remove();
        }
    }
}, 500);

// ════════════════════════════════════════════════════════════════════════════
// Sidebar controls
// ════════════════════════════════════════════════════════════════════════════
document.getElementById('sidebar-toggle').addEventListener('click', function () {
    const sidebar = document.getElementById('sidebar');
    sidebar.classList.toggle('collapsed');
    this.innerHTML = sidebar.classList.contains('collapsed') ? '&#9654;' : '&#9664;';
    // Let Leaflet recalculate map size after transition
    setTimeout(() => map.invalidateSize(), 250);
});

document.getElementById('sel-facility').addEventListener('change', function () {
    myFacility = this.value;
    mySectors.clear();
    // Changing facility: revert all tracks to default LDB
    fdbOverrides.clear();
    wasOwnOrHo.clear();
    invalidateAllMarkers();
    rebuildSectorCheckboxes();
    showBoundariesForFacility(myFacility);
    saveSettingsToUrl();
});

document.getElementById('sel-histcount').addEventListener('change', function () {
    MAX_HISTORY = parseInt(this.value);
    for (const [, hist] of flightHistory) {
        while (hist.length > MAX_HISTORY) hist.shift();
    }
    saveSettingsToUrl();
});

document.getElementById('rng-ldb-brightness').addEventListener('input', function () {
    ldbBrightness = parseInt(this.value);
    document.getElementById('lbl-ldb-brightness').textContent = ldbBrightness;
    saveSettingsToUrl();
});

document.getElementById('sel-vector').addEventListener('change', function () {
    vectorMinutes = parseInt(this.value);
    saveSettingsToUrl();
});

document.getElementById('chk-boundaries').addEventListener('change', function () {
    showBoundaries = this.checked;
    if (showBoundaries) showBoundariesForFacility(myFacility);
    else if (activeBoundaryArtcc) {
        for (const cat of BOUNDARY_CATS) {
            const key = `${activeBoundaryArtcc}:${cat}`;
            if (boundaryLayers[key]) map.removeLayer(boundaryLayers[key]);
        }
    }
    saveSettingsToUrl();
});

for (const [cat, id] of Object.entries(BOUNDARY_CAT_SLIDER)) {
    const lblId = BOUNDARY_CAT_LABEL[cat];
    document.getElementById(id).addEventListener('input', function () {
        setBoundaryBrightness(cat, parseInt(this.value));
        document.getElementById(lblId).textContent = this.value;
    });
    document.getElementById(id).addEventListener('change', function () {
        setBoundaryBrightness(cat, parseInt(this.value));
        document.getElementById(lblId).textContent = this.value;
        saveSettingsToUrl();
    });
}

document.getElementById('chk-mapbg').addEventListener('change', function () {
    showMapBg = this.checked;
    if (showMapBg) tileLayer.addTo(map);
    else map.removeLayer(tileLayer);
    saveSettingsToUrl();
});

document.getElementById('sel-fontsize').addEventListener('change', function () {
    fontSize = parseInt(this.value);
    updateFontSize();
    saveSettingsToUrl();
});

document.getElementById('inp-alt-low').addEventListener('change', function () {
    altFilterLow = parseInt(this.value) || 0;
    saveSettingsToUrl();
});

document.getElementById('inp-alt-high').addEventListener('change', function () {
    altFilterHigh = parseInt(this.value) || 999;
    saveSettingsToUrl();
});

function updateFontSize() {
    CHAR_W = fontSize * 0.625;
    LINE_H = fontSize * 1.25;
    // Update data block and symbol CSS dynamically
    let styleEl = document.getElementById('dynamic-fontsize');
    if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = 'dynamic-fontsize';
        document.head.appendChild(styleEl);
    }
    styleEl.textContent = `
        .ac-db, .ac-col0, .ac-line0 {
            font-size: ${fontSize}px !important;
            line-height: ${LINE_H}px !important;
        }
    `;
}

setInterval(() => {
    rebuildFacilityDropdown();
    rebuildSectorCheckboxes();
    document.getElementById('stat-flights').textContent = flights.size;
    document.getElementById('stat-rate').textContent = msgRate;
}, 5000);

// ════════════════════════════════════════════════════════════════════════════
// Flight detail panel
// ════════════════════════════════════════════════════════════════════════════
function toggleTrackSelect(gufi) {
    const f = flights.get(gufi);
    if (!f) return;
    const cls = classifyTrack(f);

    // Own/handoff/emergency tracks: default FDB, clicking does NOT toggle to LDB
    if (cls === 'own' || cls === 'ho' || cls === 'emrg') {
        showFlightDetail(gufi);
        return;
    }

    // Other tracks: toggle between default LDB and FDB (quick look)
    if (fdbOverrides.has(gufi)) {
        fdbOverrides.delete(gufi);  // back to default LDB
    } else {
        fdbOverrides.set(gufi, true);  // promote to FDB
    }

    showFlightDetail(gufi);
}

function showFlightDetail(gufi) {
    selectedGufi = gufi;
    const f = flights.get(gufi);
    if (!f) return;

    document.getElementById('fd-title').textContent =
        `${f.callsign || '???'}  ${f.aircraftType || ''}`;

    const cls = classifyTrack(f);
    const heading = (f.trackVelocityX != null && f.trackVelocityY != null)
        ? `${Math.round((Math.atan2(f.trackVelocityX, f.trackVelocityY) * 180 / Math.PI + 360) % 360)}\u00b0` : '';
    const tvSpd = (f.trackVelocityX != null && f.trackVelocityY != null)
        ? `${Math.round(Math.sqrt(f.trackVelocityX ** 2 + f.trackVelocityY ** 2))} kt` : '';

    const rows = [
        ['ODP', `${f.origin || ''}\u2192${f.destination || ''}`],
        ['Track', cls === 'own' ? 'OWN' : cls === 'ho' ? 'HANDOFF' : cls === 'emrg' ? 'EMERGENCY' : 'OTHER'],
        ['Facility', `${f.controllingFacility || f.reportingFacility || ''}`],
        ['Sector', f.controllingSector || ''],
        ['Squawk', f.squawk],
        ['Assigned', f.assignedAltitude != null ? `FL${Math.round(f.assignedAltitude / 100)}` : ''],
        ['Reported', f.reportedAltitude != null ? `FL${Math.round(f.reportedAltitude / 100)}` : ''],
        ['Interim', f.interimAltitude != null ? `FL${Math.round(f.interimAltitude / 100)}` : ''],
        ['GS', f.groundSpeed != null ? `${Math.round(f.groundSpeed)} kt` : ''],
        ['Heading', heading],
        ['T/V Speed', tvSpd],
        ['Route', f.route || ''],
        ['Rules', f.flightRules || ''],
        ['STAR', f.star || ''],
        ['Coord Fix', f.coordinationFix || ''],
        ['Coord Time', f.coordinationTime || ''],
        ['ETD', f.actualDepartureTime || ''],
        ['ETA', f.eta || ''],
        ['Handoff', f.handoffEvent ? `${f.handoffEvent} ${f.handoffReceiving || ''} \u2190 ${f.handoffTransferring || ''}` : ''],
        ['HO Debug', (() => {
            const parts = [];
            const hoEvt = hoEventType(f.handoffEvent);
            if (hoEvt) parts.push(`active=${hoEvt}`);
            if (f.handoffReceiving) parts.push(`recv=${f.handoffReceiving}`);
            if (f.handoffTransferring) parts.push(`xfer=${f.handoffTransferring}`);
            if (f.handoffAccepting) parts.push(`accept=${f.handoffAccepting}`);
            const comp = hoCompletedInfo.get(f.gufi);
            if (comp) {
                const secsAgo = Math.round((performance.now() - comp.time) / 1000);
                parts.push(`completed=${secsAgo}s ago recv=${comp.receiving}`);
            }
            return parts.join(' | ');
        })()],
        ['CID', getCid(f) || f.computerId],
        ['Operator', f.operator],
        ['A/C Type', f.aircraftType || ''],
        ['Reg', f.registration || ''],
        ['Wake', f.wakeCategory],
        ['Equip', f.equipmentQualifier || ''],
        ['Datalink', f.dataLinkCode],
        ['Remarks', f.remarks || ''],
        ['Last msg', f.lastMsgSource],
        ['Last seen', f.lastSeen],
    ];

    let html = '';
    for (const [label, val] of rows) {
        if (!val) continue;
        html += `<div class="fd-row"><span class="fd-label">${label}</span><span class="fd-val">${esc(String(val))}</span></div>`;
    }
    document.getElementById('fd-body').innerHTML = html;
    document.getElementById('flight-detail-section').style.display = 'block';
}

function closeFd() {
    selectedGufi = null;
    document.getElementById('flight-detail-section').style.display = 'none';
}

setInterval(() => { if (selectedGufi) showFlightDetail(selectedGufi); }, 5000);

// ════════════════════════════════════════════════════════════════════════════
// URL-based settings persistence
// ════════════════════════════════════════════════════════════════════════════
function loadSettingsFromUrl() {
    const params = new URLSearchParams(window.location.hash.slice(1));
    myFacility = params.get('facility') || '';
    const sectors = params.get('sectors');
    mySectors = sectors ? new Set(sectors.split(',').filter(s => s)) : new Set();
    if (params.has('fdb')) showFdb = params.get('fdb') !== '0';
    if (params.has('history')) showHistory = params.get('history') !== '0';
    if (params.has('histcount')) MAX_HISTORY = parseInt(params.get('histcount')) || 5;
    if (params.has('vector')) vectorMinutes = parseInt(params.get('vector'));
    if (params.has('boundaries')) showBoundaries = params.get('boundaries') !== '0';
    if (params.has('bndbr')) {
        const vals = params.get('bndbr').split(',').map(Number);
        BOUNDARY_CATS.forEach((cat, i) => { if (!isNaN(vals[i])) boundaryBrightness[cat] = vals[i]; });
    }
    if (params.has('fontsize')) fontSize = parseInt(params.get('fontsize')) || 10;
    if (params.has('altlow')) altFilterLow = parseInt(params.get('altlow')) || 0;
    if (params.has('althigh')) altFilterHigh = parseInt(params.get('althigh')) || 999;
    if (params.has('ldb')) ldbBrightness = parseInt(params.get('ldb'));
    if (params.has('mapbg')) showMapBg = params.get('mapbg') !== '0';

    // Restore map position/zoom
    if (params.has('lat') && params.has('lng') && params.has('z')) {
        const lat = parseFloat(params.get('lat'));
        const lng = parseFloat(params.get('lng'));
        const z = parseInt(params.get('z'));
        if (!isNaN(lat) && !isNaN(lng) && !isNaN(z)) map.setView([lat, lng], z);
    }

    // Apply to UI controls
    document.getElementById('sel-facility').value = myFacility;
    document.getElementById('sel-histcount').value = MAX_HISTORY;
    document.getElementById('sel-vector').value = vectorMinutes;
    document.getElementById('chk-boundaries').checked = showBoundaries;
    for (const [cat, id] of Object.entries(BOUNDARY_CAT_SLIDER)) {
        document.getElementById(id).value = boundaryBrightness[cat];
        document.getElementById(BOUNDARY_CAT_LABEL[cat]).textContent = boundaryBrightness[cat];
    }
    document.getElementById('chk-mapbg').checked = showMapBg;
    document.getElementById('sel-fontsize').value = fontSize;
    document.getElementById('inp-alt-low').value = altFilterLow;
    document.getElementById('inp-alt-high').value = altFilterHigh;
    document.getElementById('rng-ldb-brightness').value = ldbBrightness;
    document.getElementById('lbl-ldb-brightness').textContent = ldbBrightness;
    updateFontSize();
    if (!showMapBg) map.removeLayer(tileLayer);
    showBoundariesForFacility(myFacility);
}

function saveSettingsToUrl() {
    const params = new URLSearchParams();
    if (myFacility) params.set('facility', myFacility);
    if (mySectors.size) params.set('sectors', [...mySectors].join(','));
    if (!showFdb) params.set('fdb', '0');
    if (!showHistory) params.set('history', '0');
    if (MAX_HISTORY !== 5) params.set('histcount', MAX_HISTORY);
    if (vectorMinutes !== 1) params.set('vector', vectorMinutes);
    if (!showBoundaries) params.set('boundaries', '0');
    const brVals = BOUNDARY_CATS.map(c => boundaryBrightness[c]);
    const defaultBr = [60, 60, 60, 0];
    if (brVals.join(',') !== defaultBr.join(',')) params.set('bndbr', brVals.join(','));
    if (!showMapBg) params.set('mapbg', '0');
    if (fontSize !== 10) params.set('fontsize', fontSize);
    if (altFilterLow !== 0) params.set('altlow', altFilterLow);
    if (altFilterHigh !== 999) params.set('althigh', altFilterHigh);
    if (ldbBrightness !== 70) params.set('ldb', ldbBrightness);
    // Map position/zoom
    const center = map.getCenter();
    params.set('lat', center.lat.toFixed(4));
    params.set('lng', center.lng.toFixed(4));
    params.set('z', map.getZoom());
    const hash = params.toString();
    history.replaceState(null, '', hash ? '#' + hash : window.location.pathname);
}

// ════════════════════════════════════════════════════════════════════════════
// Right-click pan (replaces default left-click drag)
// ════════════════════════════════════════════════════════════════════════════
const mapEl = document.getElementById('map');
mapEl.addEventListener('contextmenu', e => e.preventDefault());

let _rightDragging = false;
let _rightDragStart = null;

mapEl.addEventListener('mousedown', e => {
    if (e.button === 2) {
        _rightDragging = true;
        _rightDragStart = { x: e.clientX, y: e.clientY };
        mapEl.style.cursor = 'grabbing';
        e.preventDefault();
    }
});

document.addEventListener('mousemove', e => {
    if (!_rightDragging) return;
    const dx = e.clientX - _rightDragStart.x;
    const dy = e.clientY - _rightDragStart.y;
    map.panBy([-dx, -dy], { animate: false });
    _rightDragStart = { x: e.clientX, y: e.clientY };
});

document.addEventListener('mouseup', e => {
    if (e.button === 2 && _rightDragging) {
        _rightDragging = false;
        mapEl.style.cursor = '';
    }
});

// ════════════════════════════════════════════════════════════════════════════
// MCA (Message Composition Area)
// ════════════════════════════════════════════════════════════════════════════
const mca = {
    text: '',
    cursor: 0,
    overstrike: true,   // true = overstrike (_), false = insert (|)
    feedback: [],       // array of { type: 'ok'|'err'|'info', text: string }
    lastCommand: '',
    maxChars: 120,      // max total characters in preview area
};

function mcaInsertChar(ch) {
    if (mca.text.length >= mca.maxChars && !mca.overstrike) {
        mca.feedback = [{ type: 'err', text: 'MESSAGE TOO LONG' }];
        mcaRender();
        return;
    }
    if (mca.overstrike && mca.cursor < mca.text.length) {
        mca.text = mca.text.substring(0, mca.cursor) + ch + mca.text.substring(mca.cursor + 1);
    } else {
        if (mca.text.length >= mca.maxChars) {
            mca.feedback = [{ type: 'err', text: 'MESSAGE TOO LONG' }];
            mcaRender();
            return;
        }
        mca.text = mca.text.substring(0, mca.cursor) + ch + mca.text.substring(mca.cursor);
    }
    mca.cursor++;
    mcaRender();
}

function mcaBackspace() {
    if (mca.cursor > 0) {
        mca.text = mca.text.substring(0, mca.cursor - 1) + mca.text.substring(mca.cursor);
        mca.cursor--;
        mcaRender();
    }
}

function mcaDelete() {
    if (mca.cursor < mca.text.length) {
        mca.text = mca.text.substring(0, mca.cursor) + mca.text.substring(mca.cursor + 1);
        mcaRender();
    }
}

function mcaExecute() {
    const cmd = mca.text.trim();
    mca.lastCommand = mca.text;
    mca.text = '';
    mca.cursor = 0;
    if (!cmd) { mcaRender(); return; }
    const result = processCommand(cmd);
    mca.feedback = result.feedback || [];
    mcaRender();
}

function mcaClear() {
    mca.text = '';
    mca.cursor = 0;
    mca.feedback = [];
    mcaRender();
}

function mcaRecall() {
    mca.text = mca.lastCommand;
    mca.cursor = mca.text.length;
    mcaRender();
}

function mcaRender() {
    const previewEl = document.getElementById('mca-preview');
    const feedbackEl = document.getElementById('mca-feedback');

    // Preview: text with blinking cursor
    const before = esc(mca.text.substring(0, mca.cursor));
    if (mca.overstrike) {
        // Overstrike: cursor replaces character at position (or shows _ at end)
        const after = mca.cursor < mca.text.length ? esc(mca.text.substring(mca.cursor + 1)) : '';
        previewEl.innerHTML = before + '<span class="mca-cursor">_</span>' + after;
    } else {
        // Insert: cursor between characters (thin bar)
        const after = esc(mca.text.substring(mca.cursor));
        previewEl.innerHTML = before + '<span class="mca-cursor">|</span>' + after;
    }

    // Feedback area
    if (mca.feedback.length === 0) {
        feedbackEl.innerHTML = '';
    } else {
        feedbackEl.innerHTML = mca.feedback.map(f => {
            if (f.type === 'ok') return '<span style="color:#44cc44;">\u2713</span> ' + esc(f.text);
            if (f.type === 'err') return '<span style="color:#cc4444;">\u2717</span> ' + esc(f.text);
            return esc(f.text);
        }).join('\n');
    }
}

// ════════════════════════════════════════════════════════════════════════════
// Command processor
// ════════════════════════════════════════════════════════════════════════════

// Find flight by CID or callsign (case-insensitive)
// CID matching uses only the selected facility's CID (not fallback from other facilities)
function findFlight(id) {
    const needle = id.toUpperCase();
    // Try CID match first — only match against selected facility's CID
    if (myFacility) {
        for (const f of flights.values()) {
            const cid = f.computerIds && f.computerIds[myFacility];
            if (cid && cid === needle) return f;
        }
    }
    // Then callsign match
    for (const f of flights.values()) {
        if (f.callsign?.toUpperCase() === needle) return f;
    }
    return null;
}

function processCommand(cmd) {
    const parts = cmd.trim().split(/\s+/);
    const verb = parts[0]?.toUpperCase();

    // <1-9> <FLID> — Position data block (numpad layout)
    if (/^[1-9]$/.test(verb) && parts.length >= 2) {
        const pos = parseInt(verb);
        const flid = parts.slice(1).join('').toUpperCase();
        const f = findFlight(flid);
        if (f) {
            dbPositions.set(f.gufi, pos);
            // Invalidate marker hash so it rebuilds immediately
            const m = markers.get(f.gufi);
            if (m) { const el = m.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: 'OFFSET DATA BLK' },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // /<0-3> <FLID> — Set individual leader line length
    if (/^\/[0-3]$/.test(verb) && parts.length >= 2) {
        const level = parseInt(verb.charAt(1));
        const flid = parts.slice(1).join('').toUpperCase();
        const f = findFlight(flid);
        if (f) {
            ldrLenOverrides.set(f.gufi, level);
            const m3 = markers.get(f.gufi);
            if (m3) { const el = m3.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: `LDR LEN ${level}` },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // QF <callsign> — Query Flight plan → show in RA
    if (verb === 'QF' && parts.length >= 2) {
        const cs = parts.slice(1).join('').toUpperCase();
        const f = findFlight(cs);
        if (f) {
            showFlightInRA(f);
            return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
        }
        return { feedback: [{ type: 'err', text: 'FLIGHT NOT FOUND' }] };
    }

    // QD — clear Response Area
    if (verb === 'QD') {
        document.getElementById('ra-content').textContent = '';
        return { feedback: [{ type: 'ok', text: 'ACCEPT' }] };
    }

    // <FLID> — toggle FDB/LDB (single argument, not a known verb)
    if (parts.length === 1 && verb) {
        const f = findFlight(verb);
        if (f) {
            const cls = classifyTrack(f);
            const currentlyFdb = shouldShowFdb(f.gufi, cls);
            // Controlled flights (own/ho) cannot be toggled to LDB
            if (currentlyFdb && (cls === 'own' || cls === 'ho')) {
                return { feedback: [
                    { type: 'err', text: 'USER ACTION NOT ALLOWED ON A\nCONTROLLED FLIGHT' },
                    { type: 'info', text: `FORCED DATA BLK ${f.callsign}` }
                ]};
            }
            fdbOverrides.set(f.gufi, !currentlyFdb);
            // Invalidate marker hash so it rebuilds immediately
            const m2 = markers.get(f.gufi);
            if (m2) { const el = m2.getElement(); if (el) el._lastHash = ''; }
            lastRenderTime = 0;
            return { feedback: [
                { type: 'ok', text: 'ACCEPT' },
                { type: 'info', text: currentlyFdb ? 'SUPPRESS DATA BLK' : 'FORCE DATA BLK' },
                { type: 'info', text: `${f.callsign}/${getCid(f) || '???'}` }
            ]};
        }
    }

    return { feedback: [{ type: 'err', text: 'INVALID ENTRY' }] };
}

function showFlightInRA(f) {
    const ra = document.getElementById('ra-content');
    const now = new Date();
    const zulu = String(now.getUTCHours()).padStart(2, '0') + String(now.getUTCMinutes()).padStart(2, '0');
    const cidVal = getCid(f);
    const cid = cidVal ? String(cidVal).padStart(4, '0') : '????';
    // Sector display: prefix with ARTCC handoff code if different facility
    const ctrlFac = f.controllingFacility || '';
    const ctrlSec = f.controllingSector || '??';
    const sector = (ctrlFac && myFacility && ctrlFac !== myFacility)
        ? getHandoffCode(ctrlFac) + ctrlSec
        : ctrlSec;
    const cs = f.callsign || '???';
    const type = f.aircraftType || '????';
    const equip = f.equipmentQualifier ? '/' + f.equipmentQualifier : '';
    const bcn = f.squawk || '????';
    const spd = f.groundSpeed != null ? String(Math.round(f.groundSpeed)).padStart(4, ' ') : '    ';
    const aalt = f.assignedAltitude != null ? String(Math.round(f.assignedAltitude / 100)).padStart(3, '0') : '???';
    const origin = f.origin || '????';
    const dest = f.destination || '????';
    const route = f.route || '';
    const star = f.star || '';
    const remarks = f.remarks || '';

    let text = `${zulu}\n`;
    text += `${cid} ${cs}(${sector}) ${type}${equip}\n`;
    text += `${bcn} ${spd} ${aalt} ${origin}..\n`;
    text += `${route}${star ? '.' + star + '.' : ''}\n`;
    text += `..${dest}\n`;
    if (remarks) text += `${remarks}`;
    ra.textContent = text;
}

// ════════════════════════════════════════════════════════════════════════════
// Global keyboard capture → MCA
// ════════════════════════════════════════════════════════════════════════════
document.addEventListener('keydown', e => {
    // Don't capture when focused on sidebar form elements
    const tag = document.activeElement?.tagName;
    if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;

    // Escape → clear MCA
    if (e.key === 'Escape') { mcaClear(); e.preventDefault(); return; }

    // Ctrl+R → recall last command
    if (e.ctrlKey && (e.key === 'r' || e.key === 'R')) { mcaRecall(); e.preventDefault(); return; }

    // Ctrl+Delete → clear RA
    if (e.ctrlKey && e.key === 'Delete') {
        document.getElementById('ra-content').textContent = '';
        e.preventDefault(); return;
    }

    // PageUp / PageDown → cycle vector line minutes (0,1,2,4,8)
    const vectorSteps = [0, 1, 2, 4, 8];
    if (e.key === 'PageUp' && !e.ctrlKey) {
        const idx = vectorSteps.indexOf(vectorMinutes);
        const next = idx < vectorSteps.length - 1 ? vectorSteps[idx + 1] : vectorSteps[vectorSteps.length - 1];
        vectorMinutes = next;
        document.getElementById('sel-vector').value = vectorMinutes;
        saveSettingsToUrl();
        e.preventDefault(); return;
    }
    if (e.key === 'PageDown' && !e.ctrlKey) {
        const idx = vectorSteps.indexOf(vectorMinutes);
        const next = idx > 0 ? vectorSteps[idx - 1] : vectorSteps[0];
        vectorMinutes = next;
        document.getElementById('sel-vector').value = vectorMinutes;
        saveSettingsToUrl();
        e.preventDefault(); return;
    }

    // Enter → execute command
    if (e.key === 'Enter' && !e.ctrlKey) { mcaExecute(); e.preventDefault(); return; }

    // Ctrl+Enter → newline in preview
    if (e.key === 'Enter' && e.ctrlKey) { mcaInsertChar('\n'); e.preventDefault(); return; }

    // Arrow keys
    if (e.key === 'ArrowLeft') {
        if (mca.cursor > 0) mca.cursor--;
        mcaRender(); e.preventDefault(); return;
    }
    if (e.key === 'ArrowRight') {
        if (mca.cursor < mca.text.length) mca.cursor++;
        mcaRender(); e.preventDefault(); return;
    }

    // Home / End / Ctrl+PgUp / Ctrl+PgDn
    if (e.key === 'Home' || (e.ctrlKey && e.key === 'PageUp')) {
        mca.cursor = 0; mcaRender(); e.preventDefault(); return;
    }
    if (e.key === 'End' || (e.ctrlKey && e.key === 'PageDown')) {
        mca.cursor = mca.text.length; mcaRender(); e.preventDefault(); return;
    }

    // Backspace / Delete
    if (e.key === 'Backspace') { mcaBackspace(); e.preventDefault(); return; }
    if (e.key === 'Delete') { mcaDelete(); e.preventDefault(); return; }

    // Insert → toggle overstrike/insert mode
    if (e.key === 'Insert') { mca.overstrike = !mca.overstrike; mcaRender(); e.preventDefault(); return; }

    // Printable characters → type into MCA (uppercase)
    if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
        mcaInsertChar(e.key.toUpperCase());
        e.preventDefault();
        return;
    }
});

// ════════════════════════════════════════════════════════════════════════════
// MCA & RA box drag/drop (click to pick up, click to drop)
// ════════════════════════════════════════════════════════════════════════════
let _boxDragging = null;
let _boxDragOffset = { x: 0, y: 0 };

function saveBoxPosition(el) {
    const key = 'boxPos_' + el.id;
    localStorage.setItem(key, JSON.stringify({ left: el.style.left, top: el.style.top }));
}

function restoreBoxPosition(el) {
    const key = 'boxPos_' + el.id;
    const saved = localStorage.getItem(key);
    if (saved) {
        try {
            const pos = JSON.parse(saved);
            if (pos.left) el.style.left = pos.left;
            if (pos.top) { el.style.top = pos.top; el.style.bottom = 'auto'; }
        } catch(e) {}
    }
}

function dropBox() {
    if (!_boxDragging) return;
    saveBoxPosition(_boxDragging);
    _boxDragging.classList.remove('box-dragging');
    _boxDragging = null;
}

function setupBoxDrag(el) {
    restoreBoxPosition(el);
    el.addEventListener('mousedown', e => {
        if (e.button !== 0) return;
        e.stopPropagation();

        if (_boxDragging === el) {
            // Already dragging this box → drop it
            dropBox();
            return;
        }
        // Drop any currently dragged box
        if (_boxDragging) dropBox();
        // Pick up this box
        _boxDragging = el;
        el.classList.add('box-dragging');
        const rect = el.getBoundingClientRect();
        _boxDragOffset = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    });
}

document.addEventListener('mousemove', e => {
    if (!_boxDragging) return;
    const containerRect = _boxDragging.parentElement.getBoundingClientRect();
    _boxDragging.style.left = (e.clientX - containerRect.left - _boxDragOffset.x) + 'px';
    _boxDragging.style.top = (e.clientY - containerRect.top - _boxDragOffset.y) + 'px';
    _boxDragging.style.bottom = 'auto';
    _boxDragging.style.right = 'auto';
});

// Click outside the dragged box → drop it
document.addEventListener('mousedown', e => {
    if (_boxDragging && e.button === 0 && !_boxDragging.contains(e.target)) {
        dropBox();
    }
});

setupBoxDrag(document.getElementById('mca'));
setupBoxDrag(document.getElementById('ra'));

// ════════════════════════════════════════════════════════════════════════════
// Init
// ════════════════════════════════════════════════════════════════════════════
loadSettingsFromUrl();
rebuildFacilityDropdown();
rebuildSectorCheckboxes();

// Save map position/zoom on pan/zoom (debounced)
let _mapSaveTimer = null;
map.on('moveend', () => {
    clearTimeout(_mapSaveTimer);
    _mapSaveTimer = setTimeout(saveSettingsToUrl, 500);
});
</script>
</body>
</html>
